Index: src/test/mapred/org/apache/hadoop/mp/fft/TestDistFft.java
===================================================================
--- src/test/mapred/org/apache/hadoop/mp/fft/TestDistFft.java	(revision 0)
+++ src/test/mapred/org/apache/hadoop/mp/fft/TestDistFft.java	(revision 0)
@@ -0,0 +1,97 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.fft;
+
+import java.util.Random;
+
+import org.apache.hadoop.mp.math.PowerOfTwo_int;
+import org.apache.hadoop.mp.math.SchonhageStrassen;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Parse;
+import org.apache.hadoop.mp.util.Print;
+
+public class TestDistFft extends junit.framework.TestCase {
+  public void testParallelFft() {
+    final JavaUtil.Timer timer = new JavaUtil.Timer(false, false);
+    final PowerOfTwo_int D = PowerOfTwo_int.valueOf(1 << 4);
+    Print.println("D                = " + D);
+    final PowerOfTwo_int bitsPerElement = PowerOfTwo_int.valueOf(1 << 4);
+    Print.println("bitsPerElement   = " + bitsPerElement);
+    final int bitsPerDigit = 16;
+    final Zahlen Z = Zahlen.FACTORY.valueOf(bitsPerDigit, 4096, 1024);
+    final int modulusExponent = Math.max(D.value, bitsPerElement.value << 3) >> 1;
+    Print.println("modulusExponent  = " + modulusExponent);
+    final SchonhageStrassen schonhagestrassen = SchonhageStrassen.FACTORY.valueOf(
+        modulusExponent, bitsPerElement, D, Z);
+
+    final PowerOfTwo_int J = PowerOfTwo_int.values()[D.exponent >> 1];
+    final PowerOfTwo_int K = PowerOfTwo_int.values()[D.exponent - J.exponent];
+    final String dir = "test-" + Parse.currentTime2String();
+    final DistFft parameters = new DistFft(schonhagestrassen, false, J, K, dir);
+    parameters.printDetail("");
+
+    //setup input
+    final Zahlen.Element x = Z.random(JavaUtil.toInt(schonhagestrassen.digitsPerOperand()), new Random());
+    timer.tick("x = " + x.toBrief());
+    final Zahlen.Element[] a = x.split(schonhagestrassen.bitsPerElement.value, D.value);
+
+    final Zahlen.Element[][] reduce = new Zahlen.Element[J.value][K.value];
+
+    //inner
+    for(int k0 = 0; k0 < K.value; k0++) {
+      final Zahlen.Element[] t = new Zahlen.Element[J.value];
+      for(int k1 = 0; k1 < J.value; k1++) {
+        final int i = (k1 << K.exponent) + k0;
+        t[k1] = Z.newElement().set(a[i]);
+      }
+      parameters.dft(t, null);
+      parameters.scaleMultiplication(k0, t, null);
+      for(int j0 = 0; j0 < J.value; j0++) {
+        reduce[j0][k0] = t[j0];
+      }
+    }
+    
+    //outer
+    final Zahlen.Element[] b = new Zahlen.Element[D.value];
+    for(int j0 = 0; j0 < J.value; j0++) {
+      final Zahlen.Element[] t = reduce[j0];
+      parameters.dft(t, null);
+      for(int j1 = 0; j1 < K.value; j1++) {
+        final int i = (j1 << J.exponent) + j0;
+        b[i] = t[j1];
+      }
+    }
+    
+    //verify output
+    schonhagestrassen.parallel.fft(a, null);
+    //Print.print("a", a);
+    //Print.print("b", b);
+    for(int i = 0; i < J.value; i++) {
+      if (!b[i].equals(a[i])) {
+        Print.println("b[" + i + "] = ");
+        b[i].print(10);
+        Print.println("a[" + i + "] = ");
+        a[i].print(10);
+        Print.println("!b[j1].equals(a[i])");
+        throw new RuntimeException("!b[j1].equals(a[i])");
+      }
+    }
+    Print.print("DONE");
+  }
+}
Index: src/test/mapred/org/apache/hadoop/mp/math/TestFixedPointFraction.java
===================================================================
--- src/test/mapred/org/apache/hadoop/mp/math/TestFixedPointFraction.java	(revision 0)
+++ src/test/mapred/org/apache/hadoop/mp/math/TestFixedPointFraction.java	(revision 0)
@@ -0,0 +1,236 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.math;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.math.BigDecimal;
+import java.util.Random;
+
+import org.apache.hadoop.mp.math.BrentSalamin;
+import org.apache.hadoop.mp.math.FixedPointFraction;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Print;
+
+public class TestFixedPointFraction extends junit.framework.TestCase {
+  private static final Random RANDOM = JavaUtil.newRandom();
+  final JavaUtil.Timer timer = new JavaUtil.Timer(true, true);
+  final JavaUtil.WorkGroup workers = new JavaUtil.WorkGroup(BrentSalamin.class.getSimpleName(), 2, timer);
+  
+  static final BigDecimal TWO = BigDecimal.valueOf(2);
+  static final BigDecimal THREE = BigDecimal.valueOf(3);
+  
+  public void testFixedPointFraction() throws IOException {
+    final Zahlen Z = Zahlen.FACTORY.valueOf(8, 2, 1024);
+    final FixedPointFraction R = FixedPointFraction.FACTORY.valueOf(8, Z);
+    Print.println("R = " + R);
+    
+    final FixedPointFraction.Element x = R.newElement();
+    Print.println("x = " + x);
+    assertEquals(BigDecimal.ZERO, x.toBigDecimal());
+
+    final FixedPointFraction.Element y = R.valueOf(1);
+    y.printDetail("y");
+    assertTrue(y.isOne());
+    assertEquals(BigDecimal.ONE, y.toBigDecimal());
+    final FixedPointFraction.Element one = R.newElement().set(y);
+
+    y.plusEqual(y);
+    Print.println("y = " + y);
+    assertFalse(y.isOne());
+    assertEquals(TWO, y.toBigDecimal());
+    final FixedPointFraction.Element two = R.newElement().set(y);
+    
+    Print.println("x += y = " + x.plusEqual(y));
+    assertFalse(x.isOne());
+    assertEquals(TWO, x.toBigDecimal());
+
+    y.plusEqual(one);
+    Print.println("y = " + y);
+    assertFalse(y.isOne());
+    assertEquals(THREE, y.toBigDecimal());
+    
+    final BigDecimal DIGIT = BigDecimal.valueOf(Z.digitLimit.value);
+    x.shiftRightEqual_bits(Z.digitsPerArray.value << Z.bitsPerDigit.exponent);
+    BigDecimal expected = TWO.divide(DIGIT.pow(Z.digitsPerArray.value));
+    Print.println("x >>= " + Z.bitsPerDigit.value + " = " + x);
+    assertFalse(x.isOne());
+    assertEquals(expected, x.toBigDecimal());
+
+    x.plusEqual(y);
+    expected = expected.add(THREE);
+    x.printDetail("x += y = ");
+    assertFalse(x.isOne());
+    assertEquals(expected, x.toBigDecimal());
+    
+    x.multiplyEqual(x, workers);
+    x.printDetail("x *= x = ");
+    assertFalse(x.isOne());
+    expected = expected.multiply(expected);
+    assertEquals(expected, x.toBigDecimal());
+   
+    y.multiplyEqual(y, workers);
+    Print.println("y = " + y);
+    assertFalse(y.isOne());
+    assertEquals(THREE.multiply(THREE), y.toBigDecimal());
+
+    y.multiplyEqual(y, workers);
+    Print.println("y = " + y);
+    assertFalse(y.isOne());
+    assertEquals(BigDecimal.valueOf(81), y.toBigDecimal());
+
+    x.set(y).reciprocalEqual(workers);
+    Print.println("x = 1/y = " + x.toBigDecimal());
+
+    Print.println("two = " + two);
+    y.multiplyEqual(two, workers);
+    Print.println("y = " + y);
+    assertFalse(y.isOne());
+    assertEquals(BigDecimal.valueOf(162), y.toBigDecimal());
+
+    x.set(y);
+    Print.println("x = y = " + x.toBigDecimal());
+    y.reciprocalEqual(workers);
+    Print.println("y = 1/y = " + y.toBigDecimal());
+    
+    x.multiplyEqual(y, workers);
+    Print.println("x *= y = " + x.toBigDecimal());
+
+    y.set(R.valueOf(4));
+    Print.println("y = " + y.toBigDecimal());
+    x.set(y).reciprocalEqual(workers);
+    Print.println("x = 1/y = " + x.toBigDecimal());
+  }
+  
+  public void testSqrt() throws IOException {
+    final Zahlen Z = Zahlen.FACTORY.valueOf(8, 4, 1024);
+    final FixedPointFraction R = FixedPointFraction.FACTORY.valueOf(8, Z);
+    Print.println("R = " + R);
+    
+    {//Zahlen
+      final Zahlen.Element a = Z.newElement();
+      Print.println("a = " + a + " = " + a.toBigInteger());
+      a.plusEqual(16);
+      Print.println("a = " + a + " = " + a.toBigInteger());
+      a.approximateSqrtReciprocalEqual(workers);
+      Print.println("a = " + a + " = " + a.toBigInteger());
+    }
+    
+
+    final FixedPointFraction.Element x = R.newElement();
+    Print.println("x = " + x);
+    assertEquals(BigDecimal.ZERO, x.toBigDecimal());
+
+    final FixedPointFraction.Element a = R.valueOf(1);
+    assertTrue(a.isOne());
+    assertEquals(BigDecimal.ONE, a.toBigDecimal());
+
+    final FixedPointFraction.Element one = R.valueOf(1);
+    a.plusEqual(one);
+    Print.println("z = " + a.toBigDecimal());
+    assertFalse(a.isOne());
+    assertEquals(TWO, a.toBigDecimal());
+ 
+    a.negateEqual();
+    a.plusEqual(one);
+    a.plusEqual(one);
+    
+    final FixedPointFraction.Element y = R.newElement();
+    for(int i = 1; i < 10; i++) {
+      a.plusEqual(one);
+      Print.println("========================================================");
+      Print.println("a = " + a + " = " + a.toBigDecimal());
+      Print.println();
+  
+      x.set(a).sqrtReciprocalEqual(workers);
+      y.set(x);
+      
+      Print.println("x = 1/sqrt(a) = " + x.toBigDecimal());
+      x.printDetail("              = ");
+      x.multiplyEqual(x, workers);
+      Print.println("x^2 = " + x.toBigDecimal());
+      x.printDetail("    = ");
+      x.multiplyEqual(a, workers);
+      Print.println("ax^2 = " + assertOne(x.toBigDecimal()));
+
+      Print.println("--------------------------------------------------------");
+      x.set(y);
+      Print.println("x = " + x + " = " + x.toBigDecimal());
+      Print.println();
+      y.sqrtReciprocalEqual(workers);
+
+      Print.println("y = 1/sqrt(x) = " + y.toBigDecimal());
+      y.printDetail("              = ");
+      y.multiplyEqual(y, workers);
+      Print.println("y^2 = " + y.toBigDecimal());
+      y.printDetail("    = ");
+      y.multiplyEqual(x, workers);
+      Print.println("xy^2 = " + assertOne(y.toBigDecimal()));
+    }
+  }
+  
+  static final BigDecimal DELTA = BigDecimal.valueOf(0.5).pow(20);
+  static BigDecimal assertOne(final BigDecimal x) {
+    final BigDecimal delta = x.subtract(BigDecimal.ONE).abs();
+    assertTrue(delta.compareTo(DELTA) <= 0);
+    return x;
+  }
+
+  public void testSerialization() throws IOException {
+    final Zahlen Z = Zahlen.FACTORY.valueOf(16, 2, 1024);
+    final FixedPointFraction R = FixedPointFraction.FACTORY.valueOf(16, Z);
+    assertTrue(R == FixedPointFraction.FACTORY.valueOf(R.serialize()));
+
+    {
+      final ByteArrayOutputStream ba = new ByteArrayOutputStream();
+      final DataOutputStream baout = new DataOutputStream(ba);
+      R.serialize(baout);
+      baout.flush();
+
+      final DataInputStream in = new DataInputStream(new ByteArrayInputStream(ba.toByteArray()));
+      final FixedPointFraction r = FixedPointFraction.FACTORY.valueOf(in);
+      //Print.println("r = " + r);
+      assertTrue(R == r);
+    }
+
+
+    runTestSerialization(R.newElement());
+    for(int i = 1; i < 30; i+=2) {
+      runTestSerialization(R.random(i, RANDOM));
+    }
+  }
+  
+  private void runTestSerialization(FixedPointFraction.Element x) throws IOException {
+    //Print.println("x = ");
+    //x.printDetail();
+    final ByteArrayOutputStream ba = new ByteArrayOutputStream();
+    final DataOutputStream baout = new DataOutputStream(ba);
+    
+    x.serialize(baout);
+    baout.flush();
+
+    final DataInputStream in = new DataInputStream(new ByteArrayInputStream(ba.toByteArray()));
+    final FixedPointFraction.Element e = FixedPointFraction.ELEMENT_FACTORY.valueOf(in);
+    assertTrue(x.get() == e.get());
+    assertEquals(x, e);
+  }
+}
Index: src/test/mapred/org/apache/hadoop/mp/math/TestZahlen.java
===================================================================
--- src/test/mapred/org/apache/hadoop/mp/math/TestZahlen.java	(revision 0)
+++ src/test/mapred/org/apache/hadoop/mp/math/TestZahlen.java	(revision 0)
@@ -0,0 +1,318 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.math;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.PrintStream;
+import java.math.BigInteger;
+import java.util.Random;
+
+import org.apache.hadoop.mp.math.BrentSalamin;
+import org.apache.hadoop.mp.math.MathUtil;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Print;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class TestZahlen {
+  private static final Random RANDOM = JavaUtil.newRandom();
+  static final PrintStream out = System.out;
+
+  static class CheckPlusEqual {
+    final Zahlen.Element e;
+    long value = 0;
+    
+    CheckPlusEqual(final Zahlen Z) {e = Z.newElement();}
+
+    void checkPlusEqual(long singleDigit) {
+      for(; singleDigit > Integer.MAX_VALUE; ) {
+        e.plusEqual(Integer.MAX_VALUE);
+        singleDigit -= Integer.MAX_VALUE;
+      }
+      for(; singleDigit < Integer.MIN_VALUE; ) {
+        e.plusEqual(Integer.MIN_VALUE);
+        singleDigit -= Integer.MIN_VALUE;
+      }
+      e.plusEqual((int)singleDigit);
+      value += singleDigit;
+      out.println("e " + (singleDigit > 0? "+ " + singleDigit: "- " + -singleDigit)
+          + " = " + e + ", value=" + value);
+      Assert.assertEquals(value, e.toBigInteger().longValue());
+    }
+
+    Zahlen.Element checkPlusEqual(Zahlen.Element x) {
+      e.plusEqual(x);
+      final long xValue = x.toBigInteger().longValue();
+      value += xValue;
+      out.println("e " + (xValue > 0? "+ " + xValue: "- " + -xValue)
+          + " = " + e + ", value=" + value);
+      Assert.assertEquals(value, e.toBigInteger().longValue());
+      return e;
+    }
+  }
+
+  @Test
+  public void testPlusEqualElement() {
+    final Zahlen Z = Zahlen.FACTORY.valueOf(8, 4, 1024);
+    final CheckPlusEqual cpe = new CheckPlusEqual(Z);
+    final Zahlen.Element x = Z.newElement();
+    x.plusEqual(1);
+    cpe.checkPlusEqual(1);
+    cpe.checkPlusEqual(x);
+
+    x.plusEqual((int)Z.digitLimit.mask >>> 1);
+    cpe.checkPlusEqual(x);
+
+    x.plusEqual(-1);
+    cpe.checkPlusEqual(x);
+    cpe.checkPlusEqual(x);
+    
+    
+    final int n = 16;
+    final Zahlen.Element y = Z.random(n, new Random());
+    out.println("y = " + y);
+    int d = y.difference(n, 3);
+    out.println("d = " + d + ", x = " + y);
+  }
+
+  @Test
+  public void testPlusEqualSingleDigit() {
+    final Zahlen Z = Zahlen.FACTORY.valueOf(8, 4, 1024);
+    final CheckPlusEqual cpe = new CheckPlusEqual(Z);
+
+    for(int i = 0; i < 2; i++)
+      cpe.checkPlusEqual(1);
+    for(int i = 0; i < 4; i++)
+      cpe.checkPlusEqual(-1);
+    for(int i = 0; i < 5; i++)
+      cpe.checkPlusEqual(1);
+
+    cpe.checkPlusEqual(Z.digitLimit.value - 1);
+
+    for(int i = 0; i < 5; i++)
+      cpe.checkPlusEqual(-1);
+    for(int i = 0; i < 5; i++)
+      cpe.checkPlusEqual(1);
+    
+    for(int i = 0; i < 3; i++) {
+      cpe.checkPlusEqual(Z.digitLimit.value - 2);
+      cpe.checkPlusEqual(2);
+    }
+
+    for(int i = 0; i < 2; i++)
+      cpe.checkPlusEqual(-1);
+
+    for(int i = 0; i < 10; i++) {
+      cpe.checkPlusEqual(-(Z.digitLimit.value >> 1));
+    }
+  }
+  
+  @Test
+  public void testSerialization() throws IOException {
+    for(int bpd = 3; bpd <= 5; bpd++) {
+      final Zahlen Z = Zahlen.FACTORY.valueOf(1 << bpd, 4, 1024);
+      Assert.assertTrue(Z == Zahlen.FACTORY.valueOf(Z.serialize()));
+  
+      {
+        final ByteArrayOutputStream ba = new ByteArrayOutputStream();
+        final DataOutputStream baout = new DataOutputStream(ba);
+        Z.serialize(baout);
+        baout.flush();
+  
+        final DataInputStream in = new DataInputStream(new ByteArrayInputStream(ba.toByteArray()));
+        final Zahlen z = Zahlen.FACTORY.valueOf(in);
+        out.println("z = " + z);
+        Assert.assertTrue(Z == z);
+      }
+  
+  
+      runTestSerialization(Z.newElement());
+      for(int e = 1; e < 10; e++)
+        for(int i = 0; i < 5; i++)
+          runTestSerialization(Z.random((1 << e) + i - 2, RANDOM));
+    }
+  }
+  
+  private void runTestSerialization(Zahlen.Element x) throws IOException {
+    final ByteArrayOutputStream ba = new ByteArrayOutputStream();
+    final DataOutputStream baout = new DataOutputStream(ba);
+    
+    x.serialize(baout);
+    baout.flush();
+
+    final DataInputStream in = new DataInputStream(new ByteArrayInputStream(ba.toByteArray()));
+    final Zahlen.Element e = Zahlen.ELEMENT_FACTORY.valueOf(in);
+    Assert.assertTrue(x.get() == e.get());
+    Assert.assertEquals(x, e);
+  }
+
+  @Test
+  public void testSqrt() {
+    final JavaUtil.Timer timer = new JavaUtil.Timer(true, true);
+    final JavaUtil.WorkGroup workers = new JavaUtil.WorkGroup(BrentSalamin.class.getSimpleName(), 2, timer);
+
+    final Zahlen Z = Zahlen.FACTORY.valueOf(8, 4, 1024);
+    for(long n = 0; n < 1000; n++) {
+      final long sqrt = MathUtil.sqrt_long(n);
+      final long r = n - sqrt*sqrt;
+      //Print.println("n = " + n + " = " + sqrt + "^2 + " + r);
+      Assert.assertTrue(r >= 0);
+      Assert.assertTrue((sqrt + 1)*(sqrt + 1) > n);
+    }
+
+
+    final Zahlen.Element n = Z.newElement();
+    for(long i = 0; i < 100000; i++) {
+      //Print.println("n    = " + n);
+      Zahlen.Element r = Z.newElement().set(n);
+      Zahlen.Element sqrt = r.sqrtRemainderEqual(workers);
+      //Print.println("sqrt = " + sqrt);
+      //Print.println("r    = " + r);
+      Assert.assertTrue(r.isNonNegative());
+      sqrt.plusEqual(1).multiplyEqual(sqrt, workers);
+      Assert.assertTrue(sqrt.compareMagnitudeTo(n) > 0);
+
+      n.plusEqual(1);
+    }
+  }
+
+  @Test
+  public void testMultiplication() {
+    final JavaUtil.Timer timer = new JavaUtil.Timer(true, true);
+    final JavaUtil.Timer t = new JavaUtil.Timer(false, false);
+    final JavaUtil.WorkGroup workers = new JavaUtil.WorkGroup(BrentSalamin.class.getSimpleName(), 2, null);
+
+    final Zahlen Z = Zahlen.FACTORY.valueOf(16, 1 << 12, 1 << 12);
+    for(int i = 0; i < 16; i++) {
+      Print.println();
+      final int d = 1 << i;
+      t.tick("i=" + i + ", d=" + d);
+      final Zahlen.Element x = Z.random(d, RANDOM);
+      final Zahlen.Element y = Z.random(d, RANDOM);
+      final Zahlen.Element y_copy = Z.newElement().set(y);
+      t.tick("ramdom");
+      final BigInteger expected = x.toBigInteger().multiply(y.toBigInteger());
+      t.tick("BigInteger");
+      x.multiplyEqual(y, workers);
+      t.tick("Zahlen");
+      Assert.assertEquals(expected, x.toBigInteger());
+      Assert.assertEquals(y_copy, y);
+      y.multiplyEqual(Z.newElement().plusEqual(1).shiftLeftEqual_bits(Z.digitsPerArray.value), workers);
+      y_copy.shiftLeftEqual_bits(Z.digitsPerArray.value);
+      Assert.assertEquals(y_copy, y);
+
+      Print.println("product = " + x.toBrief());
+      timer.tick("done iteration " + i);
+      Print.printMemoryInfo();
+      
+    }
+  }
+
+  @Test
+  public void testShiftAsMultiplication() {
+    final Zahlen Z = Zahlen.FACTORY.valueOf(8, 4, 1 << 12);
+
+//    {
+//      for(int i = 10; i < 100; i++) {
+//        Print.println("************* i=" + i);
+//        final Zahlen.Element x = Z.newElement();
+//        final Zahlen.Element y = Z.newElement().plusEqual(1).shiftLeftEqual_digits(i);
+//        Print.println("x = " + x.toBrief());
+//        Print.println("y = " + y.toBrief());
+//        x.plusEqual(y);
+//        Print.println("x = " + x.toBrief());
+//        Assert.assertEquals(y, x);
+//      }
+//    }
+    
+    final JavaUtil.WorkGroup workers = new JavaUtil.WorkGroup(TestZahlen.class.getSimpleName(), 2, null);
+    for(int i = 1; i < 100; i++) {
+      final Zahlen.Element x = Z.random(8, RANDOM);
+      final Zahlen.Element y = Z.newElement().plusEqual(1).shiftLeftEqual_bits(i);
+//      final Zahlen.Element y = Z.random(4, RANDOM).shiftLeftEqual_bits(1);
+      Print.println("************* i=" + i);
+      Print.println("x = " + x);
+      Print.println("y = " + y);
+  
+      final Zahlen.Element y_copy = Z.newElement().set(y);
+      final BigInteger expected = x.toBigInteger().multiply(y.toBigInteger());
+      final int max = x.numberOfDigits() > y.numberOfDigits()? x.numberOfDigits(): y.numberOfDigits();
+      x.multiplyEqual_SchonhageStrassen(y, max, workers);
+  
+      Assert.assertEquals(expected, x.toBigInteger());
+      Assert.assertEquals(y_copy, y);
+  
+      y.multiplyEqual(Z.newElement().plusEqual(1).shiftLeftEqual_bits(Z.digitsPerArray.value), workers);
+      y_copy.shiftLeftEqual_bits(Z.digitsPerArray.value);
+      Assert.assertEquals(y_copy, y);
+  
+      Print.println("product = " + x);
+      Print.printMemoryInfo();
+    }
+  }
+
+  @Test
+  public void testKaratsuba() {
+    final JavaUtil.Timer timer = new JavaUtil.Timer(true, true);
+    final JavaUtil.WorkGroup workers = new JavaUtil.WorkGroup(BrentSalamin.class.getSimpleName(), 2, null);
+    final JavaUtil.Timer t = new JavaUtil.Timer(false, false);
+    final Zahlen Z = Zahlen.FACTORY.valueOf(32, 1 << 3, 1 << 12);
+    for(int i = 1; i < 5; i++) {
+      Print.println();
+      final int d = 1 << i;
+      t.tick("i=" + i + ", d=" + d + " **********************");
+      Zahlen.Element x = Z.random(d, RANDOM);
+      final Zahlen.Element y = Z.random(d, RANDOM);
+      final Zahlen.Element y_copy = Z.newElement().set(y);
+      t.tick("ramdom");
+      final BigInteger expected = x.toBigInteger().multiply(y.toBigInteger());
+      final long tBigInteger = t.tick("BigInteger");
+      final long tKaratsuba;
+      {
+        final int max = x.numberOfDigits() > y.numberOfDigits()? x.numberOfDigits(): y.numberOfDigits();
+        x.multiplyEqual_Karatsuba(y, max, workers);
+        tKaratsuba = t.tick("Karatsuba");
+        Assert.assertEquals(expected, x.toBigInteger());
+        Assert.assertEquals(y_copy, y);
+      }
+
+      Print.println("product = " + x.toBrief());
+      if (tKaratsuba < tBigInteger) {
+        Print.println("!!!");
+        Print.println("!!! Karatsuba");
+        Print.println("!!!");
+      }
+
+      {
+        x = Z.newElement().plusEqual(1).shiftLeftEqual_bits(Z.digitsPerArray.value);
+        final int max = x.numberOfDigits() > y.numberOfDigits()? x.numberOfDigits(): y.numberOfDigits();
+        y.multiplyEqual_Karatsuba(x, max, workers);
+        y_copy.shiftLeftEqual_bits(Z.digitsPerArray.value);
+        Assert.assertEquals(y_copy, y);
+      }
+
+      timer.tick("done iteration " + i);
+      Print.printMemoryInfo();
+    }
+  }
+}
Index: src/test/mapred/org/apache/hadoop/mp/math/TestSchonhageStrassen.java
===================================================================
--- src/test/mapred/org/apache/hadoop/mp/math/TestSchonhageStrassen.java	(revision 0)
+++ src/test/mapred/org/apache/hadoop/mp/math/TestSchonhageStrassen.java	(revision 0)
@@ -0,0 +1,279 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.math;
+
+import java.io.FileNotFoundException;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.TreeMap;
+
+import org.apache.hadoop.mp.math.BrentSalamin;
+import org.apache.hadoop.mp.math.PowerOfTwo_int;
+import org.apache.hadoop.mp.math.SchonhageStrassen;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Parse;
+import org.apache.hadoop.mp.util.Print;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class TestSchonhageStrassen {
+  @Test
+  public void testSerialization() {
+    for(int bpd = 3; bpd <= 5; bpd++) {
+      final Zahlen Z = Zahlen.FACTORY.valueOf(1 << bpd, 4096, 1024);
+      Print.println("testSerialization");
+      for(int d = 4; d < 10; d++) {
+        for(int bpe = 4; bpe < 10; bpe++) {
+          final PowerOfTwo_int D = PowerOfTwo_int.valueOf(1 << d);
+          final PowerOfTwo_int bitsPerElement = PowerOfTwo_int.valueOf(1 << bpe);
+          final int ss_exponent = Z.bitsPerDigit.toMultipleOf((D.exponent >> 1) + (bitsPerElement.value << 1));
+          final int modulusExponent = D.toMultipleOf(ss_exponent << 1) >> 1;
+          final SchonhageStrassen schonhagestrassen = SchonhageStrassen.FACTORY.valueOf(
+              modulusExponent, bitsPerElement, D, Z);
+
+          final String str = schonhagestrassen.serialize();
+          final SchonhageStrassen ss = SchonhageStrassen.FACTORY.valueOf(str, Z);
+          Assert.assertTrue(schonhagestrassen == ss);
+        }
+      }
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  static class SuitableNumber {
+    final int n;
+    final int v;
+    final int k;
+    
+    SuitableNumber(final int v, final int k) {
+      this.n = v << k;
+      this.v = v;
+      this.k = k;
+    }
+
+    SuitableNumber nextN() {
+      return new SuitableNumber(v/2 + 1, (k-1)/2 + 1);
+    }
+
+    @Override
+    public String toString() {
+      return getClass().getSimpleName() + ": " + n + " = " + v + "*2^" + k;
+    }
+  }
+
+  static class Average implements Comparable<Average> {
+    final String name;
+    final double avg;
+
+    Average(String name, long[] values) {
+      this.name = name;
+      long sum = 0;
+      for(long v : values)
+        sum += v;
+      avg = sum / (double)values.length;
+    }
+    
+    @Override
+    public int compareTo(final Average that) {
+      final double d = this.avg - that.avg;
+      return d > 0? 1: d < 0? -1: 0;
+    }
+
+    @Override
+    public String toString() {
+      return Parse.millis2String(avg, 2) + ": " + name;
+    }
+  }
+
+  @Test
+  public void testMultiplication() throws FileNotFoundException {
+    final JavaUtil.Timer timer = new JavaUtil.Timer(true, true);
+//    Print.initLogFile("TestMultiplication");
+    final int trials = 10;
+    timer.tick("testMultiplication: trial=" + trials);
+    final Map<String, long[]> t = new TreeMap<String, long[]>();
+    for(int i = 0; i < trials; i++) {
+      //runTestClassicalMultiplication();
+      Print.beginIndentation("\n\n\n*** TEST " + i);
+      for(Map.Entry<String, Long> d : runTestMultiplication(new SuitableNumber(16, 15)).entrySet()) {
+        long[] a = t.get(d.getKey());
+        if (a == null) {
+          a = new long[trials];
+          t.put(d.getKey(), a);
+        }
+        a[i] = d.getValue();
+      }
+      timer.tick("DONE");
+      Print.endIndentation();
+    }
+
+    final List<Average> a = new ArrayList<Average>();
+    for(Map.Entry<String, long[]> e : t.entrySet())
+      a.add(new Average(e.getKey(), e.getValue()));
+    Collections.sort(a);
+    
+    timer.tick("DONE ALL");
+    Print.println("Average Running Time = " + Parse.list2string(a));
+  }
+
+  private Map<String, Long> runTestMultiplication(final SuitableNumber n) {
+    final JavaUtil.Timer timer = new JavaUtil.Timer(false, false);
+    final JavaUtil.WorkGroup workers = new JavaUtil.WorkGroup(BrentSalamin.class.getSimpleName(), 2, null);
+
+    final PowerOfTwo_int D = PowerOfTwo_int.valueOf(1 << 10);
+    Print.println("D                = " + D);
+    final PowerOfTwo_int bitsPerElement = PowerOfTwo_int.valueOf(1 << 10);
+    Print.println("bitsPerElement   = " + bitsPerElement);
+    
+    final Zahlen Z = Zahlen.FACTORY.valueOf(32, 4096, 1024);
+    Print.beginIndentation(Z);
+
+    final Random RANDOM = JavaUtil.newRandom();
+    final int digitsPerOperand = (D.value >> 1)*(bitsPerElement.value >> Z.bitsPerDigit.exponent);
+    final Zahlen.Element x = Z.random(digitsPerOperand, RANDOM);
+    Print.println("  x = " + x.toBrief());
+    final Zahlen.Element y = Z.random(digitsPerOperand, RANDOM);
+    Print.println("  y = " + y.toBrief());
+    timer.tick("Random Integers");
+    Print.endIndentation();
+
+    //Fast Fourier Transform
+    final int modulusExponent = Math.max(D.value, bitsPerElement.value << 3) >> 1;
+    Print.println("modulusExponent      = " + modulusExponent);
+    final SchonhageStrassen ss = SchonhageStrassen.FACTORY.valueOf(
+        modulusExponent, bitsPerElement, D, Z);
+    SchonhageStrassen.PRINT_LEVEL = Print.Level.VERBOSE;
+    Print.beginIndentation(ss);
+
+    final BigInteger xx = x.toBigInteger();
+    Print.println("x = " + Parse.bigInteger2Brief(xx));
+    final BigInteger yy = y.toBigInteger();
+    Print.println("y = " + Parse.bigInteger2Brief(yy));
+    timer.tick();
+    final BigInteger expected = xx.multiply(yy);
+    timer.tick("BigInteger.multiply(..)");
+    Print.println("expected = " + Parse.bigInteger2Brief(expected));
+
+    final Map<String, Long> durations = new TreeMap<String, Long>();
+//    for(int i = 0; i < ss.algorithms.length; i++) {
+//      final SchonhageStrassen.FastFourierTransform fft = ss.algorithms[i];
+    final SchonhageStrassen.FastFourierTransform fft = ss.parallel;
+      timer.tick();
+      final Zahlen.Element z = ss.multiplyEquals(Z.newElement().set(x), y, fft, workers);
+      final String name = fft.getClass().getSimpleName();
+      final long ms = timer.tick(name);
+      durations.put(name, ms); 
+      Print.println("z        = " + z.toBrief());
+  
+      //BigInteger
+      final BigInteger zz = z.toBigInteger();
+      Print.println("z        = " + Parse.bigInteger2Brief(zz));
+      Assert.assertEquals(expected, zz);
+//    }
+    /*
+    //Apint
+    final Apint apx = new Apint(xx);
+    final Apint apy = new Apint(yy);
+    timer.tick();
+    final Apint apz = apx.multiply(apy);
+    timer.tick("Apint.multiply(..)");
+    final BigInteger apzz = apz.toBigInteger();
+    Print.println("apzz    = " + toBrief(apzz));
+    assertEquals(expected, apzz);
+*/
+    Print.endIndentation();
+    return durations;
+  }
+
+  static void runTestMultiplication(final int d, final int bitsPerDigit, final int orderOfTwo) {
+
+    /*
+
+    final long Y = ran.nextLong() & long_mask;
+
+    final int D_half = fft.D >> 1;
+    final int[] x = new int[fft.D];
+    final int[] y = new int[fft.D];
+    Printer.println("");
+    Printer.println(String.format("  X =%20d = %16X", X, X));
+    Printer.println(String.format("  x =%20d =", toLong(x, D_half, bitsPerDigit)) + toString(x, D_half, bitsPerDigit));
+    Printer.println(String.format("  Y =%20d = %16X", Y, Y));
+    Printer.println(String.format("  y =%20d =", toLong(y, D_half, bitsPerDigit)) + toString(y, D_half, bitsPerDigit));
+
+
+    //Schonhage-Strassen
+    final int[] z = fft.schonhageStrassen(x, y);
+    final BigInteger zzz = toBigInteger(z, bitsPerDigit);
+    Printer.println("  z        = " + zzz + " = " + toLongString(z, bitsPerDigit));
+
+    final BigInteger expected = LongLong.multiplication(new LongLong(), X, Y).toBigInteger();
+    Printer.println("  expected = " + expected + " = " + expected.toString(16).toUpperCase());
+    assertEquals(expected, zzz);
+    */
+  }
+
+  static String toString(int[] x, int length, int M) {
+    final int hexPerDigit = (M+3) >> 2;
+    final StringBuilder b = new StringBuilder();
+    for(int i = length - 1; i >= 0; i--) {
+      b.append(String.format(" %0" + hexPerDigit + "X", x[i]));
+    }
+    return b.toString();
+  }
+
+  static long toLong(int[] x, int length, int M) {
+    long a = 0;
+    for(int i = 0; i < length; i++) {
+      a |= ((long)x[i] << (M*i));
+    }
+    return a;
+  }
+
+  static BigInteger toBigInteger(int[] x, int bitsPerDigit) {
+    final int digitsPerLong = (59/bitsPerDigit) + 1;
+    BigInteger c = BigInteger.ZERO;
+    for(int i = 0; i < x.length; ) {
+      long a = 0;
+      for(int j = 0; i < x.length && j < digitsPerLong; j++) {
+        a |= ((long)x[i] << (bitsPerDigit*j));
+        i++;
+      }
+      c = c.add(BigInteger.valueOf(a).shiftLeft(bitsPerDigit*digitsPerLong*((i - 1)/digitsPerLong)));
+    }
+    return c;
+  }
+
+  static String toLongString(int[] x, int bitsPerDigit) {
+    final int digitsPerLong = (59/bitsPerDigit) + 1;
+    final StringBuilder b = new StringBuilder();
+    for(int i = 0; i < x.length; ) {
+      long a = 0;
+      int j = 0;
+      for(; i < x.length && j < digitsPerLong; j++) {
+        a |= ((long)x[i] << (bitsPerDigit*j));
+        i++;
+      }
+      b.insert(0, String.format((i == x.length? "%": "%0" + ((bitsPerDigit*j + 3) >> 2)) + "X ", a));
+    }
+    return b.toString();
+  }
+}
Index: src/test/mapred/org/apache/hadoop/mp/math/TestPowerOfTwo.java
===================================================================
--- src/test/mapred/org/apache/hadoop/mp/math/TestPowerOfTwo.java	(revision 0)
+++ src/test/mapred/org/apache/hadoop/mp/math/TestPowerOfTwo.java	(revision 0)
@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.math;
+
+import org.apache.hadoop.mp.math.PowerOfTwo_int;
+import org.apache.hadoop.mp.math.PowerOfTwo_long;
+
+public class TestPowerOfTwo extends junit.framework.TestCase {
+  public void test() {
+    assertEquals(Integer.SIZE - 1, PowerOfTwo_int.values().length);
+    for(int i = 0; i < Integer.SIZE - 1; i++) {
+      assertEquals(1 << i, PowerOfTwo_int.values()[i].value);
+    }
+
+    assertEquals(Long.SIZE - 1, PowerOfTwo_long.values().length);
+    for(int i = 0; i < Long.SIZE - 1; i++) {
+      assertEquals(1L << i, PowerOfTwo_long.values()[i].value);
+    }
+  }
+}
Index: src/test/mapred/org/apache/hadoop/mp/util/TestJava.java
===================================================================
--- src/test/mapred/org/apache/hadoop/mp/util/TestJava.java	(revision 0)
+++ src/test/mapred/org/apache/hadoop/mp/util/TestJava.java	(revision 0)
@@ -0,0 +1,55 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.util;
+
+import java.util.List;
+
+import org.apache.hadoop.mp.util.Interval;
+import org.apache.hadoop.mp.util.JavaUtil;
+
+
+public class TestJava extends junit.framework.TestCase {
+  public void testInterval() throws Exception {
+    final Interval i = new Interval(1000000L, 2000000L);
+    final String[] strings = {
+        "[1000000, 2000000)",
+        "[1000k, 2000k)",
+        "[1,000,000, 2,000,000)",
+        "[  1,000k   ,   2,000k  )"
+    };
+    for(String s : strings) {
+      final Interval j = Interval.valueOf(s);
+      final String mess = "s = " + s + "\ni = " + i + "\nj=" + j;
+      System.out.println(mess);
+      assertEquals(mess, i, j);
+    }
+  }
+
+  public void testPartition() throws Exception {
+    final Interval i = new Interval(100, 201);
+    for(int n = 1; n < 9; n++) {
+      final List<Interval> parts = i.partition(n);
+      //System.out.println("parts = " + parts);
+      assertEquals(n, parts.size());
+      
+      final List<Interval> combined = JavaUtil.combine(parts);
+      assertEquals(1, combined.size());
+      assertEquals(i, combined.get(0));
+    }
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/fft/DistMpSquareTest.java
===================================================================
--- src/examples/org/apache/hadoop/mp/fft/DistMpSquareTest.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/fft/DistMpSquareTest.java	(revision 0)
@@ -0,0 +1,39 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.fft;
+
+import java.io.FileNotFoundException;
+
+import org.apache.hadoop.mp.Function;
+import org.apache.hadoop.util.ToolRunner;
+
+public class DistMpSquareTest extends DistMpMultTest {
+
+  DistMpSquareTest() throws FileNotFoundException {}
+
+  @Override
+  public int run(String[] args) throws Exception {
+    final Function.Variable x = Function.Variable.valueOf("x");
+    return run(args, "y", x);
+  }
+
+  /** main */
+  public static void main(String[] args) throws Exception {
+    System.exit(ToolRunner.run(null, new DistMpSquareTest(), args));
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/fft/DistMpMult.java
===================================================================
--- src/examples/org/apache/hadoop/mp/fft/DistMpMult.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/fft/DistMpMult.java	(revision 0)
@@ -0,0 +1,208 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.fft;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.mp.DistMpBase;
+import org.apache.hadoop.mp.Function;
+import org.apache.hadoop.mp.FunctionDescriptor;
+import org.apache.hadoop.mp.ZahlenDescriptor;
+import org.apache.hadoop.mp.ZahlenSerialization;
+import org.apache.hadoop.mp.ZahlenSerialization.ZahlenOutputFormat;
+import org.apache.hadoop.mp.math.PowerOfTwo_int;
+import org.apache.hadoop.mp.math.PowerOfTwo_long;
+import org.apache.hadoop.mp.math.SchonhageStrassen;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.sum.DistCarrying;
+import org.apache.hadoop.mp.sum.DistCompSum;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Print;
+
+public class DistMpMult {
+  public static final String VERSION = "20110307";
+
+  static final Print.Level PRINT_LEVEL = Print.Level.VERBOSE;
+  static final boolean IS_VERBOSE = PRINT_LEVEL.is(Print.Level.VERBOSE);
+
+  private static final String PREFIX = DistMpMult.class.getSimpleName();
+  public static final String NAME = PREFIX.toLowerCase();
+  public static final String DESCRIPTION = "Distributed Multi-precision Multiplication";
+
+  static final AtomicBoolean printversions = new AtomicBoolean(false);
+
+  public static void printVersions() {
+    if (!printversions.getAndSet(true)) {
+      Print.println();
+      Print.println(DistFft.NAME + ".VERSION = " + DistFft.VERSION);
+      Print.println(NAME + ".VERSION = " + VERSION);
+      Print.println(NAME + ".LOCAL_THRESHOLD = " + LOCAL_THRESHOLD);
+      Print.printSystemInfo();
+    }
+  }
+
+  public static final PowerOfTwo_long LOCAL_THRESHOLD = PowerOfTwo_long.values()[16];
+
+  /** Compute product = x*y with DistFft */
+  public static ZahlenDescriptor multiply(final Function.Variable product,
+      final long numDigits, final Zahlen smallZ, final Zahlen largeZ,
+      final JavaUtil.Timer timer, final JavaUtil.WorkGroup workers,
+      final String dir, final Configuration conf,
+      final Function... x) throws Exception {
+    final SchonhageStrassen schonhagestrassen = SchonhageStrassen.FACTORY.valueOf(numDigits, smallZ);
+    final PowerOfTwo_int K = PowerOfTwo_int.values()[schonhagestrassen.D.exponent >> 1];
+    final PowerOfTwo_int J = PowerOfTwo_int.values()[schonhagestrassen.D.exponent - K.exponent];
+
+    if (numDigits <= LOCAL_THRESHOLD.value) {
+      return multiply_local(product, schonhagestrassen, largeZ, J, K, timer, workers, dir, conf, x);
+    } else {
+      return multiply_mapreduce(product, schonhagestrassen, J, K, timer, dir, conf, x);
+    }
+  }
+  
+  private static ZahlenDescriptor multiply_local(final Function.Variable product,
+      final SchonhageStrassen schonhagestrassen, final Zahlen largeZ,
+      final PowerOfTwo_int J, final PowerOfTwo_int K,
+      final JavaUtil.Timer timer, final JavaUtil.WorkGroup workers,
+      final String dir, final Configuration conf,
+      final Function... x) throws Exception {
+    if (x.length != 1 && x.length != 2) {
+      throw new IllegalArgumentException("x.length != 1 && x.length != 2, x.length=" + x.length);
+    }
+    if (IS_VERBOSE)
+      Print.beginIndentation("multiply_local: " + product + "; x = " + Arrays.asList(x));
+    final Function f = x.length == 1?
+        new Function.Square(x[0]):
+        new Function.Multiplication(x[0], x[1]);
+
+    FunctionDescriptor.evaluateLocal(product, f, schonhagestrassen, largeZ, workers, dir, conf);
+    final ZahlenDescriptor p = new ZahlenDescriptor(product, J, K.value);
+    if (IS_VERBOSE)
+      Print.endIndentation("multiply_local: return " + p);
+    if (timer != null) {
+      timer.tick("multiply_local, product=" + product);
+    }
+    return p;
+  }
+
+  private static ZahlenDescriptor multiply_mapreduce(final Function.Variable product,
+      final SchonhageStrassen schonhagestrassen,
+      final PowerOfTwo_int J, final PowerOfTwo_int K,
+      final JavaUtil.Timer timer, final String dir, final Configuration conf,
+      final Function... x) throws Exception {
+    if (x.length != 1 && x.length != 2) {
+      throw new IllegalArgumentException("x.length != 1 && x.length != 2, x.length=" + x.length);
+    }
+    if (IS_VERBOSE)
+      Print.beginIndentation("multiply_mapreduce: " + product + "; x = " + Arrays.asList(x));
+
+    final DistFft forward = new DistFft(schonhagestrassen, false, J, K, dir);
+    if (IS_VERBOSE) forward.printDetail("forward");
+
+    final long digitsPerOperand = schonhagestrassen.digitsPerOperand();
+    if (IS_VERBOSE) Print.println("digitsPerOperand = " + digitsPerOperand);
+
+    //submit forward-FFT jobs
+    final DistFft.DftJob[] X = new DistFft.DftJob[x.length];
+    for(int i = 0; i < x.length; i++) {
+      X[i] = forward.new DftJob(x[i], conf);
+    }
+    final boolean[] submittedX = new boolean[x.length];
+    for(int i = 0; i < x.length; i++) {
+      submittedX[i] = submit("forward " + x[i], forward, X[i], false, timer);
+    }
+    for(int i = 0; i < x.length; i++) {
+      wait4job("forward " + x[i], X[i], submittedX[i], null);
+    }
+
+    //create function
+    final Function fun = x.length == 1?
+        new Function.Square(X[0].descriptor.output):
+        new Function.Multiplication(
+          X[0].descriptor.output, X[1].descriptor.output);
+
+    //submit the backward-FFT job
+    final DistFft backward = new DistFft(schonhagestrassen, true, J, K, dir);
+    final Function.Variable cdr = Function.Variable.valueOf(product.getName() + "'");
+
+    final DistFft.DftJob B = backward.new DftJob(cdr, fun, conf);
+    ZahlenOutputFormat.setSplit(schonhagestrassen.digitsPerElement(), 3, B.job.getConfiguration());
+    submit("backward", backward, B, true, timer);
+
+    //submit the summation job
+    final String sumdir = dir + Path.SEPARATOR + cdr.getName();
+    final DistCompSum sum = new DistCompSum(schonhagestrassen, J, K, sumdir);
+    final Function.Variable[] parts = ZahlenSerialization.ZahlenOutputFormat.toSplitVariables(cdr, 3);
+    final Function.Variable remainder = Function.Variable.valueOf(product.getName() + "''");
+    final DistCompSum.SumJob S = sum.new SumJob(remainder, conf, parts);
+    submit("summation", sum, S, true, timer);
+
+    //submit the carrying job
+    final DistCarrying carry = new DistCarrying(schonhagestrassen, J, K, sumdir);
+    final DistCarrying.MpJob C = carry.new MpJob(remainder, product, conf);
+    submit("carrying", carry, C, true, timer);
+ 
+    //done
+    rename(product, sumdir, dir, conf);
+    final ZahlenDescriptor p = new ZahlenDescriptor(product, C.descriptor.numParts, C.descriptor.elementsPerPart);
+    if (IS_VERBOSE)
+      Print.endIndentation("multiply_mapreduce: returns " + p);
+    return p;
+  }
+  
+  static void rename(final Function.Variable var, final String srcdir, final String dir,
+      final Configuration conf) throws IOException {
+    final FileSystem fs = FileSystem.get(conf);
+    final Path src = new Path(srcdir, var.getName());
+    final Path dst = new Path(dir, var.getName());
+    final boolean b = fs.rename(src, dst);
+    if (!b) {
+      throw new IOException("Failed to rename from " + src + " to " + dst);
+    }
+  }
+  
+  static boolean submit(final String name, final DistMpBase mp,
+      final DistMpBase.MpJob J, final boolean wait, final JavaUtil.Timer timer
+      ) throws IOException, InterruptedException, ClassNotFoundException {
+    if (IS_VERBOSE)
+      Print.println(name + ": " + mp);
+    final boolean submitted = J.submit();
+    if (IS_VERBOSE)
+      Print.println((submitted? "SUBMIT": "SKIPPED") + " JOB: " + J.jobname);
+    if (wait)
+      wait4job(name, J, submitted, timer);
+    return submitted;
+  }
+  static void wait4job(final String name, final DistMpBase.MpJob J,
+      final boolean submitted, final JavaUtil.Timer timer
+      ) throws IOException, InterruptedException, ClassNotFoundException {
+    if (submitted) {
+      J.wait4job(true);
+    }
+    if (timer != null) {
+      timer.tick(name + ", " + J.jobname);
+      if (IS_VERBOSE)
+        Print.println("-----------------------------------------------------");
+    }
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/fft/DistMpMultTest.java
===================================================================
--- src/examples/org/apache/hadoop/mp/fft/DistMpMultTest.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/fft/DistMpMultTest.java	(revision 0)
@@ -0,0 +1,232 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.fft;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.Random;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.mp.Function;
+import org.apache.hadoop.mp.FunctionDescriptor;
+import org.apache.hadoop.mp.ZahlenDescriptor;
+import org.apache.hadoop.mp.math.PowerOfTwo_int;
+import org.apache.hadoop.mp.math.PowerOfTwo_long;
+import org.apache.hadoop.mp.math.SchonhageStrassen;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.util.HadoopUtil;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Parse;
+import org.apache.hadoop.mp.util.Print;
+import org.apache.hadoop.util.ToolRunner;
+
+
+public class DistMpMultTest extends HadoopUtil.RunnerBase {
+  static final Print.Level PRINT_LEVEL = Print.Level.VERBOSE;
+
+  private static final Random RANDOM = JavaUtil.newRandom();
+
+  static enum Mode {PRINT, GEN, MULT}
+
+  public static class Parameter {
+    public final PowerOfTwo_long numDigits;
+    public final Zahlen largeZ;
+    public final SchonhageStrassen schonhagestrassen;
+    public final PowerOfTwo_int K, J;
+
+    public Parameter(final int e) {
+      this.numDigits = PowerOfTwo_long.values()[e];
+      
+      final PowerOfTwo_int digitsPerArray = PowerOfTwo_int.values()[12];
+      final int nae = numDigits.exponent - digitsPerArray.exponent + 1;
+      final PowerOfTwo_int numArrays = PowerOfTwo_int.values()[nae < 0? 0: nae];
+      largeZ = Zahlen.FACTORY.valueOf(32, digitsPerArray.value, numArrays.value);
+
+      final SchonhageStrassen ss = SchonhageStrassen.FACTORY.valueOf(numDigits.value, largeZ);
+      final int highest = Integer.highestOneBit(ss.modulusExponent);
+      final int bitsPerElement = highest == ss.modulusExponent? (ss.modulusExponent << 1): (highest << 2);
+      final int smallnumarray = bitsPerElement >> (largeZ.bitsPerDigit.exponent + digitsPerArray.exponent - 2);
+      final Zahlen smallZ = Zahlen.FACTORY.valueOf(largeZ.bitsPerDigit.value, largeZ.digitsPerArray.value,
+          smallnumarray > 0? smallnumarray: 1);
+
+      schonhagestrassen = SchonhageStrassen.FACTORY.valueOf(numDigits.value, smallZ);
+
+      K = PowerOfTwo_int.values()[schonhagestrassen.D.exponent >> 1];
+      J = PowerOfTwo_int.values()[schonhagestrassen.D.exponent - K.exponent];
+
+      Print.println();
+      Print.println("numDigits        = " + numDigits + " (e=" + e + ")");
+      Print.println("digitsPerOperand = " + schonhagestrassen.digitsPerOperand());
+      Print.println("J                = " + J);
+      Print.println("K                = " + K);
+      Print.println();
+    }
+  }
+
+  private static void createInput(Function.Variable var, Parameter parameters,
+      final String dir, final Configuration conf) throws IOException {
+//    final Zahlen.Element element = largeZ.random(schonhagestrassen.digitsPerOperand(), RANDOM);
+
+    final Zahlen smallZ = parameters.schonhagestrassen.Z;
+    final int digitsPerElement = parameters.schonhagestrassen.bitsPerElement.value >> smallZ.bitsPerDigit.exponent;
+    final Zahlen.Element[] elements = new Zahlen.Element[parameters.schonhagestrassen.D.value];
+
+    final int halfD = parameters.schonhagestrassen.D.value >> 1;
+    for(int k0 = 0; k0 < parameters.K.value; k0++) {
+      for(int k1 = 0; k1 < parameters.J.value; k1++) {
+        final int i = (k1 << parameters.K.exponent) + k0;
+        elements[i] = i < halfD? smallZ.random(digitsPerElement, RANDOM): smallZ.newElement();
+      }
+      if (k0 % 100 == 0) {
+        Print.println("k0 = " + k0);
+      }
+      FunctionDescriptor.write(var, elements, k0, parameters.K, parameters.J.value, dir, conf);
+      for(int k1 = 0; k1 < parameters.J.value; k1++) {
+        final int i = (k1 << parameters.K.exponent) + k0;
+        elements[i].reclaim();
+        elements[i] = null;
+      }
+    }
+  }
+
+  DistMpMultTest() throws FileNotFoundException {
+    DistMpMult.printVersions();
+  }
+
+  @Override
+  public int run(String[] args) throws Exception {
+    final Function.Variable a = Function.Variable.valueOf("a");
+    final Function.Variable b = Function.Variable.valueOf("b");
+    return run(args, "c", a, b);
+  }
+
+  int run(String[] args, String product, Function.Variable... vars) throws Exception {
+    Print.print("args", args);
+
+    //parse arguments
+    final int e;
+    final Mode mode;
+    final String dir;
+    {
+      int i = 0;
+      e = Parse.string2integer(args[i++]);
+      mode = Mode.valueOf(args[i++].toUpperCase());
+  
+      if (mode == Mode.GEN) {
+        final String fname = logfile.getName();
+        dir = fname.substring(0, fname.indexOf(".log"));
+      } else {
+        dir = args[i++];
+      }
+      Print.println("dir              = " + dir);
+    }
+
+    final Parameter parameters = new Parameter(e);
+    if (mode == Mode.PRINT) {
+      return 0;
+    }
+
+    //setup inputs
+    if (mode == Mode.GEN) {
+      for(int i = 0; i < vars.length; i++) {
+        createInput(vars[i], parameters, dir, getConf());
+        timer.tick("random " + vars[i]);
+        Print.printMemoryInfo();
+      }
+      timer.tick(mode);
+    }
+
+    //start verifier
+    final Verifier v = e > 20? null: new Verifier(parameters, dir, vars);
+    if (v != null)
+      v.start();
+
+    //run {@link DistMpMult}
+    final JavaUtil.WorkGroup workers = new JavaUtil.WorkGroup(
+        getClass().getSimpleName(), 2, null);
+    final ZahlenDescriptor p = DistMpMult.multiply(Function.Variable.valueOf(product),
+        parameters.schonhagestrassen.digitsPerOperand(),
+        parameters.schonhagestrassen.Z, parameters.largeZ,
+        timer, workers, dir, getConf(), vars);
+    Print.println(product + " = " + p);
+    timer.tick(DistMpMult.class.getSimpleName());
+
+    Print.printMemoryInfo();
+
+    if (v != null) {
+      final Zahlen.Element computed = ZahlenDescriptor.read(p.output,
+          parameters.schonhagestrassen, parameters.largeZ, dir, getConf());
+      Print.println("computed = " + computed.toBrief());
+
+      v.join();
+      if (!computed.equals(v.expected)) {
+        Print.println("ERROR: computed != expected");
+        Print.isOutEnabled.set(false);
+        v.expected.printDetail("expected ");
+        computed.printDetail("computed ");
+        Print.isOutEnabled.set(true);
+        throw new RuntimeException("!computed.equals(expected)");
+      }
+    }
+
+    timer.tick("DONE (dir = " + dir + ")");
+    return 0;
+  }
+  
+  private class Verifier extends Thread {
+    final Function.Variable[] vars;
+    final Parameter parameters;
+    final String dir;
+    Zahlen.Element expected;
+    
+    Verifier(final Parameter parameters, final String dir, final Function.Variable... vars) {
+      this.vars = vars;
+      this.parameters = parameters;
+      this.dir = dir;
+    }
+
+    @Override
+    public void run() {
+      Print.println(getClass().getSimpleName() + ": STARTED");
+      try {
+        final Zahlen.Element[] elements = new Zahlen.Element[vars.length];
+        for(int i = 0; i < elements.length; i++) {
+          elements[i] = ZahlenDescriptor.read(vars[i],
+            parameters.schonhagestrassen, parameters.largeZ, dir, getConf());
+        }
+        
+        if (elements.length == 1) {
+          elements[0].multiplyEqual(elements[0], null);
+        } else {
+          elements[0].multiplyEqual(elements[1], null);
+          elements[1].reclaim();
+        }
+
+        expected = elements[0];
+        Print.println(getClass().getSimpleName() + ": expected = " + expected.toBrief());
+      } catch(IOException ioe) {
+        throw new RuntimeException(ioe);
+      }
+    }
+  }
+
+  /** main */
+  public static void main(String[] args) throws Exception {
+    System.exit(ToolRunner.run(null, new DistMpMultTest(), args));
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/fft/DistFft.java
===================================================================
--- src/examples/org/apache/hadoop/mp/fft/DistFft.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/fft/DistFft.java	(revision 0)
@@ -0,0 +1,258 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.fft;
+
+import java.io.IOException;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.io.IntWritable;
+import org.apache.hadoop.mapreduce.Job;
+import org.apache.hadoop.mapreduce.Mapper;
+import org.apache.hadoop.mapreduce.Reducer;
+import org.apache.hadoop.mp.DistMpBase;
+import org.apache.hadoop.mp.Function;
+import org.apache.hadoop.mp.FunctionDescriptor;
+import org.apache.hadoop.mp.ZahlenSerialization;
+import org.apache.hadoop.mp.ZahlenSerialization.ZahlenInputFormat;
+import org.apache.hadoop.mp.ZahlenSerialization.ZahlenOutputFormat;
+import org.apache.hadoop.mp.math.PowerOfTwo_int;
+import org.apache.hadoop.mp.math.SchonhageStrassen;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Print;
+
+
+public class DistFft extends DistMpBase {
+  public static final String VERSION = "20110124";
+
+  static final Print.Level PRINT_LEVEL = Print.Level.VERBOSE;
+  static final boolean IS_VERBOSE = PRINT_LEVEL.is(Print.Level.VERBOSE);
+
+  public static final String NAME = DistFft.class.getSimpleName().toLowerCase();
+  public static final String DESCRIPTION = "Distributed Fast Fourier Transform";
+  
+  private static final String PROPERTY_INVERSE = NAME + ".inverse";
+
+  final boolean inverse;
+
+  DistFft(final SchonhageStrassen schonhagestrassen,
+      final boolean inverse, final PowerOfTwo_int J, final PowerOfTwo_int K,
+      final String dir) {
+    super(schonhagestrassen, J, K, dir);
+    this.inverse = inverse;
+  }
+
+  @Override
+  public String toString() {
+    final String s = super.toString();
+    return s.substring(0, s.length() - 1) + ", inverse=" + inverse + ")";
+  }
+  @Override
+  public void printDetail(final String name) {
+    Print.beginIndentation(NAME + ": " + name);
+    Print.println("inverse           = " + inverse);
+    super.printDetail("");
+    Print.endIndentation();
+  }
+  
+  @Override
+  public void serialize(final Configuration conf) {
+    super.serialize(conf);
+    conf.setBoolean(PROPERTY_INVERSE, inverse);
+  }
+  
+  public static DistFft valueOf(final Configuration conf) {
+    final DistMpBase p = DistMpBase.valueOf(conf);
+    final boolean inverse = conf.getBoolean(PROPERTY_INVERSE, false);
+    return new DistFft(p.schonhagestrassen, inverse, p.J, p.K, p.dir);
+  }
+
+  String dft(final Zahlen.Element[] a, final JavaUtil.WorkGroup workers) {
+    final SchonhageStrassen.FastFourierTransform algorithm = SchonhageStrassen.FACTORY.valueOf(
+        a.length, schonhagestrassen).parallel;
+    if (inverse)
+      algorithm.fft_inverse(a, workers);
+    else
+      algorithm.fft(a, workers);
+    return algorithm.getClass().getSimpleName();
+  }
+  
+  void scaleMultiplication(final int k0, final Zahlen.Element[] a,
+      final JavaUtil.WorkGroup workers) {
+    Print.println("scaleMultiplication: k0=" + k0 + ", a.length=" + a.length);
+    for(int j0 = 0; j0 < a.length; j0++) {
+      int index = j0*k0;
+      if (index > 0 && inverse)
+        index = schonhagestrassen.D.value - index;
+//        Print.println("j0=" + j0 + ", index=" + index);
+      
+      if (workers == null) {
+        schonhagestrassen.multiplyEqual(a[j0], index);
+      } else {
+        final Zahlen.Element z = a[j0];
+        final int i = index;
+        workers.submit("multiplyEqual(a[" + j0 + "], index=" + i + ")", new Runnable() {
+          @Override
+          public void run() {
+            schonhagestrassen.multiplyEqual(z, i);
+          }
+        });
+      }
+    }
+    if (workers != null)
+      workers.waitUntilZero();
+  }
+
+  /** The job computes g = DFT(f). */
+  public class DftJob extends MpJob {
+    DftJob(final Function f, final Configuration conf) throws IOException {
+      // The job computes g = DFT(f).
+      this(Function.Variable.valueOf(f.getName() + "'"), f, conf);
+    }
+
+    DftJob(final Function.Variable g, final Function f,
+        final Configuration conf) throws IOException {
+      super(inverse? new FunctionDescriptor(f, g, K, J.value):
+                     new FunctionDescriptor(f, g, J, K.value), conf);
+    }
+  }
+
+  public static class FftMapper
+      extends Mapper<IntWritable, FunctionDescriptor, IntWritable, ZahlenSerialization.Part.W> {
+    protected void map(final IntWritable index, final FunctionDescriptor fun,
+        final Context context) throws IOException, InterruptedException {
+      //initialize
+      final DistMpBase.TaskHelper helper = new DistMpBase.TaskHelper(context,
+          NAME + ".VERSION = " + VERSION);
+
+      final Configuration conf = context.getConfiguration();
+      final DistFft parameters = DistFft.valueOf(conf);
+      parameters.printDetail(getClass().getSimpleName());
+      Print.println("fun = " + fun);
+
+      final int k0 = index.get();
+      helper.show("init: k0=" + k0);
+
+      //evaluate inputs
+      final int nWorkers = conf.getInt(N_WORKERS_CONF_KEY, 2);
+      final JavaUtil.WorkGroup workers = new JavaUtil.WorkGroup(
+          getClass().getSimpleName(), nWorkers, null);
+      final FunctionDescriptor.Evaluater evaluater = new FunctionDescriptor.Evaluater(
+          k0, parameters.K, parameters.J.value, parameters.schonhagestrassen,
+          parameters.dir, conf); 
+      final Zahlen.Element[] a = evaluater.evaluate(fun.input, helper.timer, workers);
+      helper.show("evaluating inputs: a.length = " + a.length);
+
+      //fft
+      final String algorithm = parameters.dft(a, workers);
+      helper.show("fft: " + algorithm);
+
+      parameters.scaleMultiplication(k0, a, workers);
+      helper.show("scaleMultiplication");
+
+      //write output
+      final ZahlenSerialization.Part.W w = new ZahlenSerialization.Part.W();
+      for(int j0 = 0; j0 < a.length; j0++) {
+        if (j0 < 10 || j0 + 10 >= a.length)
+          Print.println("a[" + j0 + "]=" + a[j0].toBrief());
+        else if (j0 == 10)
+          Print.println("...");
+
+        w.set(new ZahlenSerialization.Part(k0, a[j0]));
+        context.write(new IntWritable(j0), w);
+      }
+      helper.show(getClass().getSimpleName());
+    }
+  }
+
+  public static class FftReducer
+      extends Reducer<IntWritable, ZahlenSerialization.Part.W, IntWritable, ZahlenSerialization.E> {
+    @Override
+    protected final void reduce(final IntWritable index,
+        final Iterable<ZahlenSerialization.Part.W> writables,
+        final Context context) throws IOException, InterruptedException {
+      //initialize
+      final DistMpBase.TaskHelper helper = new DistMpBase.TaskHelper(context,
+          NAME + ".VERSION = " + VERSION);
+
+      final DistFft parameters = DistFft.valueOf(context.getConfiguration());
+      parameters.printDetail(getClass().getSimpleName());
+
+      final int j0 = index.get();
+      helper.show("init: j0=" + j0);
+
+      //read inputs
+      final Zahlen.Element[] a = new Zahlen.Element[parameters.K.value];
+      for(ZahlenSerialization.Part.W w : writables) {
+        final ZahlenSerialization.Part p = w.get();
+        a[p.index] = p.get(0);
+      }
+      helper.show("read inputs: a.length=" + a.length);
+
+      //fft
+      final int nWorkers = context.getConfiguration().getInt(N_WORKERS_CONF_KEY, 2);
+      final JavaUtil.WorkGroup workers = new JavaUtil.WorkGroup(
+          getClass().getSimpleName(), nWorkers, null);
+      final String algorithm = parameters.dft(a, workers);
+      helper.show(algorithm);
+
+      if (parameters.inverse) {
+        parameters.schonhagestrassen.normalize(a);
+        helper.show("normalize");
+
+        if (PRINT_LEVEL.is(Print.Level.TRACE))
+          Print.print("normalize", a);
+      }
+
+      //write output
+      DistMpBase.TaskHelper.write(a, j0, parameters.J, parameters.K.value, context);
+      helper.show(getClass().getSimpleName());
+    }
+  }
+
+  @Override
+  protected Job newJob(final Configuration conf) throws IOException {
+    final Job job = super.newJob(conf);
+
+    // setup mapper
+    job.setMapperClass(FftMapper.class);
+    job.setMapOutputKeyClass(IntWritable.class);
+    job.setMapOutputValueClass(ZahlenSerialization.Part.W.class);
+
+    // setup partitioner
+    job.setPartitionerClass(DistMpBase.IndexPartitioner.class);
+
+    // setup reducer
+    job.setReducerClass(FftReducer.class);
+    job.setOutputKeyClass(IntWritable.class);
+    job.setOutputValueClass(ZahlenSerialization.E.class);
+    job.setNumReduceTasks(J.value);
+
+    // setup input
+    job.setInputFormatClass(ZahlenInputFormat.class);
+    job.setOutputFormatClass(ZahlenOutputFormat.class);
+    return job; 
+  }
+
+  @Override
+  protected String jobName(final FunctionDescriptor f) {
+    return dir + ": " + f.output + " = dft"
+        + (inverse? "^-1(": "(")
+        + f.functionString() + ")";
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/fft/DistFftTest.java
===================================================================
--- src/examples/org/apache/hadoop/mp/fft/DistFftTest.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/fft/DistFftTest.java	(revision 0)
@@ -0,0 +1,104 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.fft;
+
+import java.io.FileNotFoundException;
+import java.util.Random;
+
+import org.apache.hadoop.mp.Function;
+import org.apache.hadoop.mp.FunctionDescriptor;
+import org.apache.hadoop.mp.math.PowerOfTwo_int;
+import org.apache.hadoop.mp.math.SchonhageStrassen;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.util.HadoopUtil;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Parse;
+import org.apache.hadoop.mp.util.Print;
+import org.apache.hadoop.util.ToolRunner;
+
+
+public class DistFftTest extends HadoopUtil.RunnerBase {
+  protected DistFftTest() throws FileNotFoundException {}
+
+  @Override
+  public int run(String[] args) throws Exception {
+    final PowerOfTwo_int D = PowerOfTwo_int.valueOf(1 << 4);
+    Print.println("D                = " + D);
+    final PowerOfTwo_int bitsPerElement = PowerOfTwo_int.valueOf(1 << 4);
+    Print.println("bitsPerElement   = " + bitsPerElement);
+    final int bitsPerDigit = 16;
+    final Zahlen Z = Zahlen.FACTORY.valueOf(bitsPerDigit, 4096, 1024);
+    final int modulusExponent = Math.max(D.value, bitsPerElement.value << 3) >> 1;
+    Print.println("modulusExponent  = " + modulusExponent);
+    final SchonhageStrassen schonhagestrassen = SchonhageStrassen.FACTORY.valueOf(
+        modulusExponent, bitsPerElement, D, Z);
+
+    final PowerOfTwo_int K = PowerOfTwo_int.values()[schonhagestrassen.D.exponent >> 1];
+    final PowerOfTwo_int J = PowerOfTwo_int.values()[schonhagestrassen.D.exponent - K.exponent];
+    final String dir = DistFft.NAME + "_" + Parse.currentTime2String();
+    final DistFft parameters = new DistFft(schonhagestrassen, false, J, K, dir);
+    final Function.Variable a = Function.Variable.valueOf("a");
+    final FunctionDescriptor vars = new FunctionDescriptor(a, Function.Variable.valueOf("b"), J, K.value);
+    parameters.printDetail("");
+    Print.println("vars = " + vars);
+
+    //setup input
+    final Zahlen.Element x = Z.random(JavaUtil.toInt(schonhagestrassen.digitsPerOperand()), new Random());
+    timer.tick("x = " + x.toBrief());
+    final Zahlen.Element[] A = x.split(schonhagestrassen.bitsPerElement.value, D.value);
+    Print.print("A", A);
+
+    for(int k0 = 0; k0 < K.value; k0++) {
+      FunctionDescriptor.write(a, A, k0, K, J.value, parameters.dir, getConf());
+    }
+    
+    //submit a job
+    final DistFft.DftJob job = parameters.new DftJob(a, getConf());
+    job.submit();
+    
+    //verify output
+    schonhagestrassen.parallel.fft(A, null);
+    Print.print("dft(a)", A);
+
+    final Zahlen.Element[] b = new Zahlen.Element[A.length];
+    for(int j0 = 0; j0 < J.value; j0++) {
+      final Zahlen.Element[] t = vars.readOutput(j0, parameters.dir, getConf());
+      for(int i = 0; i < t.length; i++)
+        b[(i << J.exponent) + j0] = t[i];
+    }
+    Print.print("b", b);
+    
+    for(int i = 0; i < A.length; i++)
+      if (!b[i].equals(A[i])) {
+        Print.println("b[" + i + "] = ");
+        b[i].print(10);
+        Print.println("a[" + i + "] = ");
+        A[i].print(10);
+        Print.println("!b[i].equals(a[i])");
+        throw new RuntimeException("!b[i].equals(a[i])");
+      }
+
+    timer.tick("DONE");
+      return 0;
+    }
+ 
+  /** main */
+  public static void main(String[] args) throws Exception {
+    System.exit(ToolRunner.run(null, new DistFftTest(), args));
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/fft/DistRecip.java
===================================================================
--- src/examples/org/apache/hadoop/mp/fft/DistRecip.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/fft/DistRecip.java	(revision 0)
@@ -0,0 +1,67 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.fft;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.mp.Function;
+import org.apache.hadoop.mp.FunctionDescriptor;
+import org.apache.hadoop.mp.math.FixedPointFraction;
+import org.apache.hadoop.mp.math.SchonhageStrassen;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Print;
+
+public class DistRecip {
+  public static final String VERSION = "20100819";
+
+  static final Print.Level PRINT_LEVEL = Print.Level.VERBOSE;
+  static final boolean IS_VERBOSE = PRINT_LEVEL.is(Print.Level.VERBOSE);
+
+  private static final String PREFIX = DistRecip.class.getSimpleName();
+  public static final String NAME = PREFIX.toLowerCase();
+  public static final String DESCRIPTION = "Compute reciprocal by Newton's method";
+
+  static final AtomicBoolean printversions = new AtomicBoolean(false);
+
+  public static void printVersions() {
+    if (!printversions.getAndSet(true)) {
+      Print.println(NAME + ".VERSION = " + VERSION);
+      Print.printSystemInfo();
+    }
+  }
+
+
+  /** Compute recip = 1/x */
+  public static FunctionDescriptor approximateReciprocal(final Function.Variable recip, final Function x,
+      final long numDigits, final Zahlen smallZ, final Zahlen largeZ, final FixedPointFraction R,
+      final JavaUtil.WorkGroup workers,
+      final String dir, final Configuration conf) throws Exception {
+
+    final SchonhageStrassen schonhagestrassen = SchonhageStrassen.FACTORY.valueOf(numDigits, smallZ);
+    if (numDigits < DistMpMult.LOCAL_THRESHOLD.value) {
+      final Zahlen.Element xx = FunctionDescriptor.evaluateLocal(null, x, schonhagestrassen, largeZ, workers, dir, conf);
+      final FixedPointFraction.Element r = R.valueOf(xx).reciprocalEqual(workers); 
+      FunctionDescriptor.write(recip, r.getFraction(), schonhagestrassen, dir, conf);
+    }
+
+      
+    return null;
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/fft/benchmarks/Results.java
===================================================================
--- src/examples/org/apache/hadoop/mp/fft/benchmarks/Results.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/fft/benchmarks/Results.java	(revision 0)
@@ -0,0 +1,82 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.fft.benchmarks;
+
+import java.util.Iterator;
+import java.util.SortedSet;
+import java.util.TreeSet;
+
+import org.apache.hadoop.mp.util.Parse;
+import org.apache.hadoop.mp.util.Print;
+
+
+public class Results {
+  private final SortedSet<Entry> set = new TreeSet<Entry>();
+  private final String name; 
+  
+  Results(final String name) {
+    this.name = name;
+  }
+  
+  public void add(final String name, final long ms) {
+    final Entry e = new Entry(name, ms);
+    Print.println(e);
+    set.add(e);
+  }
+  
+  @Override
+  public String toString() {
+    final StringBuilder b = new StringBuilder();
+    b.append(name).append(": ");
+
+    final Iterator<Entry> i = set.iterator();
+    Entry prev = i.next();
+    b.append(prev);
+    for(; i.hasNext(); ) {
+      final Entry e = i.next();
+      b.append(prev.ms == e.ms? " = ": " < ").append(e);
+      prev = e;
+    }
+    return b.toString();
+  }
+
+  static class Entry implements Comparable<Entry> {
+    final String name;
+    final long ms;
+    
+    Entry(final String name, final long ms) {
+      this.name = name;
+      this.ms = ms;    
+    }
+
+    @Override
+    public int compareTo(final Entry that) {
+      final long d = this.ms - that.ms;
+      if (d == 0) {
+        return name.compareTo(that.name);
+      } else {
+        return d > 0? 1: -1;
+      }
+    }
+
+    @Override
+    public String toString() {
+      return name + "(" + Parse.millis2String(ms) + ")";
+    }
+  }
+}
Index: src/examples/org/apache/hadoop/mp/fft/benchmarks/Benchmarks.java
===================================================================
--- src/examples/org/apache/hadoop/mp/fft/benchmarks/Benchmarks.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/fft/benchmarks/Benchmarks.java	(revision 0)
@@ -0,0 +1,137 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.fft.benchmarks;
+
+import java.io.IOException;
+import java.math.BigInteger;
+import java.util.Random;
+
+import org.apache.hadoop.mp.gmp.GmpMultiplier;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Print;
+
+public class Benchmarks {
+  public static final String DESCRIPTION = "Benchmarks: multiplication";
+  private static final Random RANDOM = JavaUtil.newRandom();
+
+  public static void multiplicationBench() throws IOException {
+    final JavaUtil.Timer t = new JavaUtil.Timer(false, false);
+    Print.printSystemInfo();
+
+    final Zahlen Z = Zahlen.FACTORY.valueOf(32, 1 << 13, 1 << 10);
+    Print.println(Z);
+
+    final JavaUtil.WorkGroup workers = new JavaUtil.WorkGroup(
+        Benchmarks.class.getSimpleName(), 2, null);
+
+    for(int i = 4; i < 32; i++) {
+      Print.println();
+      final int d = 1 << i;
+      t.tick("i=" + i + ", d=" + d);
+      final Results r = new Results(d + " digits");
+
+      final Zahlen.Element x = Z.random(d, RANDOM);
+      final Zahlen.Element x2 = Z.newElement().set(x);
+      final Zahlen.Element x3 = Z.newElement().set(x);
+//      final Zahlen.Element x4 = Z.newElement().set(x);
+      final Zahlen.Element y = Z.random(d, RANDOM);
+      Print.println("x  = " + x.toBrief());
+      Print.println("y  = " + y.toBrief());
+
+      final int max_nDigits = x.numberOfDigits() > y.numberOfDigits()? x.numberOfDigits(): y.numberOfDigits();
+      t.tick("ramdom");
+      final BigInteger xx = x.toBigInteger();
+      final BigInteger yy = y.toBigInteger();
+      t.tick("toBigInteger");
+
+      final Zahlen.Element x1 = GmpMultiplier.get().multiply(x, y);
+      r.add("gmp", t.tick());
+
+      x.multiplyEqual(y, workers);
+      r.add("multiplyEqual", t.tick());
+
+      x2.multiplyEqual_Karatsuba(y, max_nDigits, workers);
+      r.add("Karatsuba", t.tick());
+      
+      x3.multiplyEqual_SchonhageStrassen(y, max_nDigits, workers);
+      r.add("SchonhageStrassen", t.tick());
+
+//      x4.multiplyEqual_Apfloat(y);
+//      r.add("Apfloat", t.tick());
+      
+      final BigInteger expected = xx.multiply(yy);
+      r.add("BigInteger", t.tick());
+      
+      Print.println("x  = " + x.toBrief());
+      Print.println("x1 = " + x1.toBrief());
+      Print.println("x2 = " + x2.toBrief());
+//      Print.println("x3 = " + x3.toBrief());
+//      Print.println("x4 = " + x4.toBrief());
+      Print.println(r);
+      Print.println("========================================================");
+      /*
+      if (d > Zahlen.BIG_INTEGER_THRESHOLD) {
+        if (tBigInteger < tBest) {
+          Print.println("!!!");
+          Print.println("!!! tBigInteger = " + tBigInteger + " < tBest = " + tBest);
+          Print.println("!!!");
+        }
+      } else if (d <= Zahlen.KARATSUBA_THRESHOLD  && tKaratsuba < tBest) {
+        Print.println("!!!");
+        Print.println("!!! tKaratsuba = " + tKaratsuba + " < tBest = " + tBest);
+        Print.println("!!!");
+      }
+      if (d <= Zahlen.KARATSUBA_THRESHOLD  && tSchonhageStrassen < tBest) {
+        Print.println("!!!");
+        Print.println("!!! tSchonhageStrassen = " + tSchonhageStrassen + " < tBest = " + tBest);
+        Print.println("!!!");
+      }*/
+      
+      if (!x.toBigInteger().equals(expected))
+        throw new ArithmeticException("!x.equals(expected)");
+      if (!x1.equals(x))
+        throw new ArithmeticException("!x1.equals(x)");
+      if (!x2.equals(x))
+        throw new ArithmeticException("!x2.equals(x)");
+      if (!x3.equals(x))
+        throw new ArithmeticException("!x3.equals(x)");
+//      if (!x4.equals(x)) {
+//        Print.printStackTrace(new ArithmeticException("!x4.equals(x)"));
+//        System.exit(1);
+//      }
+      t.tick("verification");
+      
+      Print.printMemoryInfo();
+    }
+  }
+
+  public static void main(String[] args) throws IOException {
+//    final ApfloatContext ctx = ApfloatContext.getContext();
+//    ctx.setDefaultRadix(16);
+//    ctx.setMaxMemoryBlockSize(1L << 24);
+//    ctx.setMemoryTreshold(1 << 16);
+//    ctx.setSharedMemoryTreshold(1 << 16);
+//    ctx.setBlockSize(1 << 16);
+//    ctx.setCleanupAtExit(true);
+    
+
+    Print.initLogFile(Benchmarks.class.getSimpleName());
+    multiplicationBench();
+  }
+}
Index: src/examples/org/apache/hadoop/mp/ZahlenSerialization.java
===================================================================
--- src/examples/org/apache/hadoop/mp/ZahlenSerialization.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/ZahlenSerialization.java	(revision 0)
@@ -0,0 +1,320 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.List;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.BlockLocation;
+import org.apache.hadoop.fs.FileStatus;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.io.IntWritable;
+import org.apache.hadoop.io.SequenceFile;
+import org.apache.hadoop.io.SequenceFile.CompressionType;
+import org.apache.hadoop.io.Writable;
+import org.apache.hadoop.mapreduce.InputFormat;
+import org.apache.hadoop.mapreduce.InputSplit;
+import org.apache.hadoop.mapreduce.JobContext;
+import org.apache.hadoop.mapreduce.RecordReader;
+import org.apache.hadoop.mapreduce.RecordWriter;
+import org.apache.hadoop.mapreduce.TaskAttemptContext;
+import org.apache.hadoop.mapreduce.lib.output.FileOutputCommitter;
+import org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.util.Print;
+import org.apache.hadoop.mp.util.serialization.DataSerializable;
+
+public class ZahlenSerialization {
+  static final Print.Level PRINT_LEVEL = Print.Level.VERBOSE;
+
+  public static class E extends DataSerializable.W<Zahlen.Element> {
+    public E() {}
+
+    @Override
+    public void readFields(final DataInput in) throws IOException {
+      final Zahlen.Element e = get();
+      if (e != null)
+        e.reclaim();
+      set(valueOf(in));
+    }
+    
+    static Zahlen.Element valueOf(final DataInput in) throws IOException {
+      return Zahlen.ELEMENT_FACTORY.valueOf(in);
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  public static class Part implements DataSerializable<Void> {
+    private final Zahlen.Element[] a;
+    public final int index;
+    
+    public Part(final int index, final Zahlen.Element... a) {
+      this.a = a;
+      this.index = index;
+    }
+    
+    public Zahlen.Element get(int i) {return a[i];}
+
+    @Override
+    public Void serialize(DataOutput out) throws IOException {
+      out.writeInt(a.length);
+      for(int i = 0; i < a.length; i++) {
+        a[i].serialize(out);
+      }
+      out.writeInt(index);
+      return null;
+    }
+
+    public static class W extends DataSerializable.W<Part> {
+      public W() {}
+      @Override
+      public void readFields(DataInput in) throws IOException {
+        final Zahlen.Element[] a = new Zahlen.Element[in.readInt()];
+        for(int i = 0; i < a.length; i++) {
+          a[i] = Zahlen.ELEMENT_FACTORY.valueOf(in);
+        }
+        final int k0 = in.readInt();
+        set(new Part(k0, a));
+      }
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  public static class ZahlenSplit extends InputSplit implements Writable {
+    private FunctionDescriptor var;
+    private int k0;
+    private String[] locations;
+    
+    public ZahlenSplit() {}
+    ZahlenSplit(final FunctionDescriptor var, final int k0, final String[] locations) {
+      this.var = var;
+      this.k0 = k0;
+      this.locations = locations;
+    }
+    
+    @Override
+    public long getLength() {return 1;}
+    @Override
+    public String[] getLocations() {return locations;}
+    @Override
+    public final void readFields(DataInput in) throws IOException {
+      var = FunctionDescriptor.valueOf(in);
+      k0 = in.readInt();
+    }
+    @Override
+    public final void write(DataOutput out) throws IOException {
+      var.serialize(out);
+      out.writeInt(k0);
+    }
+  }
+
+  public static class ZahlenInputFormat
+      extends InputFormat<IntWritable, FunctionDescriptor> {
+    @Override
+    public final RecordReader<IntWritable, FunctionDescriptor> createRecordReader(
+        InputSplit generic, TaskAttemptContext context) {
+      final ZahlenSplit split = (ZahlenSplit)generic;
+      
+      //return a record reader
+      return new RecordReader<IntWritable, FunctionDescriptor>() {
+        private boolean done = false;
+        
+        /** {@inheritDoc} */
+        @Override
+        public void initialize(InputSplit split, TaskAttemptContext context) {}
+        /** {@inheritDoc} */
+        @Override
+        public boolean nextKeyValue() {return !done ? done = true : false;}
+        /** {@inheritDoc} */
+        @Override
+        public IntWritable getCurrentKey() {return new IntWritable(split.k0);}
+        /** {@inheritDoc} */
+        @Override
+        public FunctionDescriptor getCurrentValue() {return split.var;}
+        /** {@inheritDoc} */
+        @Override
+        public float getProgress() {return done? 1f: 0f;}
+        /** {@inheritDoc} */
+        @Override
+        public void close() {}
+      };
+    }
+
+    static final String[] EMPTY = {};
+
+    @Override
+    public List<InputSplit> getSplits(JobContext context
+        ) throws IOException, InterruptedException {
+      final Configuration conf = context.getConfiguration();
+      final FunctionDescriptor var = FunctionDescriptor.valueOf(conf);
+      final List<Function.Variable> variables = var.input.getVariables();
+      
+      if (variables.isEmpty()) {
+        throw new IOException("variables.isEmpty(), " + var);
+      }
+
+      final DistMpBase parameters = DistMpBase.valueOf(conf);
+      final String name = variables.get(0).getName();
+      final Path vardir = new Path(parameters.dir, name);
+      final FileSystem fs = vardir.getFileSystem(conf);
+      final FileStatus[] statuses = fs.listStatus(vardir);
+      Arrays.sort(statuses, CMP);
+
+      final List<InputSplit> splits = new ArrayList<InputSplit>(var.numParts.value);
+      for(int k0 = 0; k0 < var.numParts.value; k0++) {
+        final String filename = FunctionDescriptor.getFileName(name, k0);
+        final int i = Arrays.binarySearch(statuses, filename, CMP);
+        if (i < 0) {
+          throw new IOException("File not found: filename=" + filename
+              + ", vardir=" + vardir);
+        }
+        final BlockLocation[] locations = fs.getFileBlockLocations(statuses[i], 0L, 1L);
+        final String[] hosts = locations.length == 0? EMPTY: locations[0].getHosts();
+        splits.add(new ZahlenSplit(var, k0, hosts));
+      }
+      return splits;
+    }
+    
+    private static final Comparator<Object> CMP = new Comparator<Object>() {
+      @Override
+      public int compare(final Object l, final Object r) {
+        return object2String(l).compareTo(object2String(r));
+      }
+    };
+    private static String object2String(final Object obj) {
+      return obj instanceof String? (String)obj: ((FileStatus)obj).getPath().getName(); 
+    }
+  }
+
+  public static class ZahlenOutputFormat
+      extends SequenceFileOutputFormat<IntWritable, ZahlenSerialization.E> {
+    private static String NAME = ZahlenOutputFormat.class.getSimpleName().toLowerCase();
+    private static String SPLIT_DIGITS_PER_ELEMENT_CONF_KEY = NAME + ".split.digitsPerElement";
+    private static String SPLIT_N_SUMMANDS_CONF_KEY = NAME + ".split.nSummands";
+
+    public static void setSplit(final int digitsPerElement, final int nSummands,
+        final Configuration conf) {
+      if (nSummands < 1) {
+        throw new IllegalArgumentException(nSummands + " = nSummands < 1");
+      }
+      conf.setInt(SPLIT_N_SUMMANDS_CONF_KEY, nSummands);
+      conf.setInt(SPLIT_DIGITS_PER_ELEMENT_CONF_KEY, digitsPerElement);
+    }
+    
+    public static String toSplitName(final Function.Variable var, final int i) {
+      return var.getName() + "_" + i;
+    }
+
+    public static Function.Variable[] toSplitVariables(final Function.Variable var, final int m) {
+      final Function.Variable[] parts = new Function.Variable[m];
+      for(int i = 0; i < parts.length; i++) {
+        parts[i] = Function.Variable.valueOf(toSplitName(var, i));
+      }
+      return parts;
+    }
+
+    public ZahlenOutputFormat() {}
+
+    @Override
+    public RecordWriter<IntWritable, E> getRecordWriter(
+        final TaskAttemptContext context) throws IOException, InterruptedException {
+      final Configuration conf = context.getConfiguration();
+      final int nSummands = conf.getInt(SPLIT_N_SUMMANDS_CONF_KEY, 1);
+      final ZahlenDescriptor var = ZahlenDescriptor.valueOf(conf);
+      final int part = context.getTaskAttemptID().getTaskID().getId();
+      final Path workpath = ((FileOutputCommitter)getOutputCommitter(context)).getWorkPath();
+      final FileSystem fs = workpath.getFileSystem(conf);
+
+      if (nSummands == 1) {
+        final String name = ZahlenDescriptor.getFileName(var.output.getName(), part);
+        final SequenceFile.Writer out = SequenceFile.createWriter(fs, conf, 
+            new Path(workpath, name), IntWritable.class, E.class,
+            CompressionType.NONE, null, context);
+
+        return new RecordWriter<IntWritable, E>() {
+          @Override
+          public void write(IntWritable key, E value) throws IOException {
+            out.append(key, value);
+          }
+          @Override
+          public void close(TaskAttemptContext context) throws IOException {out.close();}
+        };
+      } else {
+        final SequenceFile.Writer[] out = new SequenceFile.Writer[nSummands];
+
+        for(int s = 0; s < out.length; s++) {
+          final String name = toSplitName(var.output, s);
+          final Path parent = new Path(workpath, name);
+          fs.mkdirs(parent);
+          final String f = ZahlenDescriptor.getFileName(name, (part + s) & var.numParts.mask);
+
+          out[s] = SequenceFile.createWriter(fs, conf, new Path(parent, f),
+              IntWritable.class, E.class,
+              CompressionType.NONE, null, context);
+        }
+      
+        final int D = var.elementsPerPart << var.numParts.exponent;
+        final int digitsPerElement = conf.getInt(SPLIT_DIGITS_PER_ELEMENT_CONF_KEY, 0);
+
+        return new RecordWriter<IntWritable, E>() {
+          private boolean first = true;
+
+          @Override
+          public void write(IntWritable key, E value) throws IOException {
+            Zahlen.Element q = value.get();
+            final int startkey = key.get();
+
+            //insert zeros
+            if (first) {
+              first = false;
+              final int d = part + out.length - var.numParts.value;
+              if (d > 0) {
+                value.set(q.get().newElement());
+                for(int k = 0; k < d; k++) {
+                  key.set(k);
+                  out[out.length - d + k].append(key, value);
+                }
+              }
+            }
+
+            //write output
+            final int limit = Math.min(out.length, D - startkey);
+            for(int i = 0; i < limit; i++) {
+              final Zahlen.Element r = q;
+              q = r.divideRemainderEqual(digitsPerElement);
+              key.set(startkey + i);
+              out[i].append(key, value.set(r));
+              r.reclaim();
+            }
+          }
+
+          @Override
+          public void close(TaskAttemptContext context) throws IOException { 
+            for(int i = 0; i < out.length; i++)
+              out[i].close();
+          }
+        };
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/IndexInputFormat.java
===================================================================
--- src/examples/org/apache/hadoop/mp/IndexInputFormat.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/IndexInputFormat.java	(revision 0)
@@ -0,0 +1,101 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.io.IntWritable;
+import org.apache.hadoop.io.NullWritable;
+import org.apache.hadoop.io.Writable;
+import org.apache.hadoop.mapreduce.InputFormat;
+import org.apache.hadoop.mapreduce.InputSplit;
+import org.apache.hadoop.mapreduce.JobContext;
+import org.apache.hadoop.mapreduce.RecordReader;
+import org.apache.hadoop.mapreduce.TaskAttemptContext;
+
+
+public class IndexInputFormat extends InputFormat<IntWritable, NullWritable> {
+  private static final String PREFIX = IndexInputFormat.class.getName();
+  private static final String N_PARTS =  PREFIX + ".nParts";
+
+  public static class IndexSplit extends InputSplit implements Writable {
+    private final static String[] EMPTY = {};
+    
+    protected int index;
+    
+    public IndexSplit() {}
+    IndexSplit(int index) {this.index = index;}
+
+    @Override
+    public long getLength() {return 1;}
+    @Override
+    public String[] getLocations() {return EMPTY;}
+
+    @Override
+    public final void readFields(DataInput in) throws IOException {
+      index = in.readInt();
+    }
+    @Override
+    public final void write(DataOutput out) throws IOException {
+      out.writeInt(index);
+    }
+  }
+
+  /** Specify how to read the records */
+  @Override
+  public final RecordReader<IntWritable, NullWritable> createRecordReader(
+      InputSplit generic, TaskAttemptContext context) {
+    final IndexSplit split = (IndexSplit)generic;
+
+    //return a record reader
+    return new RecordReader<IntWritable, NullWritable>() {
+      private boolean done = false;
+
+      @Override
+      public void initialize(InputSplit split, TaskAttemptContext context) {}
+      @Override
+      public boolean nextKeyValue() {return !done ? done = true : false;}
+      @Override
+      public IntWritable getCurrentKey() {return new IntWritable(split.index);}
+      @Override
+      public NullWritable getCurrentValue() {return NullWritable.get();}
+      @Override
+      public float getProgress() {return done? 1f: 0f;}
+      @Override
+      public void close() {}
+    };
+  }
+
+  @Override
+  public final List<InputSplit> getSplits(final JobContext context) {
+    final int nParts = context.getConfiguration().getInt(N_PARTS, 0);
+    final List<InputSplit> splits = new ArrayList<InputSplit>(nParts);
+    for(int i = 0; i < nParts; i++)
+      splits.add(new IndexSplit(i));
+    return splits;
+  }
+  
+  public static void setNumParts(final int nParts, final Configuration conf) {
+    conf.setInt(N_PARTS, nParts);
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/ZahlenDescriptor.java
===================================================================
--- src/examples/org/apache/hadoop/mp/ZahlenDescriptor.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/ZahlenDescriptor.java	(revision 0)
@@ -0,0 +1,274 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp;
+
+import java.io.Closeable;
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.Map;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.io.IntWritable;
+import org.apache.hadoop.io.SequenceFile;
+import org.apache.hadoop.mp.math.PowerOfTwo_int;
+import org.apache.hadoop.mp.math.SchonhageStrassen;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.util.Print;
+import org.apache.hadoop.mp.util.serialization.ConfSerializable;
+import org.apache.hadoop.mp.util.serialization.DataSerializable;
+
+/**
+ * Describe an Zahlen object.
+ */
+public class ZahlenDescriptor implements ConfSerializable, DataSerializable<Void> {
+  private static final String PREFIX = ZahlenDescriptor.class.getSimpleName();
+  private static final String PROPERTY_OUTPUT = PREFIX + ".output";
+  private static final String PROPERTY_NUM_PARTS = PREFIX + ".numParts";
+  private static final String PROPERTY_ELEMENTS_PER_PART = PREFIX + ".elementsPerPart";
+
+  public final PowerOfTwo_int numParts;
+  public final int elementsPerPart;
+  public final Function.Variable output;
+  
+  public ZahlenDescriptor(final Function.Variable output,
+      final PowerOfTwo_int numParts, final int elementsPerPart) {
+    this.numParts = numParts;
+    this.elementsPerPart = elementsPerPart;
+    this.output = output;
+    
+    if (numParts.value != elementsPerPart) {
+      throw new IllegalArgumentException("numParts.value != elementsPerPart = "
+          + elementsPerPart + ", numParts = " + numParts);
+    }
+  }
+  
+  @Override
+  public String toString() {
+    return getClass().getSimpleName() + "(numParts=" + numParts
+    + ", elementsPerPart=" + elementsPerPart + ")";
+  }
+
+  @Override
+  public void serialize(final Configuration conf) {
+    conf.set(PROPERTY_OUTPUT, output.serialize());
+    conf.set(PROPERTY_NUM_PARTS, numParts.serialize());
+    conf.setInt(PROPERTY_ELEMENTS_PER_PART, elementsPerPart);
+  }
+
+  public static ZahlenDescriptor valueOf(final Configuration conf) {
+    final Function.Variable output = Function.Variable.valueOf(conf.get(PROPERTY_OUTPUT));
+    final PowerOfTwo_int numParts = PowerOfTwo_int.VALUE_OF_STR.valueOf(conf.get(PROPERTY_NUM_PARTS));
+    final int elementsPerPart = conf.getInt(PROPERTY_ELEMENTS_PER_PART, 0);
+    return new ZahlenDescriptor(output, numParts, elementsPerPart);
+  }
+
+  @Override
+  public Void serialize(DataOutput out) throws IOException {
+    output.serialize(out);
+    numParts.serialize(out);
+    out.writeInt(elementsPerPart);
+    return null;
+  }
+  
+  public static ZahlenDescriptor valueOf(DataInput in) throws IOException {
+    final Function.Variable output = Function.Variable.valueOf(in);
+    final PowerOfTwo_int numParts = PowerOfTwo_int.valueOf(in);
+    final int elementsPerPart = in.readInt();
+    return new ZahlenDescriptor(output, numParts, elementsPerPart);
+  }
+
+  public static String getFileName(final String name, final int part) {
+    return name + String.format(".%05d", part);
+  }
+
+  static Path getFilePath(final String name, final int part, final String parent) {
+    return new Path(parent+Path.SEPARATOR+name, getFileName(name, part));
+  }
+
+  public Path getOutputPath(String parent) {return new Path(parent, output.getName());}
+
+  public Zahlen.Element[] readOutput(final int offset,
+      final String parent, final Configuration conf) throws IOException {
+    return read(output, offset, numParts, elementsPerPart, parent, conf);
+  }
+
+  static Map<Function.Variable, Zahlen.Element> read(
+      final Map<Function.Variable, Zahlen.Element> m, final Function f,
+      final SchonhageStrassen schonhagestrassen, final Zahlen largeZ,
+      final String dir, final Configuration conf) throws IOException {
+    if (f instanceof Function.Variable) {
+      final Function.Variable var = (Function.Variable)f;
+      final Zahlen.Element e = read(var, schonhagestrassen, largeZ, dir, conf);
+      m.put(var, e);
+    } else if (f instanceof Function.BinaryOperator) {
+      final Function.BinaryOperator opr = (Function.BinaryOperator)f;
+      read(m, opr.left, schonhagestrassen, largeZ, dir, conf);
+      read(m, opr.right, schonhagestrassen, largeZ, dir, conf);
+    } else {
+      throw new UnsupportedOperationException("f.getClass() = " + f.getClass());
+    }
+    return m;
+  }
+
+  public static Zahlen.Element read(final Function.Variable var,
+      final SchonhageStrassen schonhagestrassen, final Zahlen largeZ,
+      final String dir, final Configuration conf) throws IOException {
+    final PowerOfTwo_int K = PowerOfTwo_int.values()[schonhagestrassen.D.exponent >> 1];
+    final PowerOfTwo_int J = PowerOfTwo_int.values()[schonhagestrassen.D.exponent - K.exponent];
+
+    final Zahlen.Element[] array = new Zahlen.Element[schonhagestrassen.D.value];
+    for(int j0 = 0; j0 < J.value; j0++) {
+      final Zahlen.Element[] t = read(var, j0, J, K.value, dir, conf);
+      for(int i = 0; i < t.length; i++)
+        array[(i << J.exponent) + j0] = t[i];
+    }
+    schonhagestrassen.carrying(array);
+    
+    final Zahlen.Element combined = largeZ.newElement().combine(
+        array, schonhagestrassen.digitsPerElement());
+    for(int i = 0; i < array.length; i++)
+      array[i].reclaim();
+    return combined;
+  }
+
+  private static Zahlen.Element[] read(final Function.Variable var,
+      final int offset, final PowerOfTwo_int step, final int numElements,
+      final String parent, final Configuration conf) throws IOException {
+    final Path f = getFilePath(var.getName(), offset, parent);
+    if (ZahlenSerialization.PRINT_LEVEL.is(Print.Level.TRACE)) {
+      Print.println("read(name=" + var
+          + ", offset=" + offset
+          + ", step=" + step
+          + ", numElements=" + numElements
+          + ", parent=" + parent
+          + ")");
+      Print.println("     f = " + f);
+    }
+
+    final FileSystem fs = f.getFileSystem(conf);
+    final SequenceFile.Reader in  = new SequenceFile.Reader(fs, f, conf);
+    final Zahlen.Element[] elements = new Zahlen.Element[numElements];
+    final IntWritable key = new IntWritable();
+    final ZahlenSerialization.E e = new ZahlenSerialization.E();
+    try {
+      for(int i = 0; i < elements.length; i++) {
+        in.next(key, e);
+        if (key.get() != (i << step.exponent) + offset)
+          throw new IOException(key.get() + " = key.get() != i*step + offset, i="
+              + i + ", + offset=" + offset + ", step=" + step);
+        elements[i] = e.get();
+      }
+    } finally {
+      in.close();
+    }
+    return elements;
+  }
+
+  static class Reader implements Closeable {
+    final Function.Variable var;
+    final int offset;
+    final PowerOfTwo_int step;
+    final int numElements;
+
+    private final SequenceFile.Reader in;
+    private final IntWritable key = new IntWritable();
+    private final ZahlenSerialization.E e = new ZahlenSerialization.E();
+    private int i = 0;
+    
+    Reader(final Function.Variable var, final int offset,
+        final PowerOfTwo_int step, final int numElements,
+        final String dir, final Configuration conf) throws IOException {
+      this.var = var;
+      this.offset = offset;
+      this.step = step;
+      this.numElements = numElements;
+
+      final Path f = getFilePath(var.getName(), offset, dir);
+      if (ZahlenSerialization.PRINT_LEVEL.is(Print.Level.TRACE)) {
+        Print.println(getClass().getSimpleName() + "(var=" + var
+            + ", offset=" + offset
+            + ", step=" + step
+            + ", dir=" + dir
+            + ")");
+        Print.println("     f = " + f);
+      }
+
+      final FileSystem fs = f.getFileSystem(conf);
+      in  = new SequenceFile.Reader(fs, f, conf);
+    }
+
+    Zahlen.Element readNext() throws IOException {
+      if (i == numElements)
+        throw new IOException(i + " = i == numElements = " + numElements);
+
+      in.next(key, e);
+      if (key.get() != (i << step.exponent) + offset) {
+        throw new IOException(key.get() + " = key.get() != i*step + offset, i="
+            + i + ", + offset=" + offset + ", step=" + step);
+      }
+      i++;
+      return e.get();
+    }
+
+    @Override
+    public void close() throws IOException {
+      in.close();      
+    }
+  }
+
+  public static void write(final Function.Variable var, final Zahlen.Element[] elements,
+      final int offset, final PowerOfTwo_int step, final int numElements,
+      final String parent, final Configuration conf) throws IOException {
+    final Path f = getFilePath(var.getName(), offset, parent);
+    final FileSystem fs = f.getFileSystem(conf);
+    final SequenceFile.Writer out  = SequenceFile.createWriter(fs, conf, f,
+        IntWritable.class, ZahlenSerialization.E.class,
+        SequenceFile.CompressionType.NONE);
+
+    final IntWritable key = new IntWritable();
+    final ZahlenSerialization.E value = new ZahlenSerialization.E();
+
+    try {
+      for(int k1 = 0; k1 < numElements; k1++) {
+        final int i = (k1 << step.exponent) + offset;
+        key.set(i);
+        out.append(key, value.set(elements[i]));
+      }
+    } finally {
+      out.close();
+    }      
+  }
+
+  public static void write(final Function.Variable var, final Zahlen.Element x,
+      final SchonhageStrassen schonhagestrassen,
+      final String dir, final Configuration conf) throws IOException {
+    final PowerOfTwo_int K = PowerOfTwo_int.values()[schonhagestrassen.D.exponent >> 1];
+    final PowerOfTwo_int J = PowerOfTwo_int.values()[schonhagestrassen.D.exponent - K.exponent];
+    final int digitsPerElement = schonhagestrassen.digitsPerElement();
+    final Zahlen.Element[] elements = x.splitAndReclaim(digitsPerElement, schonhagestrassen);
+    for(int k0 = 0; k0 < K.value; k0++) {
+      write(var, elements, k0, K, J.value, dir, conf);
+    }
+    for(int i = 0; i < elements.length; i++) {
+      elements[i].reclaim();
+    }
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/gmp/GmpMultiplier.java
===================================================================
--- src/examples/org/apache/hadoop/mp/gmp/GmpMultiplier.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/gmp/GmpMultiplier.java	(revision 0)
@@ -0,0 +1,117 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.gmp;
+
+import java.io.BufferedReader;
+import java.io.Closeable;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.PrintStream;
+import java.util.Arrays;
+
+import org.apache.hadoop.mp.math.PowerOfTwo_int;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.util.Print;
+
+public class GmpMultiplier implements Zahlen.Multiplier, Closeable {
+  public static final PowerOfTwo_int BASE = PowerOfTwo_int.values()[4];
+
+  private static final String CMD = File.separatorChar == '/'? "./gmp_mult": "gmp_mult.exe";
+
+  private static final ThreadLocal<GmpMultiplier> t = new ThreadLocal<GmpMultiplier>() {
+    @Override
+    protected GmpMultiplier initialValue() {
+      try {
+        return new GmpMultiplier();
+      } catch (IOException e) {
+        throw new RuntimeException(e);
+      }
+    }
+  };
+  
+  public static GmpMultiplier get() {return t.get();}
+
+  private final String name;
+  private int count = 0;
+
+  private final Process process;
+  private final PrintStream stdin;
+  private final InputStream stdout;
+
+  private final BufferedReader stderr;
+  private final Thread messager;
+  
+  private GmpMultiplier() throws IOException {
+    this.name = Thread.currentThread().getName();
+
+    final String[] cmd = {CMD, "" + BASE.value};
+    Print.println(this + ": cmd=" + Arrays.asList(cmd));
+
+    this.process = new ProcessBuilder(cmd).start();
+    this.stdin = new PrintStream(process.getOutputStream(), true); 
+    this.stdout = process.getInputStream();
+
+    this.stderr = new BufferedReader(new InputStreamReader(process.getErrorStream()));
+    this.messager = new Thread() {
+      @Override
+      public void run() {
+        Print.println(GmpMultiplier.this + ": messager started.");
+        try {
+          for(String line; !isInterrupted() && (line = stderr.readLine()) != null; ) {
+            Print.println(GmpMultiplier.this + ": " + line);
+          }
+        } catch(IOException ioe) {
+          Print.println(this);
+          Print.printStackTrace(ioe);
+        } finally {
+          Print.println(GmpMultiplier.this + ": messager terminated.");
+        }
+      }
+    };
+    messager.start();
+  }
+
+  @Override
+  public void close() throws IOException {
+    messager.interrupt();
+    process.destroy();
+    stdin.close();
+    stdout.close();
+    stderr.close();
+  }
+
+  @Override
+  public String toString() {
+    return getClass().getSimpleName() + "(" + name + ", count=" + count + ")";
+  }
+  
+  @Override
+  public synchronized Zahlen.Element multiply(
+      final Zahlen.Element l, final Zahlen.Element r) {
+    count++;
+    l.serialize(stdin).println();
+    r.serialize(stdin).println();
+    try {
+      return l.get().valueOf(stdout);
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+}
Index: src/examples/org/apache/hadoop/mp/FunctionDescriptor.java
===================================================================
--- src/examples/org/apache/hadoop/mp/FunctionDescriptor.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/FunctionDescriptor.java	(revision 0)
@@ -0,0 +1,276 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp;
+
+import java.io.DataInput;
+import java.io.DataInputStream;
+import java.io.DataOutput;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.mp.Function.Variable;
+import org.apache.hadoop.mp.math.PowerOfTwo_int;
+import org.apache.hadoop.mp.math.SchonhageStrassen;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Parse;
+import org.apache.hadoop.mp.util.Print;
+
+/**
+ * Describe a function.
+ */
+public class FunctionDescriptor extends ZahlenDescriptor {
+  /////////////////////////////////////////////////////////////////////////////
+  private static final String PREFIX = FunctionDescriptor.class.getSimpleName();
+  private static final String PROPERTY_INPUTS = PREFIX + ".inputs";
+
+  public final Function input;
+  
+  public FunctionDescriptor(final Function input, final Function.Variable output,
+      final PowerOfTwo_int numParts, final int elementsPerPart) {
+    super(output, numParts, elementsPerPart);
+    this.input = input;
+  }
+  
+  @Override
+  public String toString() {
+    return getClass().getSimpleName() + "(input=" + input
+    + ", output=" + output + ")";
+  }
+
+  public String functionString() {
+    return input.toString();
+  }
+
+  @Override
+  public void serialize(final Configuration conf) {
+    super.serialize(conf);
+    conf.set(PROPERTY_INPUTS, input.serialize());
+  }
+
+  public static FunctionDescriptor valueOf(final Configuration conf) {
+    final ZahlenDescriptor z = ZahlenDescriptor.valueOf(conf);
+    final Function input = Function.PARSER.valueOf(conf.get(PROPERTY_INPUTS));
+    return new FunctionDescriptor(input, z.output, z.numParts, z.elementsPerPart);
+  }
+
+  @Override
+  public Void serialize(DataOutput out) throws IOException {
+    super.serialize(out);
+    input.serialize(out);
+    return null;
+  }
+  
+  public static FunctionDescriptor valueOf(DataInput in) throws IOException {
+    final ZahlenDescriptor z = ZahlenDescriptor.valueOf(in);
+    final Function input = Function.PARSER.valueOf(in);
+    return new FunctionDescriptor(input, z.output, z.numParts, z.elementsPerPart);
+  }
+
+  public static Zahlen.Element evaluateLocal(
+      final Function.Variable result, final Function f,
+      final SchonhageStrassen schonhagestrassen, final Zahlen largeZ,
+      final JavaUtil.WorkGroup workers,
+      final String dir, final Configuration conf) throws Exception {
+    final Map<Function.Variable, Zahlen.Element> m = read(
+        new TreeMap<Function.Variable, Zahlen.Element>(),
+        f, schonhagestrassen, largeZ, dir, conf);
+    final Zahlen.Element r = f.evaluate(m, workers);
+    for(Zahlen.Element e : m.values()) {
+      e.reclaim();
+    }
+    if (result != null) {
+      write(result, r, schonhagestrassen, dir, conf);
+    }
+    return r;
+  }
+
+  /** Read and evaluate a function. */
+  public static class Evaluater {
+    private static final int BATCH_SIZE = 64;
+
+    private final int offset;
+    private final PowerOfTwo_int step;
+    private final int numElements;
+    
+    private final SchonhageStrassen schonhagestrassen;
+
+    private final String dir;
+    private final Configuration conf;
+      
+    public Evaluater(final int offset, final PowerOfTwo_int step, final int numElements,
+        final SchonhageStrassen schonhagestrassen,
+        final String dir, final Configuration conf) {
+      this.offset = offset;
+      this.step = step;
+      this.numElements = numElements;
+      
+      this.schonhagestrassen = schonhagestrassen;
+
+      this.dir = dir;
+      this.conf = conf;
+    }
+    
+    public Zahlen.Element[] evaluate(final Function f, final JavaUtil.Timer timer,
+        final JavaUtil.WorkGroup workers) throws IOException {
+      final Zahlen.Element[] z = new Zahlen.Element[numElements];
+      final List<Variable> variables = f.getVariables();
+      
+      //print required space
+      final long available = Runtime.getRuntime().maxMemory() - (1L << 28);
+      final long required = (z.length >> 3) * ((long)schonhagestrassen.modulusExponent);
+      final int todisk_threshold = 0;//required < available? 0: z.length - 2*BATCH_SIZE;
+      Print.println(              "variables.size() = " + variables.size());
+      Print.println(String.format("available        = %.3f GB (= "
+          + Parse.long2string(available) + " B)",
+          available/(double)(1 << 30)));
+      Print.println(String.format("required         = %.3f GB (= "
+          + Parse.long2string(required) + " B)",
+          required/(double)(1 << 30)));
+      Print.println(              "todisk_threshold = " + todisk_threshold);
+
+      final List<VariableReader> readers = new ArrayList<VariableReader>();
+      final Runner[] runners = new Runner[z.length];
+      try {
+        //open files
+        for(Variable var: variables) {
+          readers.add(new VariableReader(var));
+        }
+        timer.tick("readers.size() = " + readers.size());
+
+        //evaluate
+        for(int i = 0; i < z.length;) {
+          for(int j = 0; i < z.length && j < BATCH_SIZE; j++) {
+            runners[i] = new Runner(f, i, readNext(readers), i < todisk_threshold);
+            workers.submit("i=" + i, runners[i]);
+            i++;
+          }
+          workers.waitUntil(16);
+          timer.tick("evaluating " + f + ", i=" + i);
+          if ((i & 0xFF) == 0) {
+            Print.printMemoryInfo();
+          }
+        }
+      } finally {
+        for(VariableReader r : readers) {
+          if (r.in != null) {
+            try {
+              r.in.close();
+            } catch(IOException ioe) {
+              Print.println("Close failed(r.var=" + r.var + "): " + ioe);
+            }
+          }
+        }
+      }
+      workers.waitUntilZero();
+
+      for(int i = 0; i < z.length; i++) {
+        z[i] = runners[i].getResult();
+      }
+      return z;
+    }
+    
+    private static final Map<Function.Variable, Zahlen.Element> readNext(
+        final List<VariableReader> readers) throws IOException {
+      final Map<Function.Variable, Zahlen.Element> m = new TreeMap<Function.Variable, Zahlen.Element>();
+      for(VariableReader r: readers) {
+        final Zahlen.Element e = r.in.readNext();
+        m.put(r.var, e);
+      }
+      return m;
+    }
+    
+    private class VariableReader {
+      final Variable var;
+      final ZahlenDescriptor.Reader in;
+      
+      VariableReader(final Variable var) throws IOException {
+        this.var = var;
+        this.in = new Reader(var, offset, step, numElements, dir, conf);
+      }
+    }
+    
+    private class Runner implements Runnable {
+      final Function f;
+      final int index;
+      final Map<Function.Variable, Zahlen.Element> m;
+      final boolean todisk;
+      private Zahlen.Element result = null;
+      private File tmpfile = null;
+      
+      Runner(final Function f, final int index,
+          final Map<Function.Variable, Zahlen.Element> m,
+          final boolean todisk) {
+        this.f = f;
+        this.index = index;
+        this.m = m;
+        this.todisk = todisk;
+      }
+
+      Zahlen.Element getResult() {
+        if (result == null) {
+          for(int i = 0; i < 3; i++) {
+            try {
+              final DataInputStream in = new DataInputStream(new FileInputStream(tmpfile));
+              try {
+                result = ZahlenSerialization.E.valueOf(in);
+              } finally {
+                in.close();
+              }
+            } catch (IOException ioe) {
+              Print.println("Got an exception when reading from " + tmpfile);
+              Print.printStackTrace(ioe);
+            }
+          }
+        }
+        return result;
+      }
+
+      @Override
+      public void run() {
+        result = f.ssEvaluate(m, schonhagestrassen);
+        m.clear();
+
+        if (todisk) {
+          try {
+            tmpfile = File.createTempFile(String.format("z%04d-", index), ".writable");
+            final DataOutputStream out = new DataOutputStream(new FileOutputStream(tmpfile));
+            try {
+              new ZahlenSerialization.E().set(result).write(out);
+            } finally {
+              out.close();
+            }
+          } catch (IOException e) {
+            throw new RuntimeException(e);
+          }
+          result.reclaim();
+          result = null;
+//          Print.println("Wrote result " + index + " of " + f + " to " + tmpfile);
+        }
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/sum/DistCarrying.java
===================================================================
--- src/examples/org/apache/hadoop/mp/sum/DistCarrying.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/sum/DistCarrying.java	(revision 0)
@@ -0,0 +1,288 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.sum;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.io.IntWritable;
+import org.apache.hadoop.io.NullWritable;
+import org.apache.hadoop.io.Writable;
+import org.apache.hadoop.mapreduce.InputFormat;
+import org.apache.hadoop.mapreduce.InputSplit;
+import org.apache.hadoop.mapreduce.Job;
+import org.apache.hadoop.mapreduce.JobContext;
+import org.apache.hadoop.mapreduce.Mapper;
+import org.apache.hadoop.mapreduce.RecordReader;
+import org.apache.hadoop.mapreduce.Reducer;
+import org.apache.hadoop.mapreduce.TaskAttemptContext;
+import org.apache.hadoop.mp.DistMpBase;
+import org.apache.hadoop.mp.Function;
+import org.apache.hadoop.mp.FunctionDescriptor;
+import org.apache.hadoop.mp.ZahlenDescriptor;
+import org.apache.hadoop.mp.ZahlenSerialization;
+import org.apache.hadoop.mp.ZahlenSerialization.ZahlenOutputFormat;
+import org.apache.hadoop.mp.math.PowerOfTwo_int;
+import org.apache.hadoop.mp.math.SchonhageStrassen;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Print;
+import org.apache.hadoop.mp.util.serialization.DataSerializable;
+
+public class DistCarrying extends DistComponentwiseOp {
+  public static final String VERSION = "20110128b";
+
+  static final Print.Level PRINT_LEVEL = Print.Level.VERBOSE;
+  static final boolean IS_VERBOSE = PRINT_LEVEL.is(Print.Level.VERBOSE);
+
+  public static final String NAME = DistCarrying.class.getSimpleName().toLowerCase();
+  public static final String DESCRIPTION = "Distributed Carrying";
+  
+  public DistCarrying(SchonhageStrassen schonhagestrassen, PowerOfTwo_int J,
+      PowerOfTwo_int K, String dir) {
+    super(schonhagestrassen, J, K, dir);
+  }
+
+  public static class CarryingMapper
+      extends Mapper<NullWritable, ZahlenDescriptor, IntWritable, CarryingDescriptor.W> {
+    protected void map(final NullWritable nullwritable, final ZahlenDescriptor y,
+        final Context context) throws IOException, InterruptedException {
+      //initialize
+      final DistMpBase.TaskHelper helper = new DistMpBase.TaskHelper(context,
+          NAME + ".VERSION = " + VERSION);
+    
+      final Configuration conf = context.getConfiguration();
+      final DistMpBase parameters = DistMpBase.valueOf(conf);
+      parameters.printDetail(getClass().getSimpleName());
+      helper.show("init: y=" + y);
+    
+      //read carries, differences
+      final int nWorkers = conf.getInt(N_WORKERS_CONF_KEY, 16);
+      final JavaUtil.WorkGroup workers = new JavaUtil.WorkGroup(
+          getClass().getSimpleName(), nWorkers, null);
+      final CarryDifference.Reader cdreader = new CarryDifference.Reader(
+          y, parameters.dir, conf);
+      final CarryDifference[] cds = cdreader.readAll(helper.timer, workers);
+      helper.show("CarryDifference: cds.length = " + cds.length);
+
+      //compute actual carries
+      final byte[] carries = new byte[cds.length];
+      carries[0] = cds[0].c;
+      for(int t = 1; t < cds.length; t++) {
+        carries[t] = cds[t].c;
+        if (carries[t-1] >= cds[t].d)
+          carries[t]++;
+      }
+      helper.show("Actuall carries: c.length = " + carries.length);
+
+      //write output
+      final byte[] c = new byte[y.elementsPerPart];
+      final IntWritable index = new IntWritable();
+      final CarryingDescriptor.W baw = new CarryingDescriptor.W();
+      baw.set(new CarryingDescriptor(y, c));
+      for(int i = 0; i < y.numParts.value; i++) {
+        int k = i;
+        for(int j = 0; j < c.length; j++) {
+          c[j] = carries[k];
+          k += y.numParts.value;
+        }
+        index.set((i + 1) & y.numParts.mask);
+        context.write(index, baw);
+      }
+      helper.show(getClass().getSimpleName());
+    }
+  }
+
+  public static class CarryingReducer
+      extends Reducer<IntWritable, CarryingDescriptor.W, IntWritable, ZahlenSerialization.E> {
+    @Override
+    protected final void reduce(final IntWritable index,
+        final Iterable<CarryingDescriptor.W> writables,
+        final Context context) throws IOException, InterruptedException {
+      //initialize
+      final DistMpBase.TaskHelper helper = new DistMpBase.TaskHelper(context,
+          NAME + ".VERSION = " + VERSION);
+    
+      final Configuration conf = context.getConfiguration();
+      final DistMpBase parameters = DistMpBase.valueOf(conf);
+      parameters.printDetail(getClass().getSimpleName());
+    
+      final int k = index.get();
+      helper.show("init: k=" + k);
+    
+      //read inputs
+      final Iterator<CarryingDescriptor.W> baw = writables.iterator();
+      final CarryingDescriptor descriptor = baw.next().get();
+      if (baw.hasNext()) {
+        throw new IOException("Not a singleton list.");
+      }
+      final ZahlenDescriptor r = descriptor.remainder;
+      final Zahlen.Element[] y = r.readOutput(k, parameters.dir, conf);
+      helper.show("read input: " + r.output + ", length=" + y.length);
+    
+      //carrying
+      if (k == 0) {
+        for(int j = 1; j < y.length; j++)
+          parameters.schonhagestrassen.plusEqual(y[j], descriptor.carries[j - 1]);
+      } else {
+        for(int j = 0; j < y.length; j++)
+          parameters.schonhagestrassen.plusEqual(y[j], descriptor.carries[j]);
+      }
+      
+      helper.show("carrying");
+
+      //write output
+      DistMpBase.TaskHelper.write(y, k, r.numParts, r.elementsPerPart, context);
+      helper.show(getClass().getSimpleName());
+    }
+  }
+  
+  public static class CarryingDescriptor implements DataSerializable<Void> {
+    final ZahlenDescriptor remainder;
+    final byte[] carries;
+
+    CarryingDescriptor(final ZahlenDescriptor remainder, final byte[] carries) {
+      this.remainder = remainder;
+      this.carries = carries;
+    }
+    
+    @Override
+    public Void serialize(DataOutput out) throws IOException {
+      remainder.serialize(out);
+      out.writeInt(carries.length);
+      out.write(carries);
+      return null;
+    }
+    
+    public static class W extends DataSerializable.W<CarryingDescriptor> {
+      @Override
+      public void readFields(DataInput in) throws IOException {
+        final ZahlenDescriptor remainder = ZahlenDescriptor.valueOf(in);
+        final byte[] carries = new byte[in.readInt()];
+        in.readFully(carries);
+        set(new CarryingDescriptor(remainder, carries));
+      }
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  public static class CarryingSplit extends InputSplit implements Writable {
+    private static final String[] EMPTY = new String[0];
+
+    private ZahlenDescriptor var;
+    
+    public CarryingSplit() {}
+    CarryingSplit(final ZahlenDescriptor var) {
+      this.var = var;
+    }
+    
+    @Override
+    public long getLength() {return 1;}
+    @Override
+    public String[] getLocations() {return EMPTY;}
+    @Override
+    public final void readFields(DataInput in) throws IOException {
+      var = ZahlenDescriptor.valueOf(in);
+    }
+    @Override
+    public final void write(DataOutput out) throws IOException {
+      var.serialize(out);
+    }
+  }
+
+  public static class CarryingInputFormat
+      extends InputFormat<NullWritable, ZahlenDescriptor> {
+    @Override
+    public final RecordReader<NullWritable, ZahlenDescriptor> createRecordReader(
+        InputSplit generic, TaskAttemptContext context) {
+      final CarryingSplit split = (CarryingSplit)generic;
+      
+      //return a record reader
+      return new RecordReader<NullWritable, ZahlenDescriptor>() {
+        private boolean done = false;
+        
+        /** {@inheritDoc} */
+        @Override
+        public void initialize(InputSplit split, TaskAttemptContext context) {}
+        /** {@inheritDoc} */
+        @Override
+        public boolean nextKeyValue() {return !done ? done = true : false;}
+        /** {@inheritDoc} */
+        @Override
+        public NullWritable getCurrentKey() {return NullWritable.get();}
+        /** {@inheritDoc} */
+        @Override
+        public ZahlenDescriptor getCurrentValue() {return split.var;}
+        /** {@inheritDoc} */
+        @Override
+        public float getProgress() {return done? 1f: 0f;}
+        /** {@inheritDoc} */
+        @Override
+        public void close() {}
+      };
+    }
+    
+    static final String[] EMPTY = {};
+    
+    @Override
+    public List<InputSplit> getSplits(JobContext context
+        ) throws IOException, InterruptedException {
+      final Configuration conf = context.getConfiguration();
+      final FunctionDescriptor var = FunctionDescriptor.valueOf(conf);
+      final List<Function.Variable> variables = var.input.getVariables();
+      if (variables.size() != 1) {
+        throw new IOException("variables.size() != 1, " + var);
+      }
+    
+      final List<InputSplit> splits = new ArrayList<InputSplit>(var.numParts.value);
+      final ZahlenDescriptor d = new ZahlenDescriptor(variables.get(0), var.numParts, var.elementsPerPart);
+      splits.add(new CarryingSplit(d));
+      return splits;
+    }
+  }
+  
+  protected Job newJob(final Configuration conf) throws IOException {
+    final Job job = super.newJob(conf);
+    job.setJarByClass(DistCarrying.class);
+
+    // setup mapper
+    job.setMapperClass(CarryingMapper.class);
+    job.setMapOutputKeyClass(IntWritable.class);
+    job.setMapOutputValueClass(CarryingDescriptor.W.class);
+
+    // setup reducer
+    job.setReducerClass(CarryingReducer.class);
+    job.setOutputKeyClass(IntWritable.class);
+    job.setOutputValueClass(ZahlenSerialization.E.class);
+    job.setNumReduceTasks(J.value);
+
+    // setup input
+    job.setInputFormatClass(CarryingInputFormat.class);
+    job.setOutputFormatClass(ZahlenOutputFormat.class);
+    return job; 
+  }
+
+  @Override
+  protected String jobName(final FunctionDescriptor f) {
+    return dir + ": " + f.output + " = carry(" + f.functionString() + ")";
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/sum/DistCompSum.java
===================================================================
--- src/examples/org/apache/hadoop/mp/sum/DistCompSum.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/sum/DistCompSum.java	(revision 0)
@@ -0,0 +1,62 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.sum;
+
+import java.io.IOException;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.mp.DistMpBase;
+import org.apache.hadoop.mp.Function;
+import org.apache.hadoop.mp.FunctionDescriptor;
+import org.apache.hadoop.mp.math.PowerOfTwo_int;
+import org.apache.hadoop.mp.math.SchonhageStrassen;
+import org.apache.hadoop.mp.util.Print;
+
+public class DistCompSum extends DistComponentwiseOp {
+  public static final String VERSION = "20110125";
+
+  static final Print.Level PRINT_LEVEL = Print.Level.VERBOSE;
+  static final boolean IS_VERBOSE = PRINT_LEVEL.is(Print.Level.VERBOSE);
+
+  public static final String NAME = DistCompSum.class.getSimpleName().toLowerCase();
+  public static final String DESCRIPTION = "Distributed Multi-precision Summation";
+  
+  public DistCompSum(SchonhageStrassen schonhagestrassen, PowerOfTwo_int J,
+      PowerOfTwo_int K, String dir) {
+    super(schonhagestrassen, J, K, dir);
+  }
+
+  private FunctionDescriptor toFunctionDescriptor(final Function.Variable output,
+      final Function... summands) throws IOException {
+    if (summands.length < 2) {
+      throw new IllegalArgumentException(summands.length + " = summands.length < 2");
+    }
+    Function sum = new Function.Addition(summands[0], summands[1]);
+    for(int i = 2; i < summands.length; i++) {
+      sum = new Function.Addition(sum, summands[i]);
+    }
+    return new FunctionDescriptor(sum, output, J, K.value);
+  }
+
+  public class SumJob extends DistMpBase.MpJob {
+    public SumJob(final Function.Variable output, final Configuration conf,
+        final Function... f) throws IOException {
+      super(toFunctionDescriptor(output, f), conf);
+    }
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/sum/CarryDifference.java
===================================================================
--- src/examples/org/apache/hadoop/mp/sum/CarryDifference.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/sum/CarryDifference.java	(revision 0)
@@ -0,0 +1,306 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.sum;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.BlockLocation;
+import org.apache.hadoop.fs.FileStatus;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.io.IntWritable;
+import org.apache.hadoop.io.SequenceFile;
+import org.apache.hadoop.io.SequenceFile.CompressionType;
+import org.apache.hadoop.io.Writable;
+import org.apache.hadoop.mapreduce.InputFormat;
+import org.apache.hadoop.mapreduce.InputSplit;
+import org.apache.hadoop.mapreduce.JobContext;
+import org.apache.hadoop.mapreduce.RecordReader;
+import org.apache.hadoop.mapreduce.RecordWriter;
+import org.apache.hadoop.mapreduce.TaskAttemptContext;
+import org.apache.hadoop.mapreduce.lib.output.FileOutputCommitter;
+import org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat;
+import org.apache.hadoop.mp.DistMpBase;
+import org.apache.hadoop.mp.Function;
+import org.apache.hadoop.mp.FunctionDescriptor;
+import org.apache.hadoop.mp.ZahlenDescriptor;
+import org.apache.hadoop.mp.ZahlenSerialization;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.serialization.DataSerializable;
+
+public class CarryDifference implements DataSerializable<Void> {
+  final byte c;
+  final byte d;
+
+  CarryDifference(final byte c, final byte d) {
+    this.c = c;
+    this.d = d;
+  }
+
+  @Override
+  public Void serialize(DataOutput out) throws IOException {
+    out.write(c);
+    out.write(d);
+    return null;
+  }
+
+  public static class CD extends DataSerializable.W<CarryDifference> {
+    public CD() {}
+    @Override
+    public void readFields(DataInput in) throws IOException {
+      final byte c = in.readByte();
+      final byte d = in.readByte();
+      set(new CarryDifference(c, d));
+    }
+  }
+
+  public static class Remainder extends CarryDifference {
+    final Zahlen.Element r;
+
+    Remainder(final Zahlen.Element r, final int c, final int d) {
+      super(JavaUtil.toByte(c), JavaUtil.toByte(d));
+      this.r = r;
+    }
+
+    CarryDifference toCarryDifference() {return new CarryDifference(c, d);}
+
+    @Override
+    public Void serialize(DataOutput out) throws IOException {
+      r.serialize(out);
+      return super.serialize(out);
+    }
+
+    public static class W extends DataSerializable.W<Remainder> {
+      public W() {}
+      @Override
+      public void readFields(DataInput in) throws IOException {
+        final Zahlen.Element r = Zahlen.ELEMENT_FACTORY.valueOf(in);
+        final byte c = in.readByte();
+        final byte d = in.readByte();
+        set(new Remainder(r, c, d));
+      }
+    }
+  }
+
+  static String getCarryDifferenceFileName(final String varname) {
+    return varname + "_cd";
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  public static class CdOutputFormat
+      extends SequenceFileOutputFormat<IntWritable, Remainder.W> {
+    public CdOutputFormat() {}
+    
+    @Override
+    public RecordWriter<IntWritable, Remainder.W> getRecordWriter(
+        final TaskAttemptContext context) throws IOException, InterruptedException {
+      final Configuration conf = context.getConfiguration();
+      final ZahlenDescriptor var = ZahlenDescriptor.valueOf(conf);
+      final int part = context.getTaskAttemptID().getTaskID().getId();
+      final Path workpath = ((FileOutputCommitter)getOutputCommitter(context)).getWorkPath();
+      final FileSystem fs = workpath.getFileSystem(conf);
+    
+      final String name = ZahlenDescriptor.getFileName(var.output.getName(), part);
+      final SequenceFile.Writer out = SequenceFile.createWriter(fs, conf, 
+          new Path(workpath, name), IntWritable.class, ZahlenSerialization.E.class,
+          CompressionType.NONE, null, context);
+      final String name_cd = getCarryDifferenceFileName(name);
+      final SequenceFile.Writer out_cd = SequenceFile.createWriter(fs, conf, 
+          new Path(workpath, name_cd), IntWritable.class, CD.class,
+          CompressionType.NONE, null, context);
+    
+      return new RecordWriter<IntWritable, Remainder.W>() {
+        final ZahlenSerialization.E e = new ZahlenSerialization.E();
+        final CD cd = new CD();
+    
+        @Override
+        public void write(IntWritable key, Remainder.W value) throws IOException {
+          final Remainder cdr = value.get();
+          e.set(cdr.r);
+          out.append(key, e);
+          cd.set(cdr.toCarryDifference());
+          out_cd.append(key, cd);
+        }
+        @Override
+        public void close(TaskAttemptContext context) throws IOException {
+          out.close();
+          out_cd.close();
+        }
+      };
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  public static class CdSplit extends InputSplit implements Writable {
+    private FunctionDescriptor var;
+    private int k0;
+    private String[] locations;
+    
+    public CdSplit() {}
+    CdSplit(final FunctionDescriptor var, final int k0, final String[] locations) {
+      this.var = var;
+      this.k0 = k0;
+      this.locations = locations;
+    }
+    
+    @Override
+    public long getLength() {return 1;}
+    @Override
+    public String[] getLocations() {return locations;}
+    @Override
+    public final void readFields(DataInput in) throws IOException {
+      var = FunctionDescriptor.valueOf(in);
+      k0 = in.readInt();
+    }
+    @Override
+    public final void write(DataOutput out) throws IOException {
+      var.serialize(out);
+      out.writeInt(k0);
+    }
+  }
+
+  public static class CdInputFormat
+      extends InputFormat<IntWritable, FunctionDescriptor> {
+    @Override
+    public final RecordReader<IntWritable, FunctionDescriptor> createRecordReader(
+        InputSplit generic, TaskAttemptContext context) {
+      final CdSplit split = (CdSplit)generic;
+      
+      //return a record reader
+      return new RecordReader<IntWritable, FunctionDescriptor>() {
+        private boolean done = false;
+        
+        /** {@inheritDoc} */
+        @Override
+        public void initialize(InputSplit split, TaskAttemptContext context) {}
+        /** {@inheritDoc} */
+        @Override
+        public boolean nextKeyValue() {return !done ? done = true : false;}
+        /** {@inheritDoc} */
+        @Override
+        public IntWritable getCurrentKey() {return new IntWritable(split.k0);}
+        /** {@inheritDoc} */
+        @Override
+        public FunctionDescriptor getCurrentValue() {return split.var;}
+        /** {@inheritDoc} */
+        @Override
+        public float getProgress() {return done? 1f: 0f;}
+        /** {@inheritDoc} */
+        @Override
+        public void close() {}
+      };
+    }
+    
+    static final String[] EMPTY = {};
+    
+    @Override
+    public List<InputSplit> getSplits(JobContext context
+        ) throws IOException, InterruptedException {
+      final Configuration conf = context.getConfiguration();
+      final FunctionDescriptor var = FunctionDescriptor.valueOf(conf);
+      final List<Function.Variable> variables = var.input.getVariables();
+      
+      if (variables.isEmpty()) {
+        throw new IOException("variables.isEmpty(), " + var);
+      }
+    
+      final DistMpBase parameters = DistMpBase.valueOf(conf);
+      final String name = variables.get(0).getName();
+      final Path vardir = new Path(parameters.dir, name);
+      final FileSystem fs = vardir.getFileSystem(conf);
+      final FileStatus[] statuses = fs.listStatus(vardir);
+      Arrays.sort(statuses);
+    
+      final List<InputSplit> splits = new ArrayList<InputSplit>(var.numParts.value);
+      for(int k0 = 0; k0 < var.numParts.value; k0++) {
+        final FileStatus s = statuses[k0];
+        if (!FunctionDescriptor.getFileName(name, k0).equals(s.getPath().getName())) {
+          throw new IOException("Name mismatched");
+        }
+        final BlockLocation[] locations = fs.getFileBlockLocations(s, 0L, 1L);
+        final String[] hosts = locations.length == 0? EMPTY: locations[0].getHosts();
+        splits.add(new CdSplit(var, k0, hosts));
+      }
+      return splits;
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  /** Read and evaluate a function. */
+  static class Reader {
+    private final CarryDifference[] carrydifferences;
+    private final ZahlenDescriptor y;
+    private final String dir;
+    private final Configuration conf;
+      
+    Reader(final ZahlenDescriptor y, final String dir, final Configuration conf) {
+      this.carrydifferences = new CarryDifference[y.elementsPerPart << y.numParts.exponent];
+      this.y = y;
+      this.dir = dir;
+      this.conf = conf;
+    }
+    
+    CarryDifference[] readAll(final JavaUtil.Timer timer, final JavaUtil.WorkGroup workers) {
+      timer.tick("y = " + y);
+      for(int i = 0; i < y.numParts.value; i++) {
+        workers.submit("i=" + i, new Runner(i));
+      }
+      workers.waitUntilZero();
+
+      return carrydifferences;
+    }
+    
+    private class Runner implements Runnable {
+      final int offset;
+
+      Runner(final int offset) {this.offset = offset;}
+
+      @Override
+      public void run() {
+        try {
+          final String name = ZahlenDescriptor.getFileName(y.output.getName(), offset);
+          final Path f = new Path(dir+Path.SEPARATOR+y.output.getName(), CarryDifference.getCarryDifferenceFileName(name));
+          final FileSystem fs = f.getFileSystem(conf);
+          final IntWritable key = new IntWritable();
+          final CD cd = new CD();
+  
+          final SequenceFile.Reader in  = new SequenceFile.Reader(fs, f, conf);
+          try {
+            for(int i = 0; i < y.elementsPerPart; i++) {
+              in.next(key, cd);
+              final int index = (i << y.numParts.exponent) + offset;
+              if (key.get() != index) {
+                throw new IOException(key.get() + " = key.get() != i*numParts + offset = " + index
+                    + ", i=" + i + ", + offset=" + offset + ", y=" + y);
+              }
+              carrydifferences[index] = cd.get();
+            }
+          } finally {
+            in.close();
+          }
+        } catch(IOException ioe) {
+          throw new RuntimeException(ioe);
+        }
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/sum/DistComponentwiseOp.java
===================================================================
--- src/examples/org/apache/hadoop/mp/sum/DistComponentwiseOp.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/sum/DistComponentwiseOp.java	(revision 0)
@@ -0,0 +1,126 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.sum;
+
+import java.io.IOException;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.io.IntWritable;
+import org.apache.hadoop.mapreduce.Job;
+import org.apache.hadoop.mapreduce.Mapper;
+import org.apache.hadoop.mp.DistMpBase;
+import org.apache.hadoop.mp.FunctionDescriptor;
+import org.apache.hadoop.mp.ZahlenSerialization.ZahlenInputFormat;
+import org.apache.hadoop.mp.math.PowerOfTwo_int;
+import org.apache.hadoop.mp.math.SchonhageStrassen;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Print;
+
+public class DistComponentwiseOp extends DistMpBase {
+  public static final String VERSION = "20110128";
+
+  static final Print.Level PRINT_LEVEL = Print.Level.VERBOSE;
+  static final boolean IS_VERBOSE = PRINT_LEVEL.is(Print.Level.VERBOSE);
+
+  public static final String NAME = DistComponentwiseOp.class.getSimpleName().toLowerCase();
+  public static final String DESCRIPTION = "Distributed Componentwise Operation";
+  
+  public DistComponentwiseOp(SchonhageStrassen schonhagestrassen,
+      PowerOfTwo_int J, PowerOfTwo_int K, String dir) {
+    super(schonhagestrassen, J, K, dir);
+  }
+
+  public static class ComponentwiseMapper
+      extends Mapper<IntWritable, FunctionDescriptor, IntWritable, CarryDifference.Remainder.W> {
+    protected void map(final IntWritable index, final FunctionDescriptor fun,
+        final Context context) throws IOException, InterruptedException {
+      //initialize
+      final DistMpBase.TaskHelper helper = new DistMpBase.TaskHelper(context,
+          NAME + ".VERSION = " + VERSION);
+
+      final Configuration conf = context.getConfiguration();
+      final DistMpBase parameters = DistMpBase.valueOf(conf);
+      parameters.printDetail(getClass().getSimpleName());
+      Print.println("fun = " + fun);
+
+      final int k = index.get();
+      helper.show("init: k=" + k);
+
+      //evaluate inputs
+      final int nWorkers = conf.getInt(N_WORKERS_CONF_KEY, 2);
+      final JavaUtil.WorkGroup workers = new JavaUtil.WorkGroup(
+          getClass().getSimpleName(), nWorkers, null);
+      final FunctionDescriptor.Evaluater evaluater = new FunctionDescriptor.Evaluater(
+          k, fun.numParts, fun.elementsPerPart, parameters.schonhagestrassen,
+          parameters.dir, conf); 
+      final Zahlen.Element[] r = evaluater.evaluate(fun.input, helper.timer, workers);
+      helper.show("evaluating inputs: r.length = " + r.length);
+
+      //compute carries, differences, remainders
+      final int m = fun.input.getVariables().size();
+      final int exponent_in_digits = parameters.schonhagestrassen.digitsPerElement();
+      final CarryDifference.Remainder[] cdr = new CarryDifference.Remainder[r.length];
+      for(int i = 0; i < r.length; i++) {
+        final String s = r[i].toBrief();
+        final Zahlen.Element c = r[i].divideRemainderEqual(exponent_in_digits);
+        final int d = r[i].difference(exponent_in_digits, m);
+        try {
+          cdr[i] = new CarryDifference.Remainder(r[i], c.toInt(), d);
+        } catch(IllegalArgumentException iae) {
+          throw new RuntimeException("r[" + i + "]\n= " + s
+              + "\nr[" + i + "].divideRemainderEqual(" + exponent_in_digits
+              + ")\n= " + r[i].toBrief()
+              + "\nc\n= " + c.toBrief(), iae);
+        }
+      }
+      helper.show("carry-difference-remainder: k=" + k);
+
+      //write output
+      final IntWritable key = new IntWritable();
+      final CarryDifference.Remainder.W w = new CarryDifference.Remainder.W();
+      for(int j = 0; j < r.length; j++) {
+        if (j < 10 || j + 10 >= r.length)
+          Print.println("r[" + j + "]=" + r[j].toBrief());
+        else if (j == 10)
+          Print.println("...");
+
+        key.set((j << fun.numParts.exponent) + k);
+        w.set(cdr[j]);
+        context.write(key, w);
+      }
+      helper.show(getClass().getSimpleName());
+    }
+  }
+
+  @Override
+  protected Job newJob(final Configuration conf) throws IOException {
+    final Job job = super.newJob(conf);
+
+    // setup mapper
+    job.setMapperClass(ComponentwiseMapper.class);
+    job.setMapOutputKeyClass(IntWritable.class);
+    job.setMapOutputValueClass(CarryDifference.Remainder.W.class);
+
+    // setup input
+    job.setInputFormatClass(ZahlenInputFormat.class);
+    job.setOutputFormatClass(CarryDifference.CdOutputFormat.class);
+    return job; 
+  }
+
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/DistZahlen.java
===================================================================
--- src/examples/org/apache/hadoop/mp/DistZahlen.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/DistZahlen.java	(revision 0)
@@ -0,0 +1,245 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.Random;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.io.IntWritable;
+import org.apache.hadoop.io.NullWritable;
+import org.apache.hadoop.mapreduce.Job;
+import org.apache.hadoop.mapreduce.Mapper;
+import org.apache.hadoop.mp.ZahlenSerialization.ZahlenOutputFormat;
+import org.apache.hadoop.mp.fft.DistMpMultTest;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.util.HadoopUtil;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Parse;
+import org.apache.hadoop.mp.util.Print;
+import org.apache.hadoop.mp.util.serialization.ConfSerializable;
+import org.apache.hadoop.util.ToolRunner;
+
+
+public class DistZahlen extends HadoopUtil.RunnerBase {
+  protected DistZahlen() throws FileNotFoundException {}
+
+  public static final String VERSION = "20100904";
+
+  static final Print.Level PRINT_LEVEL = Print.Level.VERBOSE;
+  static final boolean IS_VERBOSE = PRINT_LEVEL.is(Print.Level.VERBOSE);
+
+  public static final String NAME = DistZahlen.class.getSimpleName().toLowerCase();
+  public static final String DESCRIPTION = "Gerenate a Zahlen";
+  
+  static final AtomicBoolean printversions = new AtomicBoolean(false);  
+  public static void printVersions() {
+    if (!printversions.getAndSet(true)) {
+      Print.println(NAME + ".VERSION = " + VERSION);
+      Print.printSystemInfo();
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  public static class Parameter implements ConfSerializable, Print.Detail {
+    private static final String PREFIX = DistZahlen.class.getSimpleName()
+                                       + "." + Parameter.class.getSimpleName();
+    private static final String PROPERTY_ZAHLEN = PREFIX + "." + Zahlen.class.getSimpleName();
+    private static final String PROPERTY_NUM_ELEMENTS = PREFIX + ".numElements";
+    private static final String PROPERTY_DIGITS_PER_ELEMENT = PREFIX + ".digitsPerElement";
+    private static final String PROPERTY_DIR = PREFIX + ".dir";
+
+    final Zahlen smallZ;
+    final ZahlenDescriptor var;
+    final int numElements;
+    final int digitsPerElement;
+    final String dir;
+
+    Parameter(final Zahlen smallZ, final ZahlenDescriptor var,
+        final int numElements, final int digitsPerElement, final String dir) {
+      this.smallZ = smallZ;
+      this.var = var;
+      this.numElements = numElements;
+      this.digitsPerElement = digitsPerElement;
+      this.dir = dir;
+    }
+    
+    Parameter(final ZahlenDescriptor vars, final DistMpMultTest.Parameter mult,
+        final String dir) {
+      this(mult.schonhagestrassen.Z, vars, mult.K.value << (mult.J.exponent - 1),
+          mult.schonhagestrassen.digitsPerElement(), dir);
+    }
+
+    @Override
+    public String toString() {
+      return DistZahlen.class.getSimpleName() + "." + Parameter.class.getSimpleName()
+          + "(var=" + var
+          + ", numElements=" + numElements
+          + ", digitsPerElement=" + digitsPerElement
+          + ")";
+    }
+    
+    @Override
+    public void serialize(final Configuration conf) {
+      conf.set(PROPERTY_ZAHLEN, smallZ.serialize());
+      var.serialize(conf);
+      conf.setInt(PROPERTY_NUM_ELEMENTS, numElements);
+      conf.setInt(PROPERTY_DIGITS_PER_ELEMENT, digitsPerElement);
+      conf.set(PROPERTY_DIR, dir);
+    }
+    
+    static Parameter valueOf(final Configuration conf) {
+      final Zahlen smallZ = Zahlen.FACTORY.valueOf(conf.get(PROPERTY_ZAHLEN));
+      final ZahlenDescriptor var = ZahlenDescriptor.valueOf(conf);
+      final int numElements = conf.getInt(PROPERTY_NUM_ELEMENTS, -1);
+      final int digitsPerElement = conf.getInt(PROPERTY_DIGITS_PER_ELEMENT, -1);
+      final String dir = conf.get(PROPERTY_DIR);
+      return new Parameter(smallZ, var, numElements, digitsPerElement, dir);
+    }
+
+    public void printDetail(final String name) {
+      Print.beginIndentation(PREFIX + ": " + name);
+      Print.println("smallZ           = " + smallZ);
+      Print.println("vars             = " + var);
+      Print.println("numElements      = " + numElements);
+      Print.println("digitsPerElement = " + digitsPerElement);
+      Print.println("dir              = " + dir);
+      Print.endIndentation();
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  public static class GenMapper
+      extends Mapper<IntWritable, NullWritable, IntWritable, ZahlenSerialization.E> {
+    protected void map(final IntWritable index, final NullWritable nullwritable,
+        final Context context) throws IOException, InterruptedException {
+      final JavaUtil.Timer timer = new JavaUtil.Timer(true, true);
+      int step = 0;
+      Print.printSystemInfo();
+
+      final Configuration conf = context.getConfiguration();
+      final Parameter parameters = Parameter.valueOf(conf);
+      parameters.printDetail(getClass().getSimpleName());
+
+      final int offset = index.get();
+      show("offset = " + offset, context, timer, ++step);
+
+      final Random r = JavaUtil.newRandom();
+      final IntWritable key = new IntWritable();
+      final ZahlenSerialization.E value = new ZahlenSerialization.E();
+
+      for(int j = 0; j < parameters.var.elementsPerPart; j++) {
+        final int i = (j << parameters.var.numParts.exponent) + offset;
+
+        final Zahlen.Element z = i < parameters.numElements?
+            parameters.smallZ.random(parameters.digitsPerElement, r):
+            parameters.smallZ.newElement();
+  
+        if (j < 10 || j + 10 >= parameters.var.elementsPerPart)
+          Print.println("j=" + j + ", i=" + i + ") z=" + z.toBrief());
+        else if (j == 10)
+          Print.println("...");
+
+        key.set(i);
+        value.set(z);
+        context.write(key, value);
+        z.reclaim();
+      }
+      show("END", context, timer, ++step);
+    }
+
+    static void show(final String message, final Context context,
+        final JavaUtil.Timer timer, final int step) {
+      timer.tick(message);
+      Print.printMemoryInfo();
+      context.setStatus(step + ") " + message);
+      context.progress();
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  static Job newJob(final Configuration conf) throws IOException {
+//  final Cluster cluster = new Cluster(JobTracker.getAddress(conf), conf);
+    final Job job = new Job(conf);
+    final Configuration jobconf = job.getConfiguration();
+    job.setJarByClass(DistZahlen.class);
+
+    // do not use speculative execution
+    //jobconf.setBoolean(JobContext.MAP_SPECULATIVE, false);
+    //jobconf.setBoolean(JobContext.REDUCE_SPECULATIVE, false);
+    jobconf.setBoolean("mapred.map.tasks.speculative.execution", true);
+    jobconf.setBoolean("mapred.reduce.tasks.speculative.execution", true);
+
+    // setup mapper
+    job.setMapperClass(GenMapper.class);
+    job.setMapOutputKeyClass(IntWritable.class);
+    job.setMapOutputValueClass(ZahlenSerialization.E.class);
+    jobconf.setBoolean("mapred.compress.map.output", false);
+
+    // setup reducer
+    job.setNumReduceTasks(0);
+    job.setOutputKeyClass(IntWritable.class);
+    job.setOutputValueClass(ZahlenSerialization.E.class);
+
+    // setup input/output
+    job.setInputFormatClass(IndexInputFormat.class);
+    job.setOutputFormatClass(ZahlenOutputFormat.class);
+    return job; 
+  }
+
+  /** Setup a job with the parameters. */
+  static String setupJob(final Job job, final Parameter parameters,
+      final String dir) throws IOException {
+    final Configuration jobconf = job.getConfiguration();
+    parameters.serialize(jobconf);
+    IndexInputFormat.setNumParts(parameters.var.numParts.value, jobconf);
+
+    final Path p = new Path(dir);
+    ZahlenOutputFormat.setOutputPath(job, p);
+
+    final String name = NAME + ": " + p.getName();
+    job.setJobName(name);
+    return name; 
+  }
+
+  @Override
+  public int run(String[] args) throws Exception {
+    Print.print("args", args);
+
+    int i = 0;
+    final int e = Parse.string2integer(args[i++]);
+    final String dir = args[i++];
+
+    final DistMpMultTest.Parameter mult = new DistMpMultTest.Parameter(e);
+    final Function.Variable output = Function.Variable.valueOf(new Path(dir).getName());
+    final ZahlenDescriptor d = new ZahlenDescriptor(output, mult.J, mult.K.value);
+    final Parameter parameters = new Parameter(d, mult, dir);
+    parameters.printDetail("main");
+
+    final Job job = newJob(getConf());
+    setupJob(job, parameters, dir);
+    job.submit();
+    job.waitForCompletion(true);
+    return 0;
+  }
+
+  /** main */
+  public static void main(String[] args) throws Exception {
+    System.exit(ToolRunner.run(null, new DistZahlen(), args));
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/Function.java
===================================================================
--- src/examples/org/apache/hadoop/mp/Function.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/Function.java	(revision 0)
@@ -0,0 +1,463 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.StringTokenizer;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.hadoop.io.Text;
+import org.apache.hadoop.mp.math.SchonhageStrassen;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Print;
+import org.apache.hadoop.mp.util.serialization.DataSerializable;
+import org.apache.hadoop.mp.util.serialization.StringSerializable;
+
+
+public abstract class Function implements StringSerializable, DataSerializable<Void> {
+  static final String SEPARATOR = " ";
+  static final Parser PARSER = new Parser();
+  static final Print.Level PRINT_LEVEL = Print.Level.VERBOSE;
+
+  /** Return the name of this function */
+  public abstract String getName();
+
+  public List<Variable> getVariables() {
+    final List<Variable> variables = new ArrayList<Variable>();
+    getVariablesRecursively(variables);
+    return variables;
+  }
+
+  private void getVariablesRecursively(final List<Variable> variables) {
+    if (this instanceof Variable) {
+      variables.add((Variable)this);
+    } else if (this instanceof UnaryOperator) {
+      final UnaryOperator opr = (UnaryOperator)this;
+      opr.fun.getVariablesRecursively(variables);
+    } else if (this instanceof BinaryOperator) {
+      final BinaryOperator opr = (BinaryOperator)this;
+      opr.left.getVariablesRecursively(variables);
+      opr.right.getVariablesRecursively(variables);
+    }
+  }
+
+  /** Evaluate this function over Schonhage-Strassen ring. */
+  public abstract Zahlen.Element ssEvaluate(
+      final Map<Function.Variable, Zahlen.Element> m,
+      final SchonhageStrassen schonhagestrassen);
+  
+  /** Evaluate this function */
+  public abstract Zahlen.Element evaluate(
+      final Map<Function.Variable, Zahlen.Element> m,
+      final JavaUtil.WorkGroup workers);
+
+  @Override
+  public final Void serialize(DataOutput out) throws IOException {
+    Text.writeString(out, serialize());
+    return null;
+  }
+
+  /** Infix notation */
+  public abstract String infix(boolean parenthesis);
+  @Override
+  public final String toString() {return infix(false);}
+  ///////////////////////////////////////////////////////////////////////////
+  public static final class Variable extends Function implements Comparable<Variable> {
+    private final String name;
+    
+    private Variable(String name) {this.name = name;}
+    
+    @Override
+    public String getName() {return name;}
+    @Override
+    public int compareTo(Variable that) {return this.name.compareTo(that.name);}
+    @Override
+    public int hashCode() {return name.hashCode();}
+
+    @Override
+    public final Zahlen.Element ssEvaluate(
+        final Map<Function.Variable, Zahlen.Element> m,
+        final SchonhageStrassen schonhagestrassen) {
+      return m.get(this);
+    }
+    @Override
+    public final Zahlen.Element evaluate(
+        final Map<Function.Variable, Zahlen.Element> m,
+        final JavaUtil.WorkGroup workers) {
+      return m.get(this);
+    }
+
+    @Override
+    public String infix(boolean parenthesis) {return name;}
+    @Override
+    public String serialize() {return name;}
+
+    public static Variable valueOf(DataInput in) throws IOException {
+      return valueOf(Text.readString(in));
+    }
+    
+    static final String VALID_SPECIAL_CHARACTERS = "_'";
+
+    public static Variable valueOf(String name) {
+      boolean valid = Character.isLetter(name.charAt(0));
+      int i = 1;
+      for(; valid && i < name.length(); ) {
+        final char c = name.charAt(i++);
+        valid = VALID_SPECIAL_CHARACTERS.indexOf(c) >= 0
+            || Character.isLetter(c) || Character.isDigit(c);
+      }
+      if (!valid) {
+        throw new IllegalArgumentException("\"" + name
+            + "\" is not valid variable name, i=" + i);
+      }
+      return new Variable(name);
+    }
+  }
+  ///////////////////////////////////////////////////////////////////////////
+  public static interface OperatorSymbol extends DataSerializable<Void> {
+    String getValue();
+
+    String getAcronym();
+  }
+
+  public static enum UnaryOperatorSymbol implements OperatorSymbol {
+    SQUARE("^2", "square"),
+    SQRT("sqrt", "sqrt")
+    ;
+    
+    public final String value;
+    public final String acronym;
+    UnaryOperatorSymbol(String symbol, String acronym) {
+      this.value = symbol;
+      this.acronym = acronym;
+    }
+    
+    public static UnaryOperatorSymbol string2operator(final String s) {
+      for(UnaryOperatorSymbol symbol : values()) {
+        if (s.equals(symbol.value))
+          return symbol;
+      }
+      return null;
+    }
+
+    @Override
+    public String getValue() {return value;}
+    @Override
+    public String getAcronym() {return acronym;}
+    @Override
+    public Void serialize(DataOutput out) throws IOException {
+      Text.writeString(out, value);
+      return null;
+    }
+  }
+  
+  public static enum BinaryOperatorSymbol implements OperatorSymbol {
+    ADDITION("+", "plus"),
+    MUPLICATION("**", "mult");
+    
+    public final String value;
+    public final String acronym;
+    BinaryOperatorSymbol(String symbol, String acronym) {
+      this.value = symbol;
+      this.acronym = acronym;
+    }
+    
+    public static BinaryOperatorSymbol string2operator(final String s) {
+      for(BinaryOperatorSymbol symbol : values()) {
+        if (s.equals(symbol.value))
+          return symbol;
+      }
+      return null;
+    }
+
+    @Override
+    public String getValue() {return value;}
+    @Override
+    public String getAcronym() {return acronym;}
+    @Override
+    public Void serialize(DataOutput out) throws IOException {
+      Text.writeString(out, value);
+      return null;
+    }
+  }
+  ///////////////////////////////////////////////////////////////////////////
+  static abstract class Operator extends Function {
+    public final OperatorSymbol symbol;
+    Operator(final OperatorSymbol symbol) {this.symbol = symbol;}
+  }
+
+  static abstract class UnaryOperator extends Operator {
+    final Function fun;
+
+    UnaryOperator(final UnaryOperatorSymbol symbol, Function fun) {
+      super(symbol);
+      this.fun = fun;      
+    }
+    
+    @Override
+    public String getName() {
+      return symbol.getAcronym() + "_" + fun.getName();
+    }
+    @Override
+    public final String serialize() {
+      return symbol.getValue() + SEPARATOR + fun.serialize();
+    }
+  }
+
+  public static class Square extends UnaryOperator {
+    final AtomicInteger count = new AtomicInteger(0);
+
+    public Square(Function fun) {
+      super(UnaryOperatorSymbol.SQUARE, fun);
+    }
+
+    @Override
+    public String infix(boolean parenthesis) {
+      final String s = fun.infix(true) + symbol.getValue();
+      return parenthesis? "(" + s + ")": s;
+    }
+
+    @Override
+    public final Zahlen.Element ssEvaluate(
+        final Map<Function.Variable, Zahlen.Element> m,
+        final SchonhageStrassen schonhagestrassen) {
+      final Zahlen.Element E = fun.ssEvaluate(m, schonhagestrassen);
+
+      final int c = count.getAndIncrement();
+      if (c % 256 == 0) {
+        System.out.println(getClass().getSimpleName() + ": c=" + c);
+        System.out.println("    E = " + E.toBrief());
+        if (c == 0) {
+          System.out.println("    over " + E.get());
+        }
+      }
+      schonhagestrassen.multiplyEqual(E, E);
+      return E;
+    }
+
+    @Override
+    public final Zahlen.Element evaluate(
+        final Map<Function.Variable, Zahlen.Element> m,
+        final JavaUtil.WorkGroup workers) {
+      final Zahlen.Element E = fun.evaluate(m, workers);
+      E.multiplyEqual(E, workers);
+      if (PRINT_LEVEL.is(Print.Level.VERBOSE)) {
+        Print.print(getClass().getSimpleName() + ": " + E.toBrief());
+      }
+      return E;
+    }
+  }
+  
+  public static class Sqrt extends UnaryOperator {
+    final AtomicInteger count = new AtomicInteger(0);
+
+    public Sqrt(Function fun) {
+      super(UnaryOperatorSymbol.SQRT, fun);
+    }
+
+    @Override
+    public String infix(boolean parenthesis) {
+      final String s = symbol.getValue() + "(" + fun.infix(false) + ")";
+      return parenthesis? "(" + s + ")": s;
+    }
+
+    @Override
+    public final Zahlen.Element ssEvaluate(
+        final Map<Function.Variable, Zahlen.Element> m,
+        final SchonhageStrassen schonhagestrassen) {
+      throw new UnsupportedOperationException(getClass().getSimpleName()
+          + " does not support ssEvaluate(..)");
+    }
+
+    @Override
+    public final Zahlen.Element evaluate(
+        final Map<Function.Variable, Zahlen.Element> m,
+        final JavaUtil.WorkGroup workers) {
+      final Zahlen.Element E = fun.evaluate(m, workers);
+      E.approximateSqrtReciprocalEqual(workers);
+      if (PRINT_LEVEL.is(Print.Level.VERBOSE)) {
+        Print.print(getClass().getSimpleName() + ": " + E.toBrief());
+      }
+      return E;
+    }
+  }
+
+  static abstract class BinaryOperator extends Operator {
+    final Function left;
+    final Function right;
+
+    BinaryOperator(BinaryOperatorSymbol symbol, Function left, Function right) {
+      super(symbol);
+      this.left = left;
+      this.right = right;
+    }
+
+    @Override
+    public String getName() {
+      return left.getName() + "_" + symbol.getAcronym() + "_" + right.getName();
+    }
+    @Override
+    public String infix(boolean parenthesis) {
+      final String s = left.infix(true) + SEPARATOR + symbol.getValue()
+          + SEPARATOR + right.infix(true);
+      return parenthesis? "(" + s + ")": s;
+    }
+    @Override
+    public final String serialize() {
+      return symbol.getValue() + SEPARATOR + left.serialize() + SEPARATOR + right.serialize();
+    }
+  }
+
+  public static class Multiplication extends BinaryOperator {
+    final AtomicInteger count = new AtomicInteger(0);
+
+    public Multiplication(Function left, Function right) {
+      super(BinaryOperatorSymbol.MUPLICATION, left, right);
+    }
+
+    @Override
+    public final Zahlen.Element ssEvaluate(
+        final Map<Function.Variable, Zahlen.Element> m,
+        final SchonhageStrassen schonhagestrassen) {
+      final Zahlen.Element L = left.ssEvaluate(m, schonhagestrassen);
+      final Zahlen.Element R = right.ssEvaluate(m, schonhagestrassen);
+
+      final int c = count.getAndIncrement();
+      if (c % 256 == 0) {
+        System.out.println(getClass().getSimpleName() + ": c=" + c);
+        System.out.println("    L = " + L.toBrief());
+        System.out.println("    R = " + R.toBrief());
+        if (c == 0) {
+          System.out.println("    over " + L.get());
+        }
+      }
+      schonhagestrassen.multiplyEqual(L, R);
+
+      R.reclaim();
+      return L;
+    }
+
+    @Override
+    public final Zahlen.Element evaluate(
+        final Map<Function.Variable, Zahlen.Element> m,
+        final JavaUtil.WorkGroup workers) {
+      final Zahlen.Element L = left.evaluate(m, workers);
+      final Zahlen.Element R = right.evaluate(m, workers);
+      L.multiplyEqual(R, workers);
+      if (PRINT_LEVEL.is(Print.Level.VERBOSE)) {
+        Print.print(getClass().getSimpleName() + ": " + L.toBrief());
+      }
+      return L;
+    }
+  }
+
+  public static class Addition extends BinaryOperator {
+    public Addition(Function left, Function right) {
+      super(BinaryOperatorSymbol.ADDITION, left, right);
+    }
+
+    @Override
+    public final Zahlen.Element ssEvaluate(
+        final Map<Function.Variable, Zahlen.Element> m,
+        final SchonhageStrassen schonhagestrassen) {
+      final Zahlen.Element L = left.ssEvaluate(m, schonhagestrassen);
+      final Zahlen.Element R = right.ssEvaluate(m, schonhagestrassen);
+
+      schonhagestrassen.plusEqual(L, R);
+
+      R.reclaim();
+      return L;
+    }
+
+    @Override
+    public final Zahlen.Element evaluate(
+        final Map<Function.Variable, Zahlen.Element> m,
+        final JavaUtil.WorkGroup workers) {
+      final Zahlen.Element L = left.evaluate(m, workers);
+      final Zahlen.Element R = right.evaluate(m, workers);
+      L.plusEqual(R);
+      if (PRINT_LEVEL.is(Print.Level.VERBOSE)) {
+        Print.print(getClass().getSimpleName() + ": " + L.toBrief());
+      }
+      return L;
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  public static class Parser implements StringSerializable.ValueOf<Function>,
+      DataSerializable.ValueOf<Function> {
+    @Override
+    public Function valueOf(final String s) {
+      final StringTokenizer t = new StringTokenizer(s, SEPARATOR);
+      final Function f = parse(t);
+      if (t.hasMoreTokens()) {
+        throw new IllegalArgumentException("t.hasMoreTokens()=" + t.hasMoreTokens()
+            + ", s=" + s + ", f=" + f);
+      }        
+      return f;
+    }
+
+    private Function parse(final StringTokenizer t) {
+      final String s = t.nextToken();
+      final UnaryOperatorSymbol uos = UnaryOperatorSymbol.string2operator(s);
+      if (uos != null) {
+        final Function fun = parse(t);
+        if (uos == UnaryOperatorSymbol.SQUARE) {
+          return new Square(fun);
+        } else if (uos == UnaryOperatorSymbol.SQRT) {
+          return new Sqrt(fun);
+        }
+      }
+
+      final BinaryOperatorSymbol bos = BinaryOperatorSymbol.string2operator(s);
+      if (bos != null) {
+        final Function left = parse(t);
+        final Function right = parse(t);
+        if (bos == BinaryOperatorSymbol.ADDITION) {
+          return new Addition(left, right);
+        } else if (bos == BinaryOperatorSymbol.MUPLICATION) {
+          return new Multiplication(left, right);
+        }
+      }
+      
+      if (uos == null && bos == null) {
+        return Variable.valueOf(s);
+      }
+
+      throw new IllegalArgumentException("parse failed, bos=" + bos
+          + ", s=" + s + ", t=" + t);
+    }
+
+    @Override
+    public Function valueOf(DataInput in) throws IOException {
+      return valueOf(Text.readString(in));
+    }
+  }
+  
+  public static void main(String[] args) {
+    String s = "+ + c'_0 c'_1 c'_2";
+    Print.println("s = " + s);
+    Function f = new Parser().valueOf(s);
+    Print.println("f = " + f);
+  }
+}
Index: src/examples/org/apache/hadoop/mp/pi/digit/Search.java
===================================================================
--- src/examples/org/apache/hadoop/mp/pi/digit/Search.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/pi/digit/Search.java	(revision 0)
@@ -0,0 +1,401 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.pi.digit;
+
+import java.io.BufferedReader;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.PrintStream;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.StringTokenizer;
+
+import org.apache.hadoop.mp.math.PowerOfTwo_int;
+import org.apache.hadoop.mp.math.PowerOfTwo_long;
+import org.apache.hadoop.mp.util.Print;
+
+/** Z, the set of integers. */
+public class Search {
+  final PowerOfTwo_int digitsPerArray;
+  final PowerOfTwo_int bitsPerDigit; // must be either 8 or 16
+  final PowerOfTwo_long digitLimit;
+  final int hexPerDigit;
+
+  public Search(final int bitsPerDigit, final int digitsPerElement) {
+    if (bitsPerDigit % Byte.SIZE != 0)
+      throw new IllegalArgumentException("bitsPerDigit (=" + bitsPerDigit
+          + ") is not a multiple of Byte.SIZE (=" + Byte.SIZE + ")");
+    if (Integer.SIZE < bitsPerDigit || Integer.SIZE % bitsPerDigit != 0)
+      throw new IllegalArgumentException("bitsPerDigit (=" + bitsPerDigit
+          + ") is not a factor of Integer.SIZE (=" + Integer.SIZE + ")");
+
+    this.digitsPerArray = PowerOfTwo_int.valueOf(digitsPerElement);
+    this.bitsPerDigit = PowerOfTwo_int.valueOf(bitsPerDigit);
+    this.digitLimit = PowerOfTwo_long.valueOf(1 << this.bitsPerDigit.value);
+    hexPerDigit = bitsPerDigit >> 2;
+  }
+
+  public String toString() {
+    return getClass().getSimpleName() + "\n    digitsPerElement = "
+        + digitsPerArray + "\n    bitsPerDigit     = " + bitsPerDigit
+        + "\n    digitLimit       = " + digitLimit;
+  }
+  // ///////////////////////////////////////////////////////////////////////////
+  public class Digit implements Cloneable {
+    private boolean positive = false;
+    private List<long[]> digits = new ArrayList<long[]>(1);
+    /** Total number of digits, not including leading zeros, not digits.size() */
+    private int nDigit = 0;
+
+    public Digit overwrite(final int startdigit, final String filename
+        ) throws IOException {
+      final BufferedReader in = new BufferedReader(new FileReader(filename));
+      try {
+        String line;
+  
+        trim(startdigit);
+        final int startarray = startdigit >> digitsPerArray.exponent;
+        int i = startdigit;
+        int r = startdigit & digitsPerArray.mask;
+        long[] a;
+        if (startarray == digits.size()) {
+          a = new long[digitsPerArray.value];
+          digits.add(a);;
+        } else { 
+          a = digits.get(startarray);
+        }
+  
+        for(int linenumber = 0; (line = in.readLine()) != null; linenumber++) {
+          if (line.startsWith("  ")) {
+            for(final StringTokenizer t = new StringTokenizer(line); t.hasMoreTokens(); ) {
+              final String hex = t.nextToken();
+              //expecting 8 hex per token
+              if (hex.length() != 8) {
+                throw new NumberFormatException(hex.length()
+                    + " = hex.length() != 8, hex=" + hex + "\n"
+                    + linenumber + ": " + line);
+              } else {
+                a[r] = (int)Long.parseLong(hex, 16);
+                i++;
+  
+                if (++r == digitsPerArray.value) {
+                  r = 0;
+                  a = new long[digitsPerArray.value];
+                  digits.add(a);
+                }
+              }
+            }
+          }
+        }
+        if (a != null)
+          nDigit = i;
+      } finally {
+        in.close();
+      }
+      return reverseEqual(startdigit);
+    }
+
+    public Digit reverseEqual(int startdigit) {
+      if (nDigit > startdigit) {
+        final int half = (nDigit - startdigit) >> 1;
+
+        int uq = (nDigit - 1) >> digitsPerArray.exponent;
+        int ur = (nDigit - 1) & digitsPerArray.mask;
+        long[] upper = digits.get(uq);
+
+        int lq = startdigit >> digitsPerArray.exponent;
+        int lr = startdigit & digitsPerArray.mask;
+        long[] lower = digits.get(lq);
+
+        for(int i = 0; i < half; i++) {
+          final long tmp = lower[lr];
+          lower[lr] = upper[ur];
+          upper[ur] = tmp;
+          
+          if (--ur < 0) {
+            ur = digitsPerArray.value - 1;
+            upper = digits.get(--uq);
+          }
+          if (++lr == digitsPerArray.value) {
+            lr = 0;
+            lower = digits.get(++lq);
+          }
+        }
+      }
+      return this;
+    }
+
+    /** Is this == 0? */
+    public boolean isZero() {
+      return nDigit == 0;
+    }
+
+    /**
+     * @return ceiling(log_2 |n|), where n is the number represented by this
+     *         object.
+     */
+    public int numberOfBits() {
+      if (isZero())
+        return 0;
+
+      final int i = nDigit - 1;
+      final long last = digits.get(i >> digitsPerArray.exponent)[i
+          & digitsPerArray.mask];
+      return (nDigit << bitsPerDigit.exponent) - bitsPerDigit.value
+          + Long.SIZE - Long.numberOfLeadingZeros(last);
+    }
+
+    public BigInteger toBigInteger() {
+      if (isZero())
+        return BigInteger.ZERO;
+
+      final byte[] bytes = new byte[((numberOfBits() - 1) >> 3) + 1];
+      int i = bytes.length;
+      for (long[] digitarray : digits)
+        for (long d : digitarray)
+          for (int j = 0; i > 0 && j < bitsPerDigit.value; j += Byte.SIZE)
+            bytes[--i] = (byte) ((d >> j) & 0xFF);
+      return new BigInteger(positive ? 1 : -1, bytes);
+    }
+
+    int search(String query) {
+      Print.println("\nquery = " + query);
+      return search(Util.reverse(query.getBytes()));
+    }
+
+    int search(final byte[] query) {
+      final int bitLength = query.length << 3;
+      Print.println("query = "+ Util.toHexString(query, 2, "       ")
+          + "\n      = "+ Util.toBitString(query, 8, " ")
+          + "\nbitLength = " + bitLength);
+      return search(Util.byte2long(query), bitLength);
+    }
+
+    int search(final long[] query, final int bitLength) {
+      Print.println("\nquery = "+ Util.toBitString(query, 8, " ")
+          + "\nbitLength = " + bitLength);
+
+      final long[][] bits = new long[bitsPerDigit.value][];
+      final long[] leftmask = new long[bitsPerDigit.value];
+      final long[] rightmask = new long[bitsPerDigit.value];
+      {
+        final long[] a = query;
+        bits[0] = a;
+        leftmask[0] = -1;
+        rightmask[0] = (-1) << (32 - (bitLength & 0x1F));
+        if (bitLength < 32)
+          leftmask[0] &= rightmask[0];
+  
+        final long digitmask = bitsPerDigit.value == 32? -1: digitLimit.mask;
+        for(int i = 1; i < bits.length; i++) {
+          leftmask[i] = -1 >>> i;
+          rightmask[i] = (-1) << (32 - ((bitLength + i) & 0x1F));
+          if (i + bitLength <= 32)
+            rightmask[i] = leftmask[i] &= rightmask[i];
+
+          final int leftshift = bitsPerDigit.value - i;
+          int k = ((bitLength + i - 1) >> bitsPerDigit.exponent);
+          final long[] b = bits[i] = new long[k + 1];
+          b[k] = a[a.length - 1] >>> i;
+          k--;
+          for(int j = a.length - 2; j >= 0; j--, k--) {
+            b[k] = (a[j + 1] << leftshift) & digitmask;
+            b[k] |= a[j] >>> i;
+          }
+          if (k == 0) {
+            b[0] = (a[0] << leftshift) & digitmask;
+          }
+        }
+        /*
+        for(int i = 0; i < bits.length; i++) {
+          Printer.println(String.format("d[%2d] = ", i)
+              + Util.toBitString(bits[i], 8, " ") + ", length=" + bits[i].length
+              + String.format(", masks=(%08X, %08X)", leftmask[i], rightmask[i]));
+        }
+        */
+      }
+
+      for(int d = nDigit - 1; d >= bits[0].length - 1; d--) {
+        final long first = digits.get(d >> digitsPerArray.exponent)[d & digitsPerArray.mask];
+
+        for(int i = 0; i < bits.length; i++) {
+          int j = bits[i].length - 1;
+          if (bits[i][j] == (first & leftmask[i])) {
+            if (bits[i].length == 1)
+              return ((nDigit - 1 - d) << bitsPerDigit.exponent) - i;
+            else if (d > 0) {
+              int k = (d - 1) & digitsPerArray.mask;
+              long[] b = digits.get((d - 1) >> digitsPerArray.exponent);
+              for(j--; j > 0 && bits[i][j] == b[k]; j--)
+                if (--k < 0) {
+                  k = digitsPerArray.value - 1;
+                  b = digits.get((d - (bits[i].length - 1 - j)) >> digitsPerArray.exponent);
+                }
+              if (j == 0)
+                if (bits[i][j] == (b[k] & rightmask[i]))
+                  return ((nDigit - 1 - d) << bitsPerDigit.exponent) + i;
+            }
+          }
+        }
+      }
+      return -1;
+    }
+
+    public void print(final int digitsPerLine, final PrintStream out) {
+      if (isZero())
+        out.println("0");
+
+      out.print((positive ? "+[" : "-[nDigit=") + nDigit + ":\n ");
+      printDigits(0, nDigit, digitsPerLine, out);      
+      out.println("]");
+    }
+
+    public void print(final int startdigit, final int enddigit,
+        final int digitsPerLine, final PrintStream out) {
+      if (isZero())
+        out.println("0");
+
+      out.print("digits[" + startdigit + ", " + enddigit + ":\n ");
+      printDigits(startdigit, enddigit, digitsPerLine, out);      
+      out.println("]");
+    }
+
+    private void printDigits(final int startdigit, final int enddigit,
+       final int digitsPerLine, final PrintStream out) {
+      if (enddigit > nDigit) {
+        throw new IllegalArgumentException(
+            enddigit + " = enddigit > nDigit = " + nDigit);
+      }
+      int i = enddigit - 1;
+      int q = i >> digitsPerArray.exponent;
+      int r = i & digitsPerArray.mask;
+      int k = 0;
+      for (; i >= startdigit && q >= 0; q--) {
+        final long[] d = digits.get(q);
+        for (; i >= startdigit && r >= 0; r--) {
+          out.format(" %0" + hexPerDigit + "X", d[r]);
+          i--;
+          if (++k == digitsPerLine) {
+            k = 0;
+            out.print("\n ");
+          }
+        }
+        r = digitsPerArray.value - 1;
+      }
+      if (k > 0)
+        out.println();
+    }
+
+    @Override
+    public String toString() {
+      if (isZero())
+        return "0";
+
+      final StringBuilder b = new StringBuilder(positive ? "+" : "-");
+      int j = digits.size() - 1;
+      int i = (nDigit - 1) & digitsPerArray.mask;
+      for (; j >= 0; j--) {
+        final long[] d = digits.get(j);
+        for (; i >= 0; i--)
+          b.append(String.format("%0" + hexPerDigit + "X ", d[i]));
+        i = digitsPerArray.value - 1;
+      }
+      b.append("(").append(nDigit).append(
+          nDigit <= 1 ? " digit, " : " digits, ");
+      final int bits = numberOfBits();
+      b.append(bits).append(bits <= 1 ? " bit)" : " bits)");
+      return b.toString();
+    }
+
+    private void trim(final int startdigit) {
+      if (startdigit < nDigit) {
+        final int startarray = startdigit >> digitsPerArray.exponent;
+        for(int i = digits.size() - 1; i > startarray; i--)
+          digits.remove(i);
+
+        final long[] a = digits.get(startarray);
+        Arrays.fill(a, startdigit & digitsPerArray.mask, a.length, 0L);
+        nDigit = startdigit;
+      }
+    }
+  }
+
+  void print(final Digit e, final int fromBit, final int length,
+      final int digitsPerLine, final PrintStream out) {
+    if ((fromBit & bitsPerDigit.mask) != 0) {
+      throw new IllegalArgumentException(
+          "(fromBit & bitsPerDigit.mask) != 0, fromBit=" + fromBit
+          + ", bitsPerDigit=" + bitsPerDigit);
+    }
+    out.println("fromBit = " + fromBit + ", length = " + length);
+    final int d = e.nDigit - (fromBit >> bitsPerDigit.exponent);
+    e.print(d - (length >> bitsPerDigit.exponent), d, digitsPerLine, out);
+  }
+
+  public static void main(String[] args) throws IOException {
+    final Search Z = new Search(32, 1024);
+    Print.println(Z);
+    final Digit e = Z.new Digit();
+    
+    e.overwrite(0, "800,000k-200,001k_hex.txt");
+    Print.println("e.nDigit = " + e.nDigit);
+
+    final int b = (200*1000*1000) >> 5;
+    final int d = (800*1000*1000) >> 5;
+    e.overwrite(b, "0-800,001k_hex.txt");
+    Print.println("e.nDigit = " + e.nDigit);
+    e.print(0, 100, 10, System.out);
+    e.print(e.nDigit - 50, e.nDigit, 10, System.out);
+    e.print(e.nDigit - d - 50, e.nDigit - d, 10, System.out);
+    e.print(e.nDigit - d, e.nDigit - d + 50, 10, System.out);
+    Z.print(e, 100000, 1024, 10, System.out);
+
+    //Printer.println("return " + e.search("012"));
+    
+    //243F6A88 85A308D3 13198A2E
+    Print.println("return " + e.search(new long[]{0x243F6A8885A308D3L}, 64));
+    Print.println("return " + e.search(new long[]{0x85A308D3}, 32));
+    Print.println("return " + e.search(new long[]{0xA308D313}, 32));
+
+    //1100 1000 0101 0000 1111 0111 1 
+    Print.println("return " + e.search(new long[]{0xC850F780}, 25));
+
+    Print.println("return " + e.search("yahoo"));
+    Print.println("return " + e.search("Yahoo"));
+    Print.println("return " + e.search("Yahoo!"));
+    Print.println("return " + e.search("Y!"));
+    Print.println("return " + e.search("YHOO"));
+
+    Print.println("return " + e.search("HDFS"));
+    Print.println("return " + e.search("hdfs"));
+
+    Print.println("return " + e.search("MAPREDUCE"));
+    Print.println("return " + e.search("MapReduce"));
+    Print.println("return " + e.search("mapreduce"));
+    Print.println("return " + e.search("mapred"));
+
+    Print.println("return " + e.search("hadoop"));
+    Print.println("return " + e.search("Hadoop"));
+    Print.println("return " + e.search("HADOOP"));
+
+    Print.println("return " + e.search("DistCp"));
+    Print.println("return " + e.search("distcp"));
+  }
+}
Index: src/examples/org/apache/hadoop/mp/pi/digit/Util.java
===================================================================
--- src/examples/org/apache/hadoop/mp/pi/digit/Util.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/pi/digit/Util.java	(revision 0)
@@ -0,0 +1,172 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.pi.digit;
+
+import java.math.BigInteger;
+import java.util.Random;
+
+public class Util {
+  public static final Random ran = new Random();
+
+  static String toString(int[] x) {
+    if (x == null) {
+      return "null";
+    } else if (x.length == 0) {
+      return "<empty>";
+    } else {
+      final StringBuilder b = new StringBuilder("[");
+      b.append(x[0]);
+      for(int i = 1; i < x.length; i++) {
+        b.append(", ").append(x[i]);
+      }
+      return b.append("]").toString();
+    }
+  }
+
+  static String toString(int[] x, int length, int M) {
+    final int hexPerDigit = (M+3) >> 2;
+    final StringBuilder b = new StringBuilder();
+    for(int i = length - 1; i >= 0; i--) {
+      b.append(String.format(" %0" + hexPerDigit + "X", x[i]));
+    }
+    return b.toString();
+  }
+
+  static long toLong(int[] x, int length, int M) {
+    long a = 0;
+    for(int i = 0; i < length; i++) {
+      a |= ((long)x[i] << (M*i));
+    }
+    return a;
+  }
+
+  static BigInteger toBigInteger(int[] x, int bitsPerDigit) {
+    final int digitsPerLong = (59/bitsPerDigit) + 1;
+    BigInteger c = BigInteger.ZERO;
+    for(int i = 0; i < x.length; ) {
+      long a = 0;
+      for(int j = 0; i < x.length && j < digitsPerLong; j++) {
+        a |= ((long)x[i] << (bitsPerDigit*j));
+        i++;
+      }
+      c = c.add(BigInteger.valueOf(a).shiftLeft(bitsPerDigit*digitsPerLong*((i - 1)/digitsPerLong)));
+    }
+    return c;
+  }
+
+  static String toHexString(int[] x, int bitsPerDigit) {
+    final int digitsPerLong = (59/bitsPerDigit) + 1;
+    final StringBuilder b = new StringBuilder();
+    for(int i = 0; i < x.length; ) {
+      long a = 0;
+      int j = 0;
+      for(; i < x.length && j < digitsPerLong; j++) {
+        a |= ((long)x[i] << (bitsPerDigit*j));
+        i++;
+      }
+      b.insert(0, String.format((i == x.length? "%": "%0" + ((bitsPerDigit*j + 3) >> 2)) + "X ", a));
+    }
+    return b.toString();
+  }
+
+  static String toHexString(byte[] bytes, final int digitsPerGroup,
+      final String groupSeparator) {
+    if (digitsPerGroup <= 0 || (digitsPerGroup & 1) != 0) {
+      throw new IllegalArgumentException(
+          "digitsPerGroup <= 0 || (digitsPerGroup & 1) != 0, digitsPerGroup="
+          + digitsPerGroup);
+    }
+    final StringBuilder b = new StringBuilder();
+    int r = 0;
+    for(int i = bytes.length - 1; i >= 0; i--) {
+      b.append(String.format("%2X", bytes[i]));
+      if ((r += 2) == digitsPerGroup && i >= 0) {
+        r = 0;
+        b.append(groupSeparator);
+      }
+    }
+    return b.toString();
+  }
+
+  static final String[] BIT_STRINGS = new String[16];
+  static {
+    for(int i = 0; i < BIT_STRINGS.length; i++)
+      BIT_STRINGS[i] = ((i & 8) == 0? "0": "1")
+              + ((i & 4) == 0? "0": "1")
+              + ((i & 2) == 0? "0": "1")
+              + ((i & 1) == 0? "0": "1");
+  }
+  static String toBitString(byte[] bytes, final int digitsPerGroup,
+      final String groupSeparator) {
+    if (digitsPerGroup <= 0 || (digitsPerGroup & 7) != 0) {
+      throw new IllegalArgumentException(
+          "digitsPerGroup <= 0 || (digitsPerGroup & 1) != 0, digitsPerGroup="
+          + digitsPerGroup);
+    }
+    final StringBuilder b = new StringBuilder();
+    int r = 0;
+    for(int i = bytes.length - 1; i >= 0; i--) {
+      b.append(BIT_STRINGS[bytes[i] >>> 4]) 
+       .append(BIT_STRINGS[bytes[i] & 0xF]);
+      if ((r += 8) == digitsPerGroup && i >= 0) {
+        r = 0;
+        b.append(groupSeparator);
+      }
+    }
+    return b.toString();
+  }
+  static String toBitString(long[] integers, final int digitsPerGroup,
+      final String groupSeparator) {
+    if (digitsPerGroup <= 0 || (digitsPerGroup & 3) != 0) {
+      throw new IllegalArgumentException(
+          "digitsPerGroup <= 0 || (digitsPerGroup & 1) != 0, digitsPerGroup="
+          + digitsPerGroup);
+    }
+    final StringBuilder b = new StringBuilder();
+    int r = 0;
+    for(int i = integers.length - 1; i >= 0; i--) {
+      for(int j = 28; j >= 0; j -= 4) {
+        b.append(BIT_STRINGS[(int)(integers[i] >>> j) & 0xF]);
+        if ((r += 4) == digitsPerGroup && i >= 0) {
+          r = 0;
+          b.append(groupSeparator);
+        }
+      }
+    }
+    return b.toString();
+  }
+
+  static byte[] reverse(byte[] bytes) {
+    for(int i = 0, j = bytes.length - 1; i < j; i++, j--) {
+      final byte tmp = bytes[i];
+      bytes[i] = bytes[j];
+      bytes[j] = tmp;
+    }
+    return bytes;
+  }
+  
+  static long[] byte2long(byte[] bytes) {
+    final long[] a = new long[((bytes.length - 1) >> 2) + 1];
+    int j = a.length - 1;
+    for(int i = bytes.length - 1; i >= 0; j--) {
+      for(int k = 7; i >= 0 && k >= 0; i--, k--)
+        a[j] |= ((int)bytes[i]) << (k << 3);
+    }
+    return a;
+  }
+}
Index: src/examples/org/apache/hadoop/mp/pi/TaskResult.java
===================================================================
--- src/examples/org/apache/hadoop/mp/pi/TaskResult.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/pi/TaskResult.java	(revision 0)
@@ -0,0 +1,191 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.pi;
+
+import java.io.BufferedReader;
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.Date;
+
+import org.apache.hadoop.mp.pi.math.Mod1Fraction;
+import org.apache.hadoop.mp.pi.math.Summation;
+import org.apache.hadoop.mp.util.Container;
+import org.apache.hadoop.mp.util.MachineComputable;
+import org.apache.hadoop.mp.util.Parse;
+import org.apache.hadoop.mp.util.Print;
+import org.apache.hadoop.mp.util.serialization.DataSerializable;
+import org.apache.hadoop.mp.util.serialization.StringSerializable;
+
+/** A class for map task results or reduce task results. */
+public class TaskResult implements Container<Summation>, MachineComputable.Result<TaskResult> {
+  private Summation sigma;
+  private Mod1Fraction value;
+  private long duration;
+
+  public TaskResult() {}
+
+  public TaskResult(Summation sigma, Mod1Fraction value, long duration) {
+    this.sigma = sigma;
+    this.value = value;
+    this.duration = duration;      
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public Summation get() {return sigma;}
+
+  public Mod1Fraction getValue() {return value;}
+
+  /** @return The time duration used */
+  long getDuration() {return duration;}
+
+  /** {@inheritDoc} */
+  @Override
+  public int compareTo(TaskResult that) {
+    return this.sigma.compareTo(that.sigma);
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj)
+      return true;
+    else if (obj != null && obj instanceof TaskResult) {
+      final TaskResult that = (TaskResult)obj;
+      return this.compareTo(that) == 0;
+    }
+    throw new IllegalArgumentException(obj == null? "obj == null":
+      "obj.getClass()=" + obj.getClass());
+  }
+
+  /** Not supported */
+  @Override
+  public int hashCode() {
+    throw new UnsupportedOperationException();
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public TaskResult combine(TaskResult that) {
+    try {
+      final Summation s = this.sigma.combine(that.sigma);
+      if (s == null)
+        return null;
+
+      this.sigma = s;
+      this.value.addMod1Equal(that.value);
+      this.duration += that.duration;
+      return this;
+    }
+    catch(RuntimeException e) {
+      Print.println("Got " + e + "!!!"
+          + ",\n  this=" + this
+          + ",\n  that=" + that);
+      throw e;
+    }
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public void readFields(DataInput in) throws IOException {
+    sigma = SummationWritable.IO_VALUE_OF.valueOf(in).get();
+    value = Mod1Fraction.valueOf(in);
+    duration = in.readLong();
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public void write(DataOutput out) throws IOException {
+    SummationWritable.write(sigma, out);
+    value.serialize(out);
+    out.writeLong(duration);
+  }
+  
+  /** {@inheritDoc} */
+  @Override
+  public String toString() {
+    return "duration=" + duration + "(" + Parse.millis2String(duration)
+        + "), sigma=" + sigma + ", value=" + value;
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  public static final Factory FACTORY = new Factory();
+
+  public static final class Factory
+      implements DataSerializable.ValueOf<TaskResult>, StringSerializable.ValueOf<TaskResult> {
+    private Factory() {}
+
+    @Override
+    public TaskResult valueOf(DataInput in) throws IOException {
+      final TaskResult  r = new TaskResult();
+      r.readFields(in);
+      return r;
+    }
+
+    @Override
+    public TaskResult valueOf(final String s) {
+      int i = -1, j = -1;
+      try {
+        i = 0;
+        j = s.indexOf('(');
+        final long duration = Parse.parseLongVariable("duration", s.substring(i, j));
+  
+        i = s.indexOf("sigma=", j+1);
+        j = s.indexOf(", value=", i+1);
+        final Summation sigma = Summation.valueOf(Parse.parseStringVariable("sigma", s.substring(i, j)));
+    
+        i = j + 2;
+        final Mod1Fraction value = Mod1Fraction.FACTORY.valueOf(Parse.parseStringVariable("value", s.substring(i)));
+        return new TaskResult(sigma, value, duration);
+      } catch(RuntimeException e) {
+        throw new RuntimeException("i=" + i + ", j=" + j + ", s=" + s, e);
+      }
+    }
+  }
+
+  static void parse(final BufferedReader in, final DistSum distsum
+      ) throws IOException {
+    for(String line; (line = in.readLine()) != null; ) {
+      if (line.startsWith(DistSum.class.getSimpleName())) {
+        final int i = line.indexOf("duration=");
+        final TaskResult r = FACTORY.valueOf(line.substring(i));
+        distsum.add(r);
+      }
+    }
+  }
+  
+  public static void main(String[] args) throws IOException {
+    final String filename = args[0];
+    Print.print("args", args);
+
+    Mod1Fraction.setPrecision(1024);
+
+    final DistSum distsum = new DistSum();
+    final BufferedReader in = new BufferedReader(new FileReader(filename));
+    try {
+      parse(in, distsum);
+    } finally {
+      in.close();
+    }
+
+    Print.println("\nCPU time = " + distsum.getDurationString());
+    Print.println("END " + new Date(System.currentTimeMillis()));
+    distsum.value.print(Print.out);
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/pi/SummationWritable.java
===================================================================
--- src/examples/org/apache/hadoop/mp/pi/SummationWritable.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/pi/SummationWritable.java	(revision 0)
@@ -0,0 +1,153 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.pi;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.mp.pi.math.ArithmeticProgression;
+import org.apache.hadoop.mp.pi.math.Summation;
+import org.apache.hadoop.mp.util.Container;
+import org.apache.hadoop.mp.util.MachineComputable;
+import org.apache.hadoop.mp.util.JavaUtil.Timer;
+import org.apache.hadoop.mp.util.serialization.ConfSerializable;
+import org.apache.hadoop.mp.util.serialization.DataSerializable;
+
+/** A Writable class for Summation */
+public final class SummationWritable
+    implements Container<Summation>, MachineComputable<SummationWritable, TaskResult> {
+
+  private Summation sigma;
+
+  public SummationWritable() {}
+  SummationWritable(Summation sigma) {this.sigma = sigma;}
+
+  /** {@inheritDoc} */
+  @Override
+  public String toString() {return "" + sigma;}
+
+  /** {@inheritDoc} */
+  @Override
+  public Summation get() {return sigma;}
+
+  /** {@inheritDoc} */
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj)
+      return true;
+    else if (obj != null && obj instanceof SummationWritable) {
+      final SummationWritable that = (SummationWritable)obj;
+      return this.sigma.equals(that.sigma);
+    }
+    throw new IllegalArgumentException(obj == null? "obj == null":
+      "obj.getClass()=" + obj.getClass());
+  }
+
+  /** Not supported */
+  @Override
+  public int hashCode() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public TaskResult compute(int nThreads, Timer timer) {
+    return sigma.compute(nThreads, timer);
+  }
+
+  @Override
+  public List<SummationWritable> partition(int nParts) {
+    final List<SummationWritable> writables = new ArrayList<SummationWritable>();
+    for(Summation s : sigma.partition(nParts))
+      writables.add(new SummationWritable(s));
+    return writables;
+  }
+
+  //----------------------------------------------------------------------------
+  /** A writable class for ArithmeticProgression */
+  private static class ArithmeticProgressionWritable {
+    /** Read ArithmeticProgression from DataInput */
+    private static ArithmeticProgression read(DataInput in) throws IOException {
+      return new ArithmeticProgression(in.readChar(),
+          in.readLong(), in.readLong(), in.readLong());
+    }
+
+    /** Write ArithmeticProgression to DataOutput */
+    private static void write(ArithmeticProgression ap, DataOutput out
+        ) throws IOException {
+      out.writeChar(ap.symbol);
+      out.writeLong(ap.value);
+      out.writeLong(ap.delta);
+      out.writeLong(ap.limit);
+    }
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public void readFields(DataInput in) throws IOException {
+    final boolean ispositive = in.readBoolean();
+    final ArithmeticProgression N = ArithmeticProgressionWritable.read(in);
+    final ArithmeticProgression E = ArithmeticProgressionWritable.read(in);
+    sigma = new Summation(ispositive, N, E); 
+  }
+
+  public static final DataSerializable.ValueOf<SummationWritable> IO_VALUE_OF
+      = new DataSerializable.ValueOf<SummationWritable>() {
+    @Override
+    public SummationWritable valueOf(DataInput in) throws IOException {
+      final SummationWritable s = new SummationWritable();
+      s.readFields(in);
+      return s;
+    }
+  };
+
+  /** Write sigma to DataOutput */
+  public static void write(Summation sigma, DataOutput out) throws IOException {
+    out.writeBoolean(sigma.ispositive);
+    ArithmeticProgressionWritable.write(sigma.N, out);
+    ArithmeticProgressionWritable.write(sigma.E, out);
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public void write(DataOutput out) throws IOException {
+    write(sigma, out);
+  }
+  //----------------------------------------------------------------------------
+  private static final String CONF_PROPERTY_NAME = SummationWritable.class.getName() + ".conf";
+  public static final ConfSerializable.ValueOf<SummationWritable> CONF_VALUE_OF
+      = new ConfSerializable.ValueOf<SummationWritable>() {
+    @Override
+    public SummationWritable valueOf(Configuration conf) {
+      return new SummationWritable(Summation.valueOf(conf.get(CONF_PROPERTY_NAME))); 
+    }
+  };
+
+  @Override
+  public void serialize(Configuration conf) {
+    conf.set(CONF_PROPERTY_NAME, toString());
+  }
+
+  /** Read from conf */
+  public static SummationWritable read(Configuration conf) {
+    return CONF_VALUE_OF.valueOf(conf);
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/pi/DistBbp.java
===================================================================
--- src/examples/org/apache/hadoop/mp/pi/DistBbp.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/pi/DistBbp.java	(revision 0)
@@ -0,0 +1,193 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.pi;
+
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.hadoop.conf.Configured;
+import org.apache.hadoop.fs.FileStatus;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.mp.pi.math.Bellard;
+import org.apache.hadoop.mp.pi.math.Mod1Fraction;
+import org.apache.hadoop.mp.pi.math.Summation;
+import org.apache.hadoop.mp.util.HadoopUtil;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Parse;
+import org.apache.hadoop.mp.util.Print;
+import org.apache.hadoop.util.Tool;
+import org.apache.hadoop.util.ToolRunner;
+
+/**
+ * A map/reduce program that uses a BBP-type method to compute exact 
+ * binary digits of Pi.
+ * This program is designed for computing the n th bit of Pi,
+ * for large n, say n >= 10^8.
+ * For computing lower bits of Pi, consider using bbp.
+ *
+ * The actually computation is done by DistSum jobs.
+ * The steps for launching the jobs are:
+ * 
+ * (1) Initialize parameters.
+ * (2) Create a list of sums.
+ * (3) Read computed values from the given local directory.
+ * (4) Remove the computed values from the sums.
+ * (5) Partition the remaining sums into computation jobs.
+ * (6) Submit the computation jobs to a cluster and then wait for the results.
+ * (7) Write job outputs to the given local directory.
+ * (8) Combine the job outputs and print the Pi bits.
+ */
+public final class DistBbp extends Configured implements Tool {
+  public static final String VERSION = "20100731";
+  private static final String NAME = DistBbp.class.getSimpleName();
+  public static final String DESCRIPTION
+      = "A map/reduce program that uses a BBP-type formula to compute exact bits of Pi.";
+
+  private static final String PROCESS_EXISTING_JOB_OUTPUTS = NAME + ".processExistingJobOutputs";
+  private static final String BELLARD = NAME + ".bellard";
+
+  static final AtomicBoolean printversions = new AtomicBoolean(false);  
+  public static void printVersions() {
+    if (!printversions.getAndSet(true)) {
+      Print.println(NAME + ".VERSION = " + VERSION);
+      Print.printSystemInfo();
+    }
+  }
+
+  static final String[] ADDITIONAL_PARAMETER = {
+    "<b>         The number of bits to skip, i.e. compute the (b+1)th position."
+  };
+
+  /** {@inheritDoc} */
+  public int run(String[] args) throws Exception {
+
+    //parse arguments
+    if (args.length != DistSum.Parameters.COUNT + ADDITIONAL_PARAMETER.length)
+      return HadoopUtil.printUsage(args, getClass().getName()
+          + Parse.description2brief(ADDITIONAL_PARAMETER, DistSum.Parameters.DESCRIPTIONS)
+          + Parse.description(ADDITIONAL_PARAMETER, DistSum.Parameters.DESCRIPTIONS),
+          new IllegalArgumentException("args.length != Parameters.COUNT (="
+              + DistSum.Parameters.COUNT + ") + ADDITIONAL_PARAMETER.length (="
+              + ADDITIONAL_PARAMETER.length + ")"));
+
+    int i = 0;
+    final long b = Parse.string2long(args[i++]);
+    final DistSum.Parameters parameters = DistSum.Parameters.parse(args, i);
+    if (b < 0)
+      throw new IllegalArgumentException("b = " + b + " < 0");
+
+    //init log file
+    final String filename = "b" + b + "-p" + parameters.precision;
+    Print.initLogFile(filename);
+
+    //print version, parameters
+    final DistSum distsum = new DistSum();
+    printVersions();
+    distsum.setConf(getConf());
+    distsum.setParameters(parameters);
+    printBitSkipped(b);
+    Print.println(parameters);
+    Print.println();
+
+    //read existing
+    final FileSystem fs = FileSystem.get(getConf());
+    final Path remotedir = fs.makeQualified(new Path(parameters.remoteDir));
+    final Path tmpdir = fs.makeQualified(new Path(parameters.tmpDir));
+    final boolean pejo = getConf().getBoolean(PROCESS_EXISTING_JOB_OUTPUTS, true);
+    Print.println("\n" + PROCESS_EXISTING_JOB_OUTPUTS + " = " + pejo);
+    if (pejo) {
+      distsum.processExistingJobOutputs(remotedir, fs);
+      distsum.processExistingJobOutputs(tmpdir, fs);
+      distsum.workgroup.waitUntilZero();
+    }
+    
+    final FileStatus[] statuses = fs.listStatus(remotedir);
+    final Map<Bellard.Parameter, Bellard.Sum> sums = new TreeMap<Bellard.Parameter, Bellard.Sum>();
+    Print.println("\nRead existing results from " + remotedir + " ...");
+    final String bellard = getConf().get(BELLARD);
+    Print.println(BELLARD + " = " + bellard);
+    for(Bellard.Parameter p : Bellard.parse(bellard)) {
+      final List<TaskResult> existings = HadoopUtil.readExistingResults(p,
+          Bellard.FACTORY, TaskResult.FACTORY, statuses, fs);
+      for(TaskResult r : existings) {
+        distsum.add(r);
+      }
+
+      //initialize sums
+      final Bellard.Sum s = Bellard.getSum(b, p, parameters.nJobs, existings);
+      if (s != null) {
+        sums.put(p, s);
+      } else if (existings.size() == 1) {
+        HadoopUtil.rewriteCompletedResult(p, existings.get(0),
+            Bellard.FACTORY, statuses, remotedir, fs);
+      }
+    }
+    
+    //execute the computations
+    execute(distsum, sums);
+
+    //compute Pi from the sums 
+    final Mod1Fraction pi = distsum.value;
+    final Path pifile = new Path(remotedir, filename);
+    HadoopUtil.write(pi, pifile, fs);
+
+    printBitSkipped(b);
+    pi.print(Print.log);
+    Print.println("\nCPU time = " + distsum.getDurationString());
+    Print.println("END " + new Date(System.currentTimeMillis()));
+    Print.closeFileOutput();
+    pi.print(Print.out);
+    return 0;
+  }
+
+  /** Execute computations */
+  private static void execute(DistSum distsum,
+      final Map<Bellard.Parameter, Bellard.Sum> sums) throws Exception {
+    final List<DistSum.Computation> computations = new ArrayList<DistSum.Computation>();
+    int i = 0;
+    for(Map.Entry<Bellard.Parameter, Bellard.Sum> e : sums.entrySet()) {
+      final String name = e.getKey().toString();
+      for(Summation s : e.getValue())
+        computations.add(distsum.new Computation(i++, name, s));
+    }
+
+    if (computations.isEmpty())
+      Print.println("No computation");
+    else {
+      JavaUtil.execute(distsum.getParameters().nWorkers, computations, distsum.timer);
+      distsum.workgroup.waitUntilZero();
+    }
+  }
+
+  /** Print a "bits skipped" message. */
+  static void printBitSkipped(final long b) {
+    Print.println();
+    Print.println("b = " + Parse.long2string(b)
+        + " (" + (b < 2? "bit": "bits") + " skipped)");
+  }
+
+  /** main */
+  public static void main(String[] args) throws Exception {
+    System.exit(ToolRunner.run(null, new DistBbp(), args));
+  }
+}
Index: src/examples/org/apache/hadoop/mp/pi/DistSum.java
===================================================================
--- src/examples/org/apache/hadoop/mp/pi/DistSum.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/pi/DistSum.java	(revision 0)
@@ -0,0 +1,648 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.pi;
+
+import java.io.DataInput;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.Callable;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.conf.Configured;
+import org.apache.hadoop.fs.FileStatus;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.mapreduce.InputSplit;
+import org.apache.hadoop.mapreduce.Job;
+import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
+import org.apache.hadoop.mp.pi.math.Mod1Fraction;
+import org.apache.hadoop.mp.pi.math.Summation;
+import org.apache.hadoop.mp.util.HadoopUtil;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Machine;
+import org.apache.hadoop.mp.util.Parse;
+import org.apache.hadoop.mp.util.Print;
+import org.apache.hadoop.mp.util.serialization.ConfSerializable;
+import org.apache.hadoop.util.Tool;
+import org.apache.hadoop.util.ToolRunner;
+
+/**
+ * The main class for computing sums using map/reduce jobs.
+ * A sum is partitioned into jobs.
+ * A job may be executed on the map-side or on the reduce-side.
+ * A map-side job has multiple maps and zero reducer.
+ * A reduce-side job has one map and multiple reducers.
+ * Depending on the clusters status in runtime,
+ * a mix-type job may be executed on either side.
+ */
+public final class DistSum extends Configured implements Tool {
+  private static final String NAME = DistSum.class.getSimpleName();
+  private static final String JOB_SEPARATION = NAME + ".job.separation.seconds";
+  private static final String PRECISION = NAME + ".precision";
+
+  final Mod1Fraction value = Mod1Fraction.zero();
+  private long duration = 0;
+
+  String getDurationString() {
+    return duration + "ms = " + Parse.millis2String(duration);
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  /** DistSum job parameters */
+  static final class Parameters {
+    static final String[] DESCRIPTIONS = {
+        "<precision> The precision.",
+        "<nWorkers>  The number of workers.",
+        "<nJobs>     The number of jobs per sum.",
+        "<machine>   Machine specification"
+        + "\n    " + MapSide.class.getSimpleName() + "    : m100t3"
+        + "\n    " + ReduceSide.class.getSimpleName() + " : r50t2"
+        + "\n    " + Mix.class.getSimpleName() + "        : x-m200t1-r100t2-5"
+        + "\n    " + Alternation.class.getSimpleName() + ": a-m200t1-r100t2-mrr"
+        + "\n    " + Machine.Null.class.getSimpleName() + "       : n"
+        ,
+        "<remoteDir> Remote directory for storing results.",
+        "<tmpDir>    Tmp directory for submitting jobs.",
+    };
+    static final int COUNT = DESCRIPTIONS.length;
+
+    static String getDescription() {
+      final StringBuilder description = new StringBuilder();
+      for(String s: DESCRIPTIONS)
+        description.append("\n  ").append(s);
+      return "" + description;      
+    }
+
+    /** The precision */
+    final long precision;
+    /** Number of workers */
+    final int nWorkers;
+    /** Number of jobs */
+    final int nJobs;
+    /** The machine used in the computation */
+    final Machine machine;
+    /** The machine specification */
+    final String specification;
+    /** The remote job directory */
+    final String remoteDir;
+    /** The remote job directory */
+    final String tmpDir;
+  
+    private Parameters(long precision, int nWorkers, int nJobs,
+        Machine machine, String specification, String remoteDir, String tmpDir) {
+      this.precision = precision;
+
+      this.nWorkers = nWorkers;
+      this.nJobs = nJobs;
+      this.machine = machine;
+      this.specification = specification;
+      this.remoteDir = remoteDir;
+      this.tmpDir = tmpDir;
+    }
+
+    /** {@inheritDoc} */
+    public String toString() {
+      return "\nprecision = " + Parse.long2string(precision)
+           + "\nnWorkers  = " + nWorkers
+           + "\nnJobs     = " + nJobs
+           + "\nmachine   = " + machine + ", " + specification
+           + "\nremoteDir = " + remoteDir
+           + "\ntmpDir    = " + tmpDir;
+    }
+
+    /** Parse parameters */
+    static Parameters parse(String[] args, int i) {
+      if (args.length - i < COUNT)
+        throw new IllegalArgumentException("args.length - i < COUNT = "
+            + COUNT + ", args.length="
+            + args.length + ", i=" + i + ", args=" + Arrays.asList(args));
+      
+      final long precision = Parse.string2long(args[i++]);
+      final int nWorkers = Integer.parseInt(args[i++]);
+      final int nJobs = Integer.parseInt(args[i++]);
+      final String specification = args[i++];
+      final String remoteDir = args[i++];
+      final String tmpDir = args[i++];
+
+      if (precision < 64) {
+        throw new IllegalArgumentException("precision = " + precision + " < 64");
+      } else if (nWorkers <= 0) {
+        throw new IllegalArgumentException("nWorkers = " + nWorkers + " <= 0");
+      } else if (nJobs <= 0) {
+        throw new IllegalArgumentException("nJobs = " + nJobs + " <= 0");
+      }
+      
+      final Machine m = parseMachine(specification);
+      Mod1Fraction.setPrecision(precision);
+      return new Parameters(precision, nWorkers, nJobs, m, specification,
+          remoteDir, tmpDir);
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  /** Compute sigma */
+  static void setPrecision(Configuration conf) {
+    final long precision = conf.getLong(PRECISION, 1000);
+    Mod1Fraction.setPrecision(precision);
+  }
+
+  /** Split for the summations */
+  public static final class SummationSplit extends Machine.SplitBase<SummationWritable> {
+    public SummationSplit() {}
+    private SummationSplit(SummationWritable sigma) {super(sigma);}
+
+    @Override
+    public SummationWritable valueOf(DataInput in) throws IOException {
+      return SummationWritable.IO_VALUE_OF.valueOf(in);
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  /**
+   * A machine which does computation on the map side.
+   */
+  public static final class MapSide extends Machine.MapSideBase<SummationWritable, TaskResult> {
+    static MapSide parse(String specification) {
+      //e.g. m100t3
+      if (specification.charAt(0) != 'm') {
+        return null;
+      } else {
+        final int i = specification.indexOf('t');
+        try {
+          final int nParts = Integer.parseInt(specification.substring(1, i));
+          final int nThreads = Integer.parseInt(specification.substring(i + 1));
+          return new MapSide(nParts, nThreads);
+        } catch(RuntimeException e) {
+          throw new RuntimeException(
+              "specification=" + specification + ", i=" + i, e);
+        }
+      }
+    }
+
+    MapSide(final int nParts, final int nThreads) {
+      super(nParts, nThreads);
+    }
+
+    @Override
+    protected Class<? extends MapperBase<SummationWritable, TaskResult>> getMapperClass() {
+      return SummingMapper.class;
+    }
+
+    @Override
+    protected Class<TaskResult> getResultClass() {
+      return TaskResult.class;
+    }
+
+    @Override
+    protected Class<? extends PartitionInputFormatBase<SummationWritable, ?>> getPartitionInputFormatClass() {
+      return PartitionInputFormat.class;
+    }
+
+    /** An InputFormat which partitions a summation */
+    public static final class PartitionInputFormat extends PartitionInputFormatBase<SummationWritable, SummationSplit> {
+      @Override
+      protected ConfSerializable.ValueOf<SummationWritable> getConfValueOf() {
+        return SummationWritable.CONF_VALUE_OF;
+      }
+
+      @Override
+      public InputSplit valueOf(SummationWritable p) throws RuntimeException {
+        return new SummationSplit(p);
+      }
+    }
+  
+    /** A mapper which computes sums */
+    public static final class SummingMapper extends MapperBase<SummationWritable, TaskResult> {
+      @Override
+      protected void init(final Context context) {
+        DistSum.setPrecision(context.getConfiguration());
+      }
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  /**
+   * A machine which does computation on the reduce side.
+   */
+  public static final class ReduceSide extends Machine.ReduceSideBase<SummationWritable, TaskResult> {
+    static ReduceSide parse(String specification) {
+      //e.g. r100t3
+      if (specification.charAt(0) != 'r') {
+        return null;
+      } else {
+        final int i = specification.indexOf('t');
+        try {
+          final int nParts = Integer.parseInt(specification.substring(1, i));
+          final int nThreads = Integer.parseInt(specification.substring(i + 1));
+          return new ReduceSide(nParts, nThreads);
+        } catch(RuntimeException e) {
+          throw new RuntimeException(
+              "specification=" + specification + ", i=" + i, e);
+        }
+      }
+    }
+
+    ReduceSide(final int nParts, final int nThreads) {
+      super(nParts, nThreads);
+    }
+
+    @Override
+    protected Class<SummationWritable> getComputationClass() {
+      return SummationWritable.class;
+    }
+
+    @Override
+    protected Class<PartitionMapper> getPartitionMapperClass() {
+      return PartitionMapper.class;
+    }
+
+    @Override
+    protected Class<SummingReducer> getReducerClass() {
+      return SummingReducer.class;
+    }
+
+    @Override
+    protected Class<TaskResult> getResultClass() {
+      return TaskResult.class;
+    }
+
+    @Override
+    protected Class<SingletonInputFormat> getSingletonInputFormatClass() {
+      return SingletonInputFormat.class;
+    }
+
+    @Override
+    protected Class<IndexPartitioner> getIndexPartitionerClass() {
+      return IndexPartitioner.class;
+    }
+
+    /** An InputFormat which returns a single summation. */
+    public static final class SingletonInputFormat
+        extends SingletonInputFormatBase<SummationWritable, SummationSplit> {
+      @Override
+      protected ConfSerializable.ValueOf<SummationWritable> getConfValueOf() {
+        return SummationWritable.CONF_VALUE_OF;
+      }
+
+      @Override
+      public InputSplit valueOf(SummationWritable p) throws RuntimeException {
+        return new SummationSplit(p);
+      }
+    }
+
+    public static final class PartitionMapper extends PartitionMapperBase<SummationWritable> {
+    }
+
+    /** Use the index for partitioning. */
+    public static final class IndexPartitioner extends IndexPartitionerBase<SummationWritable> {
+    }
+
+    /** A Reducer which computes sums */
+    public static final class SummingReducer extends ReducerBase<SummationWritable, TaskResult> {
+      @Override
+      protected void init(final Context context) {
+        DistSum.setPrecision(context.getConfiguration());
+      }
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  static Machine parseMachine(String specification) {
+    Machine m = Machine.Null.parse(specification);
+    if (m == null)
+      m = MapSide.parse(specification);
+    if (m == null)
+      m = ReduceSide.parse(specification);
+    if (m == null)
+      m = Mix.parse(specification);
+    if (m == null)
+      m = Alternation.parse(specification);
+    if (m == null)
+      throw new IllegalArgumentException("specification=" + specification);
+    return m;
+  }
+
+  private static class Mix extends Machine.MixBase<SummationWritable, TaskResult> {
+    static Mix parse(String specification) {
+      //e.g. x-m200t1-r100t3-5
+      if (specification.charAt(0) != 'x') {
+        return null;
+      } else {
+        int i = 2;
+        int j = specification.indexOf('-', i+1);
+        try {
+          final MapSide m = MapSide.parse(specification.substring(i, j));
+
+          i = j + 1;
+          j = specification.indexOf('-', i+1);
+          final ReduceSide r = ReduceSide.parse(specification.substring(i, j));
+
+          final int ratio = Integer.parseInt(specification.substring(j+1));
+          return new Mix(m, r, ratio);
+        } catch(RuntimeException e) {
+          throw new RuntimeException(
+              "specification=" + specification + ", i=" + i + ", j=" + j, e);
+        }
+      }
+    }
+
+    final int nCore;
+    final int reservedMap;
+    final int reservedReduce;
+    
+    Mix(MapSide mapside, ReduceSide reduceside, final int ratio) {
+      super(mapside, reduceside);
+      this.nCore = (mapside.getCore() + reduceside.getCore()) >>> 1;
+      this.reservedMap = mapside.nParts * ratio;
+      this.reservedReduce = reduceside.nParts * ratio;
+    }
+
+    @Override
+    public int getCore() {
+      return nCore;
+    }
+
+    @Override
+    protected int availableMap(int remainingMap) {
+      final int d = remainingMap - reservedMap;
+      return d > 0? d: 0;
+    }
+
+    @Override
+    protected int availableReduce(int remainingReduce) {
+      final int d = remainingReduce - reservedReduce;
+      return d > 0? d: 0;
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  private static class Alternation extends Machine.AlternationBase<SummationWritable, TaskResult> {
+    static Alternation parse(String specification) {
+      //e.g. a-m200t1-r100t3-mrr
+      if (specification.charAt(0) != 'a') {
+        return null;
+      } else {
+        int i = specification.indexOf('-') + 1;
+        int j = specification.indexOf('-', i);
+        try {
+          final MapSide m = MapSide.parse(specification.substring(i, j));
+          
+          i = j + 1;
+          j = specification.indexOf('-', i);
+          final ReduceSide r = ReduceSide.parse(specification.substring(i, j));
+
+          return new Alternation(m, r, specification.substring(j+1));
+        } catch(RuntimeException e) {
+          throw new RuntimeException(
+              "specification=" + specification + ", i=" + i + ", j=" + j, e);
+        }
+      }
+    }
+
+    final int nCore;
+    
+    Alternation(MapSide mapside, ReduceSide reduceside, String pattern) {
+      super(mapside, reduceside, pattern);
+      this.nCore = (mapside.getCore() + reduceside.getCore()) >>> 1;
+    }
+
+    @Override
+    public int getCore() {return nCore;}
+    @Override
+    protected int availableMap(int remainingMap) {return remainingMap;}
+    @Override
+    protected int availableReduce(int remainingReduce) {return remainingReduce;}
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  final JavaUtil.Timer timer = new JavaUtil.Timer(true, true);
+  final String starttime = Parse.time2String(timer.getStart());
+
+  final JavaUtil.WorkGroup workgroup = new JavaUtil.WorkGroup(
+      NAME + ".OutputProcessor", 1, timer);
+
+  private Parameters parameters;
+
+  /** Get Parameters */
+  Parameters getParameters() {return parameters;}
+  /** Set Parameters */
+  void setParameters(Parameters p) {parameters = p;}
+
+  /** Create a job */
+  private Job createJob(String name, Summation sigma) throws IOException {
+    final Job job = Machine.createJob(parameters.tmpDir + "/" + name,
+        DistSum.class, new SummationWritable(sigma), getConf());
+    job.getConfiguration().setLong(PRECISION, parameters.precision);
+    return job; 
+  }
+
+  /**
+   * Start a job to compute sigma.
+   * If sigma == null, process existing output.
+   */
+  private void compute(final String name, final Summation sigma
+      ) throws IOException {
+    final long steps = sigma.E.getSteps();
+    if (steps == 0) {
+      timer.tick(sigma + " has zero steps.");
+      return;
+    } else if (parameters.machine instanceof Machine.Null) {
+      timer.tick("name=" + name + ", sigma=" + sigma);
+      return;
+    }
+
+    //setup remote directory
+    final FileSystem fs = FileSystem.get(getConf());
+    final Path dir = fs.makeQualified(new Path(parameters.tmpDir, name));
+    HadoopUtil.createDirectory(fs, dir, true);
+    final Path joboutdir = new Path(dir, "out");
+
+    //setup a job
+    final Job job = createJob(name, sigma);
+    FileOutputFormat.setOutputPath(job, joboutdir);
+
+    //start a map/reduce job
+    final String startmessage = "steps/cores = "
+        + steps + "/" + parameters.machine.getCore()
+        + " = " + Parse.long2string(steps/parameters.machine.getCore());
+    final long sleeptime = 1000L * job.getConfiguration().getInt(JOB_SEPARATION, 10);
+    HadoopUtil.runJob(name, job, parameters.machine, startmessage, sleeptime, timer);
+
+    //submit output for processing
+    submitJobOutput(fs, dir, name, joboutdir, true);
+  }
+
+  void submitJobOutput(final FileSystem fs, final Path dir,
+      final String jobname, final Path joboutdir, final boolean addValue
+      ) throws IOException {
+    workgroup.submit(jobname, new Runnable() {
+      @Override
+      public void run() {
+        //combine and rewrite results
+        final TaskResult combined;
+        try {
+          combined = HadoopUtil.processJobOutputs(fs,
+              parameters.remoteDir, jobname, joboutdir, TaskResult.FACTORY);
+        } catch (IOException e) {
+          throw new RuntimeException(e);
+        }
+        try {
+          fs.delete(dir, true);
+        } catch (IOException e) {
+          Print.printStackTrace(e);
+        }
+
+        if (addValue) {
+          Print.println(taskResult2string(jobname, combined));
+          add(combined);
+        }
+      }
+    });
+  }
+
+  /** Process existing job outputs. */
+  void processExistingJobOutputs(final Path dir, FileSystem fs
+      ) throws IOException {
+    final FileStatus[] statuses = fs.listStatus(dir);
+    if (statuses != null && statuses.length > 0) {
+      Print.println("\nCheck existing job outputs from " + dir + " ...");
+
+      for(FileStatus s : statuses) {
+        if (s.isDir()) {
+          final Path p = s.getPath();
+          final Path joboutdir = new Path(p, "out");
+          if (fs.exists(joboutdir)) {
+            submitJobOutput(fs, p, p.getName(), joboutdir, false);
+          }
+        }
+      }
+    }
+  }
+  
+  void add(TaskResult r) {
+    synchronized(value) {
+      duration += r.getDuration();
+      if (r.get().ispositive)
+        value.addMod1Equal(r.getValue());
+      else
+        value.subtractMod1Equal(r.getValue());
+    }
+  }
+
+  /** Convert a TaskResult to a String */
+  public static String taskResult2string(String name, TaskResult result) {
+    return NAME + " " + name + "> " + result;
+  }
+
+  /** Callable computation */
+  class Computation implements Callable<Computation> {
+    private final int index;
+    private final String name;
+    private final Summation sigma;
+
+    Computation(int index, String name, Summation sigma) {
+      this.index = index;
+      this.name = name;
+      this.sigma = sigma;
+    }
+
+    /** @return The job name */
+    String getJobName() {return String.format("%s.job%04d-" + starttime, name, index);}
+
+    /** {@inheritDoc} */
+    @Override
+    public String toString() {return getJobName() + sigma;}
+
+    /** Start the computation */
+    @Override
+    public Computation call() {
+      for(int i = 3; i > 0; ) {
+        try {
+          compute(getJobName(), sigma);
+          i = 0;
+        } catch(Exception e) {
+          Print.println("ERROR: Got an exception from " + getJobName());
+          Print.printStackTrace(e);
+          if (--i > 0) {
+            Print.println("Retry " + getJobName() + " " + i + " more times.");
+          }
+        }
+      }
+      return this;
+    }
+  }
+
+  /** Partition sigma and execute the computations. */
+  private boolean execute(String name, Summation sigma,  boolean isplus) {
+    final List<Summation> summations = sigma.partition(parameters.nJobs);
+    final List<Computation> computations = new ArrayList<Computation>(); 
+    for(int i = 0; i < summations.size(); i++)
+      computations.add(new Computation(i, name, summations.get(i)));
+    try {
+      JavaUtil.execute(parameters.nWorkers, computations, timer);
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+
+    workgroup.waitUntilZero();
+
+    final List<Summation> combined = JavaUtil.combine(summations);
+    return combined.size() == 1 && combined.get(0).equals(sigma);
+  }
+
+  static final String[] ADDITIONAL_PARAMETER = {
+    "<name>      The name.",
+    "<sigma>     The summation.",
+  };
+
+  /** {@inheritDoc} */
+  @Override
+  public int run(String[] args) throws Exception {
+    //parse arguments
+    if (args.length != Parameters.COUNT + ADDITIONAL_PARAMETER.length)
+      return HadoopUtil.printUsage(args, getClass().getName()
+          + Parse.description2brief(ADDITIONAL_PARAMETER, Parameters.DESCRIPTIONS)
+          + Parse.description(ADDITIONAL_PARAMETER, Parameters.DESCRIPTIONS),
+          new IllegalArgumentException("args.length != Parameters.COUNT (="
+              + Parameters.COUNT + ") + ADDITIONAL_PARAMETER.length (="
+              + ADDITIONAL_PARAMETER.length + ")"));
+
+    int i = 0;
+    final String name = args[i++];
+    final Summation sigma = Summation.valueOf(args[i++]);
+    setParameters(DistSum.Parameters.parse(args, i));
+
+    Print.println();
+    Print.println("name  = " + name);
+    Print.println("sigma = " + sigma);
+    Print.println(parameters);
+    Print.println();
+
+    //run jobs
+    final int r;
+    if (execute(name, sigma, true)) {
+      timer.tick("\n\nDONE\n\nsigma=" + sigma + ", value=" + value);
+      r = 0;
+    } else {
+      timer.tick("\n\nDONE WITH ERROR\n\nsigma=" + sigma);
+      r = 1;
+    }
+    Print.println("cpu time = " + getDurationString());
+    return r;
+  }
+
+  /** main */
+  public static void main(String[] args) throws Exception {
+    System.exit(ToolRunner.run(null, new DistSum(), args));
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/pi/math/LongLong.java
===================================================================
--- src/examples/org/apache/hadoop/mp/pi/math/LongLong.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/pi/math/LongLong.java	(revision 0)
@@ -0,0 +1,103 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.pi.math;
+
+import java.math.BigInteger;
+
+/** Support 124-bit integer arithmetic. */
+public class LongLong {
+  static final int BITS_PER_LONG = 62;
+  static final int MID = BITS_PER_LONG >> 1;
+  static final int SIZE = BITS_PER_LONG << 1;
+
+  static final long FULL_MASK = (1L << BITS_PER_LONG) - 1;
+  static final long MASK = FULL_MASK >>> MID;
+
+  long d0;
+  long d1;
+
+  /** Set the values. */
+  public LongLong set(long d0, long d1) {
+    this.d0 = d0;
+    this.d1 = d1;
+    return this;
+  }
+
+  /** And operation (&).
+  long and(long mask) {
+    return d0 & mask;
+  } */
+
+  /** Shift right operation (<<).
+  long shiftRight(int n) {
+    return (d1 << (BITS_PER_LONG - n)) + (d0 >>> n);
+  }
+   */
+
+  /** Plus equal operation (+=). 
+  LongLong plusEqual(LongLong that) {
+    this.d0 += that.d0;
+    this.d1 += that.d1;
+    return this;
+  }
+  */
+
+  /** Convert this to a BigInteger. */
+  public BigInteger toBigInteger() {
+    return BigInteger.valueOf(d1).shiftLeft(BITS_PER_LONG).add(BigInteger.valueOf(d0));
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public String toString() {
+    final int remainder = BITS_PER_LONG % 4;
+    return String.format("%x*2^%d + %016x", d1<<remainder, BITS_PER_LONG-remainder, d0);
+  }
+
+  /** Compute a*b and store the result to r.
+   * @return r
+   */
+  public static LongLong multiplication(final LongLong r, final long a, final long b) {
+    /*
+    final long x0 = a & LOWER_MASK;
+    final long x1 = (a & UPPER_MASK) >> MID;
+
+    final long y0 = b & LOWER_MASK;
+    final long y1 = (b & UPPER_MASK) >> MID;
+
+    final long t = (x0 + x1)*(y0 + y1);
+    final long u = (x0 - x1)*(y0 - y1);
+    final long v = x1*y1;
+
+    final long tmp = (t - u)>>>1;
+    result.d0 = ((t + u)>>>1) - v + ((tmp << MID) & FULL_MASK);;
+    result.d1 = v + (tmp >> MID);
+    return result;
+    */
+    final long a_lower = a & MASK;
+    final long a_upper = (a >> MID)& MASK;
+
+    final long b_lower = b & MASK;
+    final long b_upper = (b >> MID)& MASK;
+
+    final long tmp = a_lower*b_upper + a_upper*b_lower;
+    r.d0 = a_lower*b_lower + ((tmp << MID) & FULL_MASK);
+    r.d1 = a_upper*b_upper + (tmp >> MID);
+    return r;
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/pi/math/Mod1Fraction_IntArray.java
===================================================================
--- src/examples/org/apache/hadoop/mp/pi/math/Mod1Fraction_IntArray.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/pi/math/Mod1Fraction_IntArray.java	(revision 0)
@@ -0,0 +1,395 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.pi.math;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.io.PrintStream;
+import java.util.Arrays;
+
+import org.apache.hadoop.mp.util.Checksum;
+import org.apache.hadoop.mp.util.Interval;
+import org.apache.hadoop.mp.util.Statistics;
+
+/**
+ * Represent x (mod 1) for real number x.
+ * The class supports arbitrary precision arithmetic
+ * and the fraction is implemented by an int[].
+ */
+public class Mod1Fraction_IntArray extends Mod1Fraction {
+  private static final int VERSION = -1; 
+  private static final Statistics stat = new Statistics(Mod1Fraction_IntArray.class.getSimpleName());
+  public static Statistics getStatistics() {return stat;}
+
+  public static class Factory extends Mod1Fraction.Factory {
+    @Override
+    public String getName() {return Mod1Fraction_IntArray.class.getSimpleName();}
+
+    @Override
+    public Mod1Fraction_IntArray zero() {
+      return new Mod1Fraction_IntArray(1 + (int)((getPrecision() - 1)/BIT_PER_VALUE));
+    }
+
+    @Override
+    public Mod1Fraction valueOf(String s) {
+      try {
+        if (s.charAt(0) != '[' || s.charAt(s.length() - 1) != ']')
+          throw new IllegalArgumentException("s.charAt(0) != '[' || s.charAt(s.length() - 1) != ']'");
+
+        int i = 1;
+        int j = s.indexOf(":");
+        final Mod1Fraction_IntArray n = new Mod1Fraction_IntArray(
+            Integer.parseInt(s.substring(i, j)));
+        
+        for(int k = 0; k < n.values.length; k++) {
+          i = j + 1;
+          j = s.indexOf(" ", i);
+          n.values[k] = (int)Long.parseLong(s.substring(i, j), 16);
+        }
+        return n;
+      } catch(RuntimeException e) {
+        throw new RuntimeException("s = ***" + s + "***", e);
+      }
+    }
+
+    @Override
+    public Mod1Fraction valueOf(DataInput in) throws IOException {
+      final int version = in.readInt();
+      if (version >= 0) {
+        //before version
+        final int length = version;
+        final Mod1Fraction_IntArray n = new Mod1Fraction_IntArray(length);
+        for(int i = in.readInt(); i < n.values.length; i++)
+          n.values[i] = in.readInt();
+        return n;
+      } else if (version != VERSION) {
+        throw new IOException(version + " = version != VERSION = " + VERSION);
+      } else {
+        //current version
+        final Checksum c = Checksum.getChecksum();
+        c.update(version);
+
+        //read length and number of leading zeros
+        final Mod1Fraction_IntArray n = new Mod1Fraction_IntArray(c.update(in.readInt()));
+        final int start = c.update(in.readInt());
+
+        //read remaining values
+        for(int i = start; i < n.values.length; i++)
+          n.values[i] = in.readInt();
+        c.update(n.values, start, n.values.length);
+
+        //read and verify checksum
+        c.readAndVerify(in);
+        return n;
+      }
+    }
+  }
+
+  private static int BIT_PER_VALUE = Integer.SIZE;
+  //---------------------------------------------------------------------------
+  private final int[] values;
+
+  Mod1Fraction_IntArray(final int len) {values = new int[len];}
+  
+  Mod1Fraction_IntArray init(final long numerator, final long denominator, final long shift) {
+    /*
+    if (stat != null)
+      stat.countExecutionPoint("Mod1Fraction_IntArray.init");
+*/
+    Arrays.fill(values, 0);
+
+    final long sq = shift >>> 5;
+    if (sq >= values.length)
+      return this;
+
+    final int sr;
+    final long d;
+    if (denominator == 1) {
+      sr = 0;
+      d = 1L << (shift & 0x1FL);
+    } else {
+      sr = (int)(shift & 0x1FL);
+      d = denominator;
+    }
+
+    if (SMALL_DENOMINATORS.contains(d))
+      return initSmall(numerator, d, (int)sq, sr);
+    else {
+      initLarge(numerator, d, (int)sq, sr);
+      /*
+      JavaUtil.out.println("\ninitLarge(numerator = " + numerator + ", denominator = " + denominator + ", shift = " + shift + ")"); 
+      JavaUtil.out.println("  this     = " + this); 
+      JavaUtil.out.println("  expected = " + initApfloatTL.get().initApfloat(numerator, denominator, shift));
+      */
+      return this;
+    }
+  }
+
+  private static Interval SMALL_DENOMINATORS = new Interval(1L, 1L << 31);
+  private static Interval LARGE_DENOMINATORS = new Interval(SMALL_DENOMINATORS.end, 1L << 62);
+
+  final long[][] quotients = new long[9][16];
+  final long[][] remainers = new long[quotients.length][quotients[0].length];
+
+  /** Bit 61 to 96 */
+  private void initQR(final long d) {
+    long q = (1L << 60)/d;
+    long r = (1L << 60) - q*d;
+
+    for(int i = 0; i < quotients.length; i++) {
+      final long unitQ = q;
+      final long unitR = r;
+      quotients[i][0] = 0;
+      remainers[i][0] = 0;
+
+      for(int j = 1; j < quotients[i].length; j++) {
+        quotients[i][j] = q;
+        remainers[i][j] = r;
+        q += unitQ;
+        r += unitR;
+        if (r >= d) {q++;  r -= d;}
+      }
+    }
+  }
+
+  /** d belongs {@link #LARGE_DENOMINATORS} */
+  Mod1Fraction_IntArray initLarge(long n, final long d, final int beginindex, final int rightshift) {
+    if (beginindex >= values.length)
+      return this;
+/*
+    if (stat != null)
+      stat.countExecutionPoint("Mod1Fraction_IntArray.initLarge");
+*/
+    if (!LARGE_DENOMINATORS.contains(d))
+      throw new IllegalArgumentException("d = " + d + " is not in " + LARGE_DENOMINATORS);
+
+    initQR(d);
+    if (rightshift == 0)
+      for(int i = beginindex; i < values.length && n != 0; i++) {
+        long high = n >>> 24;
+        n <<= 36;
+        n >>>= 4;
+        long q = n/d;
+        long r = n - q*d;
+        for(int j = 0; j < quotients.length; j++) {
+          high >>= 4;
+          final int bits = (int)(high & 0xF);
+          q += quotients[j][bits];
+          r += remainers[j][bits];
+          if (r >= d) {q++;  r -= d;}
+        }
+        n = r;
+
+        values[i] = (int)q;
+      }
+    else {
+      final int leftshift = Integer.SIZE - rightshift;
+      int prev = 0;
+      for(int i = beginindex; i < values.length && n != 0; i++) {
+        long high = n >>> 24;
+        n <<= 36;
+        n >>>= 4;
+        long q = n/d;
+        long r = n - q*d;
+        for(int j = 0; j < quotients.length; j++) {
+          high >>= 4;
+          final int bits = (int)(high & 0xF);
+          q += quotients[j][bits];
+          r += remainers[j][bits];
+          if (r >= d) {q++;  r -= d;}
+        }
+        n = r;
+
+        values[i] = prev;
+        prev = (int)q;
+        values[i] |= prev >>> rightshift;
+        prev <<= leftshift;
+      }
+    }
+    return this;
+  }
+
+  /** d belongs to {@link #SMALL_DENOMINATORS} */
+  Mod1Fraction_IntArray initSmall(long n, final long d, final int beginindex, final int rightshift) {
+    /*
+    if (stat != null)
+      stat.countExecutionPoint("Mod1Fraction_IntArray.initSmall");
+*/
+    if (!SMALL_DENOMINATORS.contains(d))
+      throw new IllegalArgumentException("d = " + d + " is not in " + SMALL_DENOMINATORS);
+
+    if (rightshift == 0)
+      for(int i = beginindex; i < values.length && n != 0; i++) {
+        n <<= 32;
+        final long q = n/d;
+        values[i] = (int)q;
+        n -= q*d;
+      }
+    else {
+      final int leftshift = Integer.SIZE - rightshift;
+      int prev = 0;
+      for(int i = beginindex; i < values.length && n != 0; i++) {
+        n <<= 32;
+        final long q = n/d;
+        n -= q*d;
+
+        values[i] = prev;
+        prev = (int)q;
+        values[i] |= prev >>> rightshift;
+        prev <<= leftshift;
+      }
+    }
+    /*
+    JavaUtil.out.println("\nnumerator = " + numerator + ", denominator = " + denominator + ", shift = " + shift); 
+    JavaUtil.out.println("  this     = " + this); 
+    JavaUtil.out.println("  expected = " + newInstance_Apfloat(len, numerator,  denominator, shift));
+    */ 
+    return this;
+  }
+
+  @Override
+  public Mod1Fraction clone() {
+    final Mod1Fraction_IntArray f = new Mod1Fraction_IntArray(values.length);
+    System.arraycopy(values, 0, f.values, 0, values.length);
+    return f;
+  }
+
+  @Override
+  public Mod1Fraction_IntArray addMod1Equal(Mod1Fraction that) {
+    return addMod1Equal(that, 0);
+  }
+  private Mod1Fraction_IntArray addMod1Equal(Mod1Fraction that, final long beginindex) {
+    if (beginindex >= values.length)
+      return this;
+
+    final int[] a = ((Mod1Fraction_IntArray)that).values;
+    long carry = 0;
+    int i = values.length - 1;
+    for(; i >= (int)beginindex; i--) {
+      carry += values[i] & 0xFFFFFFFFL;
+      carry += a[i] & 0xFFFFFFFFL;
+      values[i] = (int)carry;
+      carry >>= 32;
+    }
+    for(; carry != 0 && i >= 0; i--) {
+      carry += values[i] & 0xFFFFFFFFL;
+      values[i] = (int)carry;
+      carry >>= 32;
+    }
+    return this;
+  }
+
+  @Override
+  public Mod1Fraction_IntArray subtractMod1Equal(Mod1Fraction that) {
+    final int[] a = ((Mod1Fraction_IntArray)that).values;
+    long borrow = 0;
+    for(int i = values.length - 1; i >= 0; i--) {
+      borrow += values[i] & 0xFFFFFFFFL;
+      borrow -= a[i] & 0xFFFFFFFFL;
+      values[i] = (int)borrow;
+      borrow >>= 32;
+    }
+    return this;
+  }
+
+  private final ThreadLocal<Mod1Fraction_IntArray> tmp = new ThreadLocal<Mod1Fraction_IntArray>() {
+    @Override
+    protected Mod1Fraction_IntArray initialValue() {
+      return new Mod1Fraction_IntArray(values.length);
+    }
+  };
+
+  @Override
+  public Mod1Fraction_IntArray addFractionMod1Equal(long numerator, long denominator) {
+    return addMod1Equal(tmp.get().init(numerator, denominator, 0));
+  }
+
+  /**
+   * s += 1/(n 2^e)
+   * s += 1.0 / (n << e);
+   * if (s >= 1) s--;
+   */
+  @Override
+  public Mod1Fraction_IntArray addShiftFractionMod1Equal(long n, long e) {
+    return addMod1Equal(tmp.get().init(1, n, e), e >>> 5);
+  }
+
+  @Override
+  public void printHex(int partsPerLine, PrintStream out) {
+    out.print("[" + values.length + ":");
+    for(int i = 0; i < values.length; i++) {
+      if (partsPerLine > 0 && i % partsPerLine == 0) {
+        out.println();
+        out.print("  ");
+      }
+      out.print(String.format("%08X ", values[i]));
+    }
+    out.println();
+    out.println("]");
+  }
+
+  private final int MAX_STRING_ITEM = 100;
+  @Override
+  public String toHexString(int partsPerLine) {
+    final boolean iscompact = partsPerLine == 0;
+    final StringBuilder b = new StringBuilder(); 
+    b.append("[").append(values.length).append(":");
+
+    int i = 0;
+    if (iscompact) {
+      //skip zeros
+      for(; i < values.length && values[i] == 0; i++);
+      if (i > 0)
+        b.append(" <00000000 x " + i + "> ");
+    }
+
+    final int n = iscompact && MAX_STRING_ITEM+i < values.length?
+        MAX_STRING_ITEM+i: values.length;
+    for(; i < n; i++) {
+      if (partsPerLine > 0 && i % partsPerLine == 0)
+        b.append("\n  ");
+      b.append(String.format("%08X ", values[i]));
+    }
+    if (i < values.length)
+      b.append("... ");
+    return b.append("]").toString();
+  }
+
+  @Override
+  public Void serialize(DataOutput out) throws IOException {
+    //write version and length
+    final Checksum c = Checksum.getChecksum();
+    out.writeInt(c.update(VERSION));
+    out.writeInt(c.update(values.length));
+
+    //write number of leading zeros
+    int i = 0;
+    for(; i < values.length && values[i] == 0; i++);
+    out.writeInt(c.update(i));
+
+    //write remaining values
+    c.update(values, i, values.length);
+    for(; i < values.length; i++)
+      out.writeInt(values[i]);
+    
+    //write checksum
+    c.writeDigest(out);
+    return null;
+  }
+}
Index: src/examples/org/apache/hadoop/mp/pi/math/Montgomery.java
===================================================================
--- src/examples/org/apache/hadoop/mp/pi/math/Montgomery.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/pi/math/Montgomery.java	(revision 0)
@@ -0,0 +1,98 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.pi.math;
+
+/** Montgomery method.
+ * 
+ * References:
+ * 
+ * [1] Richard Crandall and Carl Pomerance.  Prime Numbers: A Computational 
+ *     Perspective.  Springer-Verlag, 2001. 
+ * 
+ * [2] Peter Montgomery.  Modular multiplication without trial division.
+ *     Math. Comp., 44:519-521, 1985.
+ */
+class Montgomery {
+  protected final Product product = new Product();
+
+  protected long N;
+  protected long N_I;  // N'
+  protected long R;
+  protected long R_1;  // R - 1
+  protected int s_right;
+  protected int s_left;
+
+  /** Set the modular and initialize this object. */
+  Montgomery set(long n) {
+    if (n % 2 != 1)
+      throw new IllegalArgumentException("n % 2 != 1, n=" + n);
+    N = n;
+    R = Long.highestOneBit(n) << 1;
+    N_I = R - Modular.modInverse(N, R);
+    R_1 = R - 1;
+    s_right = Long.numberOfTrailingZeros(R);
+    s_left = LongLong.BITS_PER_LONG - s_right;
+    return this;
+  }
+
+  /** Compute 2^y mod N for N odd. */
+  long mod(final long y) {
+    long p = R - N; 
+    long x = p << 1;
+    if (x >= N) x -= N;
+    
+    for(long mask = Long.highestOneBit(y); mask > 0; mask >>>= 1) {
+      p = product.m(p, p);
+      if ((mask & y) != 0) p = product.m(p, x);
+    }
+    return product.m(p, 1);
+  }
+
+  class Product {
+    private final LongLong x = new LongLong();
+    //private final LongLong xN_I = new LongLong();
+    private final LongLong aN = new LongLong();
+
+    long m(final long c, final long d) {
+      LongLong.multiplication(x, c, d);
+      // a = (x * N')&(R - 1) = ((x & R_1) * N') & R_1
+      //LongLong.multiplication(xN_I, x.d0 & R_1, N_I);
+      //final long a = xN_I.d0 & R_1;
+      final long a = (x.d0 * N_I) & R_1;
+      LongLong.multiplication(aN, a, N);
+      
+      aN.d0 += x.d0;
+      aN.d1 += x.d1;
+      final long z = (aN.d1 << s_left) + (aN.d0 >>> s_right);
+      return z < N? z: z - N;      
+    }
+  }
+  
+  public static void main(String[] args) {
+    final Montgomery m = new Montgomery();
+
+    long k = 2;
+    for(int i = 0; i < 60; i++) {
+      final long n = k + 1;
+      final long e = n;
+      final long s = m.set(n).mod(e);
+      System.out.println("e=" + e + ", n=" + n + ", s=" + s);
+      k <<= 1;
+    }
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/pi/math/Modular.java
===================================================================
--- src/examples/org/apache/hadoop/mp/pi/math/Modular.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/pi/math/Modular.java	(revision 0)
@@ -0,0 +1,112 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.pi.math;
+
+/** Modular arithmetics */
+public class Modular {
+  static final long MAX_SQRT_LONG = (long)Math.sqrt(Long.MAX_VALUE);
+
+  /** Compute 2^e mod n */
+  public static long mod(long e, long n) {
+    final int HALF = (63 - Long.numberOfLeadingZeros(n)) >> 1;
+    final int FULL = HALF << 1;
+    final long ONES = (1 << HALF) - 1; 
+
+    long r = 2;
+    for (long mask = Long.highestOneBit(e) >> 1; mask > 0; mask >>= 1) {
+      if (r <= MAX_SQRT_LONG) {
+        r *= r;
+        if (r >= n) r %= n;
+      } else {
+        // r^2 will overflow
+        final long high = r >>> HALF;
+        final long low  = r &= ONES;
+        
+        r *= r;
+        if (r >= n) r %= n;
+
+        if (high != 0) {
+          long s = high * high;
+          if (s >= n) s %= n;
+          for(int i = 0; i < FULL; i++)
+            if ((s <<= 1) >= n) s -= n;
+          
+          if (low == 0)
+            r = s;
+          else {
+            long t = high * low;
+            if (t >= n) t %= n;
+            for(int i = -1; i < HALF; i++)
+              if ((t <<= 1) >= n) t -= n;
+            
+            r += s;
+            if (r >= n) r -= n;
+            r += t;
+            if (r >= n) r -= n;
+          }
+        }
+      }
+
+      if ((e & mask) != 0) {
+        r <<= 1;
+        if (r >= n) r -= n;
+      }
+    }
+    return r;
+  }
+
+  /** Given x in [0,1) and a in (-1,1),
+   * return (x, a) mod 1.0. 
+   */
+  public static double addMod(double x, final double a) {
+    x += a;
+    return x >= 1? x - 1: x < 0? x + 1: x;
+  }
+
+  /** Given 0 < x < y,
+   * return x^(-1) mod y.
+   */
+  public static long modInverse(final long x, final long y) {
+    if (x == 1) return 1;
+
+    long a = 1;
+    long b = 0;
+    long c = x;
+
+    long u = 0;
+    long v = 1;
+    long w = y;
+    
+    for(;;) {
+      {
+        final long q = w/c;
+        w -= q*c;
+        u -= q*a;
+        if (w == 1) return u > 0? u: u + y;
+        v -= q*b;
+      }
+      {
+        final long q = c/w;
+        c -= q*w;
+        a -= q*u;
+        if (c == 1) return a > 0? a: a + y;
+        b -= q*v;
+      }
+    }
+  }
+}
Index: src/examples/org/apache/hadoop/mp/pi/math/ArithmeticProgression.java
===================================================================
--- src/examples/org/apache/hadoop/mp/pi/math/ArithmeticProgression.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/pi/math/ArithmeticProgression.java	(revision 0)
@@ -0,0 +1,129 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.pi.math;
+
+import org.apache.hadoop.mp.util.Parse;
+
+/** An arithmetic progression */
+public class ArithmeticProgression implements Comparable<ArithmeticProgression> {
+  /** A symbol */
+  public final char symbol;
+  /** Starting value */
+  public final long value;
+  /** Difference between terms */
+  public final long delta;
+  /** Ending value */
+  public final long limit;
+
+  /** Constructor */
+  public ArithmeticProgression(char symbol, long value, long delta, long limit) {
+    if (delta == 0)
+      throw new IllegalArgumentException("delta == 0");
+
+    this.symbol = symbol;
+    this.value = value;
+    this.delta = delta;
+    this.limit = limit;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj)
+      return true;
+    else if (obj != null && obj instanceof ArithmeticProgression) {
+      final ArithmeticProgression that = (ArithmeticProgression)obj;
+      if (this.symbol != that.symbol)
+        throw new IllegalArgumentException("this.symbol != that.symbol, this="
+            + this + ", that=" + that);
+      return this.value == that.value
+          && this.delta == that.delta
+          && this.limit == that.limit;
+    }
+    throw new IllegalArgumentException(obj == null? "obj == null":
+      "obj.getClass()=" + obj.getClass());
+  }
+
+  /** Not supported */
+  public int hashCode() {
+    throw new UnsupportedOperationException();
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public int compareTo(ArithmeticProgression that) {
+    if (this.symbol != that.symbol)
+      throw new IllegalArgumentException("this.symbol != that.symbol, this="
+          + this + ", that=" + that);
+    if (this.delta != that.delta)
+      throw new IllegalArgumentException("this.delta != that.delta, this="
+          + this + ", that=" + that);
+    final long dl = this.limit - that.limit;
+    if (dl != 0)
+      return dl > 0? 1: -1;
+    final long dv = this.value - that.value;
+    return dv > 0? 1: dv < 0? -1: 0;
+  }
+
+  /** Does this contain that? */
+  boolean contains(ArithmeticProgression that) {
+    if (this.symbol != that.symbol)
+      throw new IllegalArgumentException("this.symbol != that.symbol, this="
+          + this + ", that=" + that);
+    if (this.delta == that.delta) {
+      if (this.value == that.value)
+        return this.getSteps() >= that.getSteps();
+      else if (this.delta < 0)
+        return this.value > that.value && this.limit <= that.limit;
+      else if (this.delta > 0)
+        return this.value < that.value && this.limit >= that.limit;
+    }
+    return false;    
+  }
+
+  /** Skip some steps */
+  long skip(long steps) {
+    if (steps < 0)
+      throw new IllegalArgumentException("steps < 0, steps=" + steps);
+    return value + steps*delta; 
+  }
+
+  /** Get the number of steps */
+  public long getSteps() {
+    return (limit - value)/delta;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public String toString() {
+    return symbol + ":value=" + value + ",delta=" + delta + ",limit=" + limit;
+  }
+
+  /** Convert a String to an ArithmeticProgression. */
+  static ArithmeticProgression valueOf(final String s) {
+    int i = 2;
+    int j = s.indexOf(",delta=");
+    final long value = Parse.parseLongVariable("value", s.substring(2, j));
+    i = j + 1;
+    j = s.indexOf(",limit=");
+    final long delta = Parse.parseLongVariable("delta", s.substring(i, j));
+    i = j + 1;
+    final long limit = Parse.parseLongVariable("limit", s.substring(i));
+    return new ArithmeticProgression(s.charAt(0), value, delta, limit);
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/pi/math/Bellard.java
===================================================================
--- src/examples/org/apache/hadoop/mp/pi/math/Bellard.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/pi/math/Bellard.java	(revision 0)
@@ -0,0 +1,370 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.pi.math;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.StringTokenizer;
+
+import org.apache.hadoop.mp.util.Container;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Parse;
+import org.apache.hadoop.mp.util.Print;
+import org.apache.hadoop.mp.util.serialization.StringSerializable;
+
+/**
+ * Bellard's BBP-type Pi formula
+ * 1/2^6 \sum_{n=0}^\infty (-1)^n/2^{10n}
+ * (-2^5/(4n+1) -1/(4n+3) +2^8/(10n+1) -2^6/(10n+3) -2^2/(10n+5)
+ *  -2^2/(10n+7) +1/(10n+9))
+ *  
+ * References:
+ *
+ * [1] David H. Bailey, Peter B. Borwein and Simon Plouffe.  On the Rapid
+ *     Computation of Various Polylogarithmic Constants.
+ *     Math. Comp., 66:903-913, 1996.
+ *     
+ * [2] Fabrice Bellard.  A new formula to compute the n'th binary digit of pi,
+ *     1997.  Available at http://fabrice.bellard.free.fr/pi .
+ */
+public final class Bellard implements StringSerializable.ValueOf<Bellard.Parameter> {
+  public static Bellard FACTORY = new Bellard();
+
+  private Bellard() {}
+
+  @Override
+  public Bellard.Parameter valueOf(String s) {
+    String t = s.trim();
+    if (t.charAt(0) == 'P')
+      t = t.substring(1);
+    final String[] parts = t.split("\\D+");
+    if (parts.length >= 2) {
+      final String name = "P" + parts[0] + "_" + parts[1];  
+      for(Parameter p : Parameter.values())
+        if (p.name().equals(name))
+          return p;
+    }
+    return null;
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  /** Parameters for the sums */
+  public enum Parameter {
+    // \sum_{k=0}^\infty (-1)^{k+1}( 2^{d-10k-1}/(4k+1) + 2^{d-10k-6}/(4k+3) )
+    P8_1(false, 1, 8, -1),
+    P8_3(false, 3, 8, -6),
+    P8_5(P8_1),
+    P8_7(P8_3),
+
+    /*
+     *   2^d\sum_{k=0}^\infty (-1)^k( 2^{ 2-10k} / (10k + 1)
+     *                               -2^{  -10k} / (10k + 3)
+     *                               -2^{-4-10k} / (10k + 5)
+     *                               -2^{-4-10k} / (10k + 7)
+     *                               +2^{-6-10k} / (10k + 9) )
+     */
+    P20_21(true , 1, 20,  2),
+    P20_3(false, 3, 20,  0),
+    P20_5(false, 5, 20, -4),
+    P20_7(false, 7, 20, -4),
+    P20_9(true , 9, 20, -6),
+    P20_11(P20_21),
+    P20_13(P20_3),
+    P20_15(P20_5),
+    P20_17(P20_7),
+    P20_19(P20_9);
+    
+    public final boolean isplus;
+    final long j;
+    final int deltaN;
+    final int deltaE;
+    final int offsetE;      
+
+    private Parameter(boolean isplus, long j, int deltaN, int offsetE) {
+      this.isplus = isplus;
+      this.j = j;
+      this.deltaN = deltaN;
+      this.deltaE = -20;
+      this.offsetE = offsetE;        
+    }
+
+    private Parameter(Parameter p) {
+      this.isplus = !p.isplus;
+      this.j = p.j + (p.deltaN >> 1);
+      this.deltaN = p.deltaN;
+      this.deltaE = p.deltaE;
+      this.offsetE = p.offsetE + (p.deltaE >> 1);
+    }
+  }
+
+  static Summation createSummation(long b, Parameter p) {
+    if (b < 0)
+      throw new IllegalArgumentException("b = " + b + " < 0");
+    final long i = p.j == 1 && p.offsetE >= 0? 1 : 0;
+    final long e = b + i*p.deltaE + p.offsetE;
+    final long n = i*p.deltaN + p.j;
+
+    /*
+     * Given precision p, what are the values of N and E?
+     * 2^{E}(1/N) < 1/2^p
+     * 2^{E + p} < N
+     * E + p < log n' < log N, where n' is some value of n
+     * 
+     * log x >= Long.SIZE - 1 - Long.numberOfLeadingZeros(x)
+     * 
+     * Therefore, set E = Long.SIZE - 1 - Long.numberOfLeadingZeros(n') - p
+     */
+    final long ntmp = n - p.deltaN*(e/p.deltaE);
+    final long elimit = Long.SIZE - 1 - Long.numberOfLeadingZeros(ntmp) - Mod1Fraction.getPrecision();
+
+    return new Summation(p.isplus, n, p.deltaN, e, p.deltaE, elimit);
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  public static Parameter[] parse(String s) {
+    if (s == null)
+      return Parameter.values();
+    else {
+      final List<Parameter> a = new ArrayList<Parameter>();
+      for(final StringTokenizer t = new StringTokenizer(s, ", "); t.hasMoreTokens();) {
+        final Parameter p = FACTORY.valueOf(t.nextToken());
+        if (p != null)
+          a.add(p);
+      }
+      return a.toArray(new Parameter[a.size()]);
+    }
+  }
+
+  /** The sums in the Bellard's formula */
+  public static class Sum implements Container<Summation>, Iterable<Summation> {
+    private final String name;
+    private final Summation sigma;
+    private final Summation[] parts;
+
+    /** Constructor */
+    private <T extends Container<Summation>> Sum(long b, Parameter p, int nParts, List<T> existing) {
+      if (nParts < 1)
+        throw new IllegalArgumentException("nParts = " + nParts + " < 1");
+
+      this.name = p.toString();
+      this.sigma = createSummation(b, p);
+      this.parts = partition(sigma, nParts, existing);
+    }
+
+    private static <T extends Container<Summation>> Summation[] partition(
+        Summation sigma, int nParts, List<T> existing) {
+      final List<Summation> parts = new ArrayList<Summation>();
+      if (existing == null || existing.isEmpty())
+        parts.addAll(sigma.partition(nParts));
+      else {
+        final long stepsPerPart = sigma.getSteps()/nParts;
+        final List<Summation> remaining = sigma.remainingTerms(existing);
+
+        for(Summation s : remaining) {
+          final int n = (int)((s.getSteps() - 1)/stepsPerPart) + 1;
+          parts.addAll(s.partition(n));
+        }
+        Collections.sort(parts);
+      }
+      return parts.toArray(new Summation[parts.size()]);
+    }
+    
+    /** {@inheritDoc} */
+    @Override
+    public String toString() {
+      return name + ": " + sigma + ", parts.length=" + parts.length;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public Summation get() {
+      return sigma;
+    }
+/*
+    /** The sum tail 
+    private class Tail {
+      private long n;
+      private long e;
+
+      private Tail(long n, long e) {
+        if (e > 0) {
+          final long edelta = -sigma.E.delta;
+          long q = e / edelta;
+          long r = e % edelta;
+          if (r == 0) {
+            e = 0;
+            n += q * sigma.N.delta;
+          } else {
+            e = edelta - r;
+            n += (q + 1)*sigma.N.delta;
+          }
+        } else if (e < 0)
+          e = -e; 
+
+        this.n = n;
+        this.e = e;
+      }
+
+      //2^{p-E} < N
+      //=>  p - E < log N
+      //=>  p - e + s(d_e) < log(n + s(d_n))
+      //
+      //Therefore, check  p - e + s(d_e) < log n
+      private Mod1Fraction compute() {
+        //Util.out.println("Tail: e=" + e + ", n=" + n);
+    
+        final long p = Mod1Fraction.getPrecision();
+        for(final Mod1Fraction s = Mod1Fraction.zero();;) {
+          if (e > p || p - e <= Long.SIZE - 1 - Long.numberOfLeadingZeros(n))
+            return s;
+
+          s.addShiftFractionMod1Equal(n, e);
+          n += sigma.N.delta;
+          e -= sigma.E.delta;
+        }
+      }
+    }
+*/
+    /** {@inheritDoc} */
+    @Override
+    public Iterator<Summation> iterator() {
+      return new Iterator<Summation>() {
+        private int i = 0;
+
+        /** {@inheritDoc} */
+        @Override
+        public boolean hasNext() {return i < parts.length;}
+        /** {@inheritDoc} */
+        @Override
+        public Summation next() {return parts[i++];}
+        /** Unsupported */
+        @Override
+        public void remove() {throw new UnsupportedOperationException();}
+      };
+    }
+  }
+
+  /** Get the sums for the Bellard formula. */
+  public static <T extends Container<Summation>> Sum getSum(final long b,
+      final Parameter p, final int partsPerSum, List<T> existings) {
+    final Sum s = new Sum(b, p, partsPerSum, existings);
+    if (s.parts.length == 0) {
+      Print.println("DONE: " + s);
+      return null;
+    } else {
+      Print.println("ADD : " + s);
+      return s;
+    }
+  }
+
+  /** Compute bits of Pi in the local machine. */
+  public static Mod1Fraction computePi(final long b, final long precision,
+      final JavaUtil.Timer t) {
+    Mod1Fraction.setPrecision(precision);
+
+    final Mod1Fraction pi = Mod1Fraction.zero();
+    for(Parameter p : Parameter.values()) {
+      final Summation sigma = createSummation(b, p);
+      final Mod1Fraction value = sigma.compute(t);
+      if (p.isplus)
+        pi.addMod1Equal(value);
+      else
+        pi.subtractMod1Equal(value);
+      if (t != null)
+        t.tick(p + ": sigma=" + sigma + ", value=" + value);
+    }
+    return pi;
+  }
+
+  /** main */
+  public static void main(String[] args) throws IOException {
+    final Mod1Fraction.Factory[] factories = {
+        new Mod1Fraction_IntArray.Factory(),
+        //new Mod1Fraction_Apfloat.Factory()
+    };
+
+    Print.initLogFile(Bellard.class.getSimpleName());
+    /*
+    for(long p = 1000; ; p *= 10) {
+      final long b = 0;
+      final long precision = p + 1000;
+    */
+    //for(long b = 100; ; b *= 10) {
+    {
+      int  b = 2152301;
+      final long precision = 128;
+
+      Print.println("\n\nb = " + Parse.long2string(b)
+          + ", precision = " + Parse.long2string(precision));
+
+      for(Mod1Fraction.Factory f : factories) {
+        Mod1Fraction.FACTORY = f;
+        final String name = Mod1Fraction.FACTORY.getName();
+        Print.println("\n" + name);
+      
+        final JavaUtil.Timer t = new JavaUtil.Timer(false, true);
+        t.tick("START: " + name);
+        final Mod1Fraction pi = computePi(b, precision, null);
+        final long duration = t.tick("DONE");
+        Print.log.println("duration = " + duration + " = " + Parse.millis2String(duration));
+        pi.print(Print.log);
+      }
+      Print.println(Mod1Fraction_IntArray.getStatistics());
+    }
+    
+
+    /*
+    computePi(t, 1);
+    computePi(t, 2);
+    computePi(t, 3);
+    computePi(t, 4);
+
+    Util.printBitSkipped(1008);
+    computePi(t, 1008);
+    computePi(t, 1012);
+
+    {
+      long b = 10;
+      for(int i = 0; i < 3; i++) {
+        Util.printBitSkipped(b);
+        computePi(t, b - 4);
+        computePi(t, b);
+        computePi(t, b + 4);
+        b *= 10;
+      }
+    }
+    */
+/*
+    {
+      final long b = 0;
+      final long check = 1280;
+      long p = 100;
+      for(int i = 0; i < 10; i++) {
+        final long duration = t.tick(computePi(new JavaUtil.Timer(false), b, p));
+        JavaUtil.out.println("b = " + b + ", p = " + p
+            + ", duration = " + JavaUtil.millis2String(duration));
+        
+        final long last = Math.max(((b + p - 1)/check - 1)*check, 0L);
+        t.tick("last = " + last + ", check = " + check + ", " + computePi(null, last, 2*check));
+        p *= 10;
+      }
+    }
+    */
+  }
+}
Index: src/examples/org/apache/hadoop/mp/pi/math/Mod1Fraction_LongArray_NotWorking.java
===================================================================
--- src/examples/org/apache/hadoop/mp/pi/math/Mod1Fraction_LongArray_NotWorking.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/pi/math/Mod1Fraction_LongArray_NotWorking.java	(revision 0)
@@ -0,0 +1,355 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.pi.math;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.io.PrintStream;
+import java.util.Arrays;
+
+import org.apache.hadoop.mp.util.Interval;
+import org.apache.hadoop.mp.util.Statistics;
+
+public class Mod1Fraction_LongArray_NotWorking extends Mod1Fraction {
+  private static final Statistics stat = new Statistics(Mod1Fraction_LongArray_NotWorking.class.getSimpleName());
+  public static Statistics getStatistics() {return stat;}
+
+  public static class Factory extends Mod1Fraction.Factory {
+    @Override
+    public String getName() {
+      return Mod1Fraction_LongArray_NotWorking.class.getSimpleName();
+    }
+
+    @Override
+    public Mod1Fraction_LongArray_NotWorking zero() {
+      return new Mod1Fraction_LongArray_NotWorking(1 + (int)((getPrecision() - 1)/BIT_PER_VALUE));
+    }
+
+    @Override
+    public Mod1Fraction valueOf(DataInput in) throws IOException {
+      final Mod1Fraction_LongArray_NotWorking n = new Mod1Fraction_LongArray_NotWorking(in.readInt());
+      for(int i = in.readInt(); i < n.values.length; i++)
+        n.values[i] = in.readLong();
+      return n;
+    }
+
+    @Override
+    public Mod1Fraction valueOf(String s) {
+      try {
+        if (s.charAt(0) != '[' || s.charAt(s.length() - 1) != ']')
+          throw new IllegalArgumentException("s.charAt(0) != '[' || s.charAt(s.length() - 1) != ']'");
+
+        int i = 1;
+        int j = s.indexOf(":");
+        final Mod1Fraction_LongArray_NotWorking n = new Mod1Fraction_LongArray_NotWorking(
+            Integer.parseInt(s.substring(i, j)));
+        
+        for(int k = 0; k < n.values.length; k++) {
+          i = j + 1;
+          j = s.indexOf(" ", i);
+          n.values[k] = Long.parseLong(s.substring(i, j), 16);
+        }
+        return n;
+      } catch(RuntimeException e) {
+        throw new RuntimeException("s = ***" + s + "***", e);
+      }
+    }
+  }
+
+  private static int BIT_PER_VALUE = Long.SIZE;
+  //---------------------------------------------------------------------------
+  private final long[] values;
+
+  Mod1Fraction_LongArray_NotWorking(final int len) {
+    values = new long[len];
+  }
+  
+  Mod1Fraction_LongArray_NotWorking init(final long numerator, final long denominator, final long shift) {
+    /*
+    if (stat != null)
+      stat.countExecutionPoint("Mod1Fraction_IntArray.init");
+*/
+    Arrays.fill(values, 0);
+
+    final long sq = shift >>> 5;
+    if (sq >= values.length)
+      return this;
+
+    final int sr;
+    final long d;
+    if (denominator == 1) {
+      sr = 0;
+      d = 1L << (shift & 0x1FL);
+    } else {
+      sr = (int)(shift & 0x1FL);
+      d = denominator;
+    }
+
+    if (SMALL_DENOMINATORS.contains(d))
+      return initSmall(numerator, d, (int)sq, sr);
+    else {
+      initLarge(numerator, d, (int)sq, sr);
+      /*
+      JavaUtil.out.println("\ninitLarge(numerator = " + numerator + ", denominator = " + denominator + ", shift = " + shift + ")"); 
+      JavaUtil.out.println("  this     = " + this); 
+      JavaUtil.out.println("  expected = " + initApfloatTL.get().initApfloat(numerator, denominator, shift));
+      */
+      return this;
+    }
+  }
+
+  private static Interval SMALL_DENOMINATORS = new Interval(1L, 1L << 31);
+  private static Interval LARGE_DENOMINATORS = new Interval(SMALL_DENOMINATORS.end, 1L << 62);
+
+  final long[][] quotients = new long[9][16];
+  final long[][] remainers = new long[quotients.length][quotients[0].length];
+
+  /** Bit 61 to 96 */
+  private void initQR(final long d) {
+    long q = (1L << 60)/d;
+    long r = (1L << 60) - q*d;
+
+    for(int i = 0; i < quotients.length; i++) {
+      final long unitQ = q;
+      final long unitR = r;
+      quotients[i][0] = 0;
+      remainers[i][0] = 0;
+
+      for(int j = 1; j < quotients[i].length; j++) {
+        quotients[i][j] = q;
+        remainers[i][j] = r;
+        q += unitQ;
+        r += unitR;
+        if (r >= d) {q++;  r -= d;}
+      }
+    }
+  }
+
+  /** d is a {@link #LARGE_DENOMINATORS} */
+  Mod1Fraction_LongArray_NotWorking initLarge(long n, final long d, final int beginindex, final int rightshift) {
+    if (beginindex >= values.length)
+      return this;
+/*
+    if (stat != null)
+      stat.countExecutionPoint("Mod1Fraction_IntArray.initLarge");
+*/
+    if (!LARGE_DENOMINATORS.contains(d))
+      throw new IllegalArgumentException("d = " + d + " is not in " + LARGE_DENOMINATORS);
+
+    initQR(d);
+    if (rightshift == 0)
+      for(int i = beginindex; i < values.length && n != 0; i++) {
+        long high = n >>> 24;
+        n <<= 36;
+        n >>>= 4;
+        long q = n/d;
+        long r = n - q*d;
+        for(int j = 0; j < quotients.length; j++) {
+          high >>= 4;
+          final int bits = (int)(high & 0xF);
+          q += quotients[j][bits];
+          r += remainers[j][bits];
+          if (r >= d) {q++;  r -= d;}
+        }
+        n = r;
+
+        values[i] = (int)q;
+      }
+    else {
+      final int leftshift = Integer.SIZE - rightshift;
+      int prev = 0;
+      for(int i = beginindex; i < values.length && n != 0; i++) {
+        long high = n >>> 24;
+        n <<= 36;
+        n >>>= 4;
+        long q = n/d;
+        long r = n - q*d;
+        for(int j = 0; j < quotients.length; j++) {
+          high >>= 4;
+          final int bits = (int)(high & 0xF);
+          q += quotients[j][bits];
+          r += remainers[j][bits];
+          if (r >= d) {q++;  r -= d;}
+        }
+        n = r;
+
+        values[i] = prev;
+        prev = (int)q;
+        values[i] |= prev >>> rightshift;
+        prev <<= leftshift;
+      }
+    }
+    return this;
+  }
+
+  /** d is a {@link #SMALL_DENOMINATORS} */
+  Mod1Fraction_LongArray_NotWorking initSmall(long n, final long d, final int beginindex, final int rightshift) {
+    /*
+    if (stat != null)
+      stat.countExecutionPoint("Mod1Fraction_IntArray.initSmall");
+*/
+    if (!SMALL_DENOMINATORS.contains(d))
+      throw new IllegalArgumentException("d = " + d + " is not in " + SMALL_DENOMINATORS);
+
+    if (rightshift == 0)
+      for(int i = beginindex; i < values.length && n != 0; i++) {
+        n <<= 32;
+        final long q = n/d;
+        values[i] = (int)q;
+        n -= q*d;
+      }
+    else {
+      final int leftshift = Integer.SIZE - rightshift;
+      int prev = 0;
+      for(int i = beginindex; i < values.length && n != 0; i++) {
+        n <<= 32;
+        final long q = n/d;
+        n -= q*d;
+
+        values[i] = prev;
+        prev = (int)q;
+        values[i] |= prev >>> rightshift;
+        prev <<= leftshift;
+      }
+    }
+    /*
+    JavaUtil.out.println("\nnumerator = " + numerator + ", denominator = " + denominator + ", shift = " + shift); 
+    JavaUtil.out.println("  this     = " + this); 
+    JavaUtil.out.println("  expected = " + newInstance_Apfloat(len, numerator,  denominator, shift));
+    */ 
+    return this;
+  }
+
+  @Override
+  public Mod1Fraction clone() {
+    final Mod1Fraction_LongArray_NotWorking f = new Mod1Fraction_LongArray_NotWorking(values.length);
+    System.arraycopy(values, 0, f.values, 0, values.length);
+    return f;
+  }
+
+  @Override
+  public Mod1Fraction_LongArray_NotWorking addMod1Equal(Mod1Fraction that) {
+    return addMod1Equal(that, 0);
+  }
+  private Mod1Fraction_LongArray_NotWorking addMod1Equal(Mod1Fraction that, final long beginindex) {
+    if (beginindex >= values.length)
+      return this;
+
+    final long[] a = ((Mod1Fraction_LongArray_NotWorking)that).values;
+    long carry = 0;
+    int i = values.length - 1;
+    for(; i >= (int)beginindex; i--) {
+      carry += values[i] & 0xFFFFFFFFL;
+      carry += a[i] & 0xFFFFFFFFL;
+      values[i] = (int)carry;
+      carry >>= 32;
+    }
+    for(; carry != 0 && i >= 0; i--) {
+      carry += values[i] & 0xFFFFFFFFL;
+      values[i] = (int)carry;
+      carry >>= 32;
+    }
+    return this;
+  }
+
+  @Override
+  public Mod1Fraction_LongArray_NotWorking subtractMod1Equal(Mod1Fraction that) {
+    final long[] a = ((Mod1Fraction_LongArray_NotWorking)that).values;
+    long borrow = 0;
+    for(int i = values.length - 1; i >= 0; i--) {
+      borrow += values[i] & 0xFFFFFFFFL;
+      borrow -= a[i] & 0xFFFFFFFFL;
+      values[i] = (int)borrow;
+      borrow >>= 32;
+    }
+    return this;
+  }
+
+  private final ThreadLocal<Mod1Fraction_LongArray_NotWorking> tmp = new ThreadLocal<Mod1Fraction_LongArray_NotWorking>() {
+    @Override
+    protected Mod1Fraction_LongArray_NotWorking initialValue() {
+      return new Mod1Fraction_LongArray_NotWorking(values.length);
+    }
+  };
+
+  @Override
+  public Mod1Fraction_LongArray_NotWorking addFractionMod1Equal(long numerator, long denominator) {
+    return addMod1Equal(tmp.get().init(numerator, denominator, 0));
+  }
+
+  /**
+   * s += 1/(n 2^e)
+   * s += 1.0 / (n << e);
+   * if (s >= 1) s--;
+   */
+  @Override
+  public Mod1Fraction_LongArray_NotWorking addShiftFractionMod1Equal(long n, long e) {
+    return addMod1Equal(tmp.get().init(1, n, e), e >>> 5);
+  }
+
+  @Override
+  public void printHex(int partsPerLine, PrintStream out) {
+    out.print("[" + values.length + ":");
+    for(int i = 0; i < values.length; i++) {
+      if (partsPerLine > 0 && i % partsPerLine == 0) {
+        out.println();
+        out.print("  ");
+      }
+      out.print(String.format("%08X ", values[i]));
+    }
+  }
+
+  private final int MAX_STRING_ITEM = 100;
+  @Override
+  public String toHexString(int partPerLine) {
+    final boolean iscompact = partPerLine == 0;
+    final StringBuilder b = new StringBuilder(); 
+    b.append("[").append(values.length).append(":");
+
+    int i = 0;
+    if (iscompact) {
+      //skip zeros
+      for(; i < values.length && values[i] == 0; i++);
+      if (i > 0)
+        b.append(" <00000000 x " + i + "> ");
+    }
+
+    final int n = iscompact && MAX_STRING_ITEM+i < values.length?
+        MAX_STRING_ITEM+i: values.length;
+    for(; i < n; i++) {
+      if (partPerLine > 0 && i % partPerLine == 0)
+        b.append("\n  ");
+      b.append(String.format("%08X ", values[i]));
+    }
+    if (i < values.length)
+      b.append("... ");
+    return b.append("]").toString();
+  }
+
+  @Override
+  public Void serialize(DataOutput out) throws IOException {
+    out.writeInt(values.length);
+    int i = 0;
+    for(; i < values.length && values[i] == 0; i++);
+    out.writeInt(i);
+    for(; i < values.length; i++)
+      out.writeLong(values[i]);
+    return null;
+  }
+}
Index: src/examples/org/apache/hadoop/mp/pi/math/Mod1Fraction.java
===================================================================
--- src/examples/org/apache/hadoop/mp/pi/math/Mod1Fraction.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/pi/math/Mod1Fraction.java	(revision 0)
@@ -0,0 +1,94 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.pi.math;
+
+import java.io.DataInput;
+import java.io.IOException;
+import java.io.PrintStream;
+
+import org.apache.hadoop.mp.util.serialization.DataSerializable;
+import org.apache.hadoop.mp.util.serialization.StringSerializable;
+
+public abstract class Mod1Fraction implements Cloneable, DataSerializable<Void> {
+  public static Factory FACTORY = new Mod1Fraction_IntArray.Factory();
+
+  public static abstract class Factory
+      implements StringSerializable.ValueOf<Mod1Fraction>, DataSerializable.ValueOf<Mod1Fraction> {
+    protected long precision = 100;
+
+    public void setPrecision(long precision) {
+      this.precision = precision;
+    }
+
+    public long getPrecision() {
+      return precision;
+    }
+
+    public abstract String getName();
+
+    public abstract Mod1Fraction zero();
+  }
+
+  public static long getPrecision() {return FACTORY.getPrecision();}
+
+  public static void setPrecision(long precision) {FACTORY.setPrecision(precision);}
+
+  public static Mod1Fraction zero() {return FACTORY.zero();}
+  
+  public static Mod1Fraction valueOf(String s) {return FACTORY.valueOf(s);}
+
+  public static Mod1Fraction valueOf(DataInput in) throws IOException {
+    return FACTORY.valueOf(in);
+  }
+  //---------------------------------------------------------------------------
+  public abstract Mod1Fraction clone();
+
+  public abstract Mod1Fraction subtractMod1Equal(Mod1Fraction that);
+
+  public abstract Mod1Fraction addMod1Equal(Mod1Fraction that);
+
+  public final Mod1Fraction addMod1(Mod1Fraction that) {
+    final Mod1Fraction sum = clone().addMod1Equal(that);
+    /*
+    JavaUtil.out.println("\n  this = " + this);
+    JavaUtil.out.println("  that = " + that);
+    JavaUtil.out.println("  sum  = " + sum);
+    */
+    //new Exception().printStackTrace(JavaUtil.out);
+    return sum;
+  }
+
+  public abstract Mod1Fraction addFractionMod1Equal(long numerator, long denominator);
+
+  /** 
+   * s += 1/(n 2^e)
+   * s += 1.0 / (n << e);
+   * if (s >= 1) s--;
+   */
+  public abstract Mod1Fraction addShiftFractionMod1Equal(long n, long e);
+
+  /** Print out value. */
+  public void print(PrintStream out) {printHex(10, out);}
+
+  public abstract void printHex(int partsPerLine, PrintStream out);
+
+  public abstract String toHexString(int partsPerLine);
+
+  @Override
+  public final String toString() {return toHexString(0);}
+}
Index: src/examples/org/apache/hadoop/mp/pi/math/TestMod1Fraction.java
===================================================================
--- src/examples/org/apache/hadoop/mp/pi/math/TestMod1Fraction.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/pi/math/TestMod1Fraction.java	(revision 0)
@@ -0,0 +1,49 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.pi.math;
+
+import org.apache.hadoop.mp.util.Print;
+
+
+public class TestMod1Fraction extends junit.framework.TestCase {
+  public void testBasic() throws Exception {
+    final Mod1Fraction_IntArray.Factory f = new Mod1Fraction_IntArray.Factory();
+    Print.println("0 = " + f.zero());
+    
+    final Mod1Fraction_IntArray x = new Mod1Fraction_IntArray(4);
+    final Mod1Fraction_IntArray sum = f.zero();
+    final Mod1Fraction_IntArray sub = f.zero();
+    for(int i = 1; i < 10; i++) {
+      x.init(1, i, 0);
+      Print.println("\n1/" + i + " = " + x);
+      sum.addMod1Equal(x);
+      Print.println("sum = " + sum);
+      sub.subtractMod1Equal(x);
+      Print.println("sub = " + sub);
+    }
+  }
+  public void testSummation() throws Exception {
+    Mod1Fraction.setPrecision(1000);
+    for(int i = 0; i < 10; i++) {
+      final long n = (1L << 31) + (i - 5)*20;
+      final Summation sigma = new Summation(true, n, 20, 100+i, -20, 0);
+      Print.println("sigma           = " + sigma);
+      Print.println("sigma.compute() = " + sigma.compute(null));
+    }
+  }
+}
Index: src/examples/org/apache/hadoop/mp/pi/math/Mod1Fraction_Apfloat.java
===================================================================
--- src/examples/org/apache/hadoop/mp/pi/math/Mod1Fraction_Apfloat.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/pi/math/Mod1Fraction_Apfloat.java	(revision 0)
@@ -0,0 +1,272 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.pi.math;
+
+//
+//import java.io.DataInput;
+//import java.io.DataOutput;
+//import java.io.IOException;
+//import java.io.PrintStream;
+//
+//import org.apache.hadoop.examples.util.JavaUtil;
+//import org.apache.hadoop.examples.util.ValueOf;
+//import org.apfloat.Apfloat;
+//import org.apfloat.ApfloatContext;
+//import org.apfloat.Apint;
+//import org.apfloat.ApintMath;
+//
+//public class Mod1Fraction_Apfloat extends Mod1Fraction {
+//  private static int radix_exponent;
+//  private static int radix;
+//
+//  private static Apfloat ZERO;
+//  private static Apfloat ONE;
+//  
+//  private static Apint TWOi;
+//  private static Apint TWOto32;
+//
+//  public static class Factory extends Mod1Fraction.Factory {
+//    @Override
+//    public long getPrecision() {return precision*radix_exponent;}
+//
+//    @Override
+//    public void setPrecision(long p) {
+//      final int r_e = 4;
+//      if (p % r_e != 0)
+//        throw new IllegalArgumentException(
+//            "p % r_e != 0, p=" + p + ", r_e=" + r_e);
+//
+//      radix_exponent = r_e;
+//      radix = 1 << radix_exponent;
+//      precision = p/radix_exponent;
+//
+//      ZERO = newApfloat(0);
+//      ONE = newApfloat(1);
+//
+//      TWOi = newApint(2);
+//      TWOto32 = newApint(1L << 32);
+//
+//      JavaUtil.out.println("precision=" + JavaUtil.long2string(getPrecision()) + ", radix=" + radix
+//          + ", ONE.precision=" + JavaUtil.long2string(ONE.precision()) + ", ONE.radix=" + ONE.radix());
+//    }
+//
+//    @Override
+//    public String getName() {
+//      return Mod1Fraction_Apfloat.class.getSimpleName();
+//    }
+//
+//    @Override
+//    public Mod1Fraction zero() {
+//      return new Mod1Fraction_Apfloat(newApfloat(0));
+//    }
+//
+//    private static final ValueOf.IO<Mod1Fraction> VALUE_OF_IO = new ValueOf.IO<Mod1Fraction>() {
+//      @Override
+//      public Mod1Fraction valueOf(DataInput in) throws IOException {
+//        Apfloat x = ZERO;
+//        long m = 0;
+//        for(int count = in.readInt(); count > 0; count = in.readInt()) {
+//          for(int i = 0; i < count; i++) {
+//            x = x.multiply(TWOto32);
+//            x = x.add(newApint(in.readInt()));
+//            m++;
+//          }
+//        }
+//        x = x.divide(ApintMath.pow(TWOto32, m));
+//        return new Mod1Fraction_Apfloat(x);
+//      }
+//    };
+//    @Override
+//    public ValueOf.IO<Mod1Fraction> getValueOfIO() {return VALUE_OF_IO;}
+//
+//    private static final ValueOf.Str<Mod1Fraction> VALUE_OF_STR = new ValueOf.Str<Mod1Fraction>() {
+//      @Override
+//      public Mod1Fraction valueOf(String s) {
+//        int i = 1;
+//        int j = s.indexOf(":");
+//        final int count = Integer.parseInt(s.substring(i, j));
+//        
+//        Apfloat x = ZERO;
+//        for(int k = 0; k < count; k++) {
+//          i = j + 1;
+//          j = s.indexOf(" ", i);
+//          x = x.multiply(TWOto32);
+//          x = x.add(newApfloat(s.substring(i, j)));
+//        }
+//        x = x.divide(ApintMath.pow(TWOto32, count));
+//        return new Mod1Fraction_Apfloat(x);
+//      }
+//    };
+//    @Override
+//    public ValueOf.Str<Mod1Fraction> getValueOfStr() {return VALUE_OF_STR;}
+//  }
+//
+//  static {
+//    final ApfloatContext ctx = ApfloatContext.getGlobalContext();
+//    ctx.setMaxMemoryBlockSize(1024L << 20);
+//    ctx.setMemoryTreshold(1024 << 20);
+//    ctx.setSharedMemoryTreshold(1024L << 20);
+//    setPrecision(100);
+//    //dump();
+//  }
+//
+//  static void dumpApfloatContext(final PrintStream out) {
+//    final ApfloatContext ctx = ApfloatContext.getContext();
+//    out.println("*************** ApfloatContext ***************");
+//    out.println("builderFactory       = " + ctx.getBuilderFactory().getClass().getName());
+//    out.println("numberOfProcessors   = " + ctx.getNumberOfProcessors());
+//    out.println("cacheL1Size          = " + ctx.getCacheL1Size());
+//    out.println("cacheL2Size          = " + ctx.getCacheL2Size());
+//    out.println("cacheBurst           = " + ctx.getCacheBurst());
+//    out.println("blockSize            = " + ctx.getBlockSize());
+//    out.println("maxMemoryBlockSize   = " + ctx.getMaxMemoryBlockSize());
+//    out.println("memoryTreshold       = " + ctx.getMemoryTreshold());
+//    out.println("sharedMemoryTreshold = " + ctx.getSharedMemoryTreshold());
+//    out.println("**********************************************");
+//  }
+//
+//  private static Apint newApint(long n) {return new Apint(n, radix);}
+//  private static Apfloat newApfloat(long n) {return new Apfloat(n, getPrecision()/radix_exponent, radix);}
+//
+//  private static Apfloat newApfloat(String s) {
+////    Util.out.println("s = " + s);
+//    try {
+//      return new Apfloat(s, getPrecision(), radix);
+//    } catch(NumberFormatException nfe) {
+//      JavaUtil.err.println("s = " + s);
+//      throw nfe;
+//    }
+//  }
+//  //---------------------------------------------------------------------------
+//  private Apfloat value;
+//
+//  private Mod1Fraction_Apfloat(Apfloat value) {this.value = value;}
+//
+//  @Override
+//  public Mod1Fraction_Apfloat clone() {
+//    return new Mod1Fraction_Apfloat(value);
+//  }
+//
+//  @Override
+//  public Mod1Fraction_Apfloat addMod1Equal(Mod1Fraction that) {
+//    if (that != null) {
+//      final Apfloat y = ((Mod1Fraction_Apfloat)that).value;
+//      final Apfloat x = value.add(y);
+//      value = x.compareTo(ONE) >= 0? x.subtract(ONE): x;
+//    }
+//    return this;
+//  }
+//
+//  @Override
+//  public Mod1Fraction_Apfloat subtractMod1Equal(Mod1Fraction that) {
+//    if (that != null) {
+//      final Apfloat y = ((Mod1Fraction_Apfloat)that).value;
+//      final Apfloat x = value.subtract(y);
+//      value = x.compareTo(ZERO) < 0? x.add(ONE): x;
+//    }
+//    return this;
+//  }
+//
+//  @Override
+//  public Mod1Fraction_Apfloat addFractionMod1Equal(final long numerator, final long denominator) {
+//    Apfloat x = value.add(newApfloat(numerator).divide(newApfloat(denominator)));
+//    if (x.compareTo(ONE) >= 0)
+//      x = x.subtract(ONE);
+//    value = x;
+//    return this;
+//  }
+//
+//  @Override
+//  public Mod1Fraction_Apfloat addShiftFractionMod1Equal(long n, long e) {
+//    Apfloat x = value.add(ONE.divide(newApint(n)).divide(ApintMath.pow(TWOi, e)));
+//    if (x.compareTo(ONE) >= 0)
+//      x = x.subtract(ONE);
+//    value = x;
+//    return this;
+//  }
+//
+//  private void check0to1() {
+//    if (value.compareTo(ZERO) < 0 || value.compareTo(ONE) >= 0)
+//      throw new RuntimeException("value  < 0 || value >= 1, value = " + value);
+//  }
+//
+//  @Override
+//  public String toHexString(int partPerLine) {
+//    check0to1();
+//
+//    int count = 0;
+//    final StringBuilder b = new StringBuilder(); 
+//    for(Apfloat x = value; x.compareTo(ZERO) > 0; ) {
+//      x = x.multiply(TWOto32);
+//      final Apint n = x.truncate();
+//      if (partPerLine > 0 && count % partPerLine == 0)
+//        b.append("\n  ");
+//      b.append(String.format("%08X ", n.longValue()));
+//      x = x.subtract(n);
+//      count++;
+//    }
+//    return b.insert(0, "[" + count + ":").append("]").toString();
+//  }
+//
+//  private static final int ARRAY_SIZE = 1024; 
+//
+//  @Override
+//  public void write(DataOutput out) throws IOException {
+//    check0to1();
+//
+//    for(Apfloat x = value; x.compareTo(ZERO) > 0; ) {
+//      out.write(ARRAY_SIZE);
+//      for(int i = 0; i < ARRAY_SIZE; i++) {
+//        x = x.multiply(TWOto32);
+//        final Apint n = x.truncate();
+//        x = x.subtract(n);
+//
+//        out.writeInt((int)n.longValue());
+//      }
+//    }
+//    out.write(0);
+//  }
+//
+//  public static class Mod1Fraction_IntArray_Util {
+//    private static final int iaRadix = 16;
+//    private static final Apint iaTWO = new Apint(2, iaRadix);
+//    private static final Apint iaTWOto32 = new Apint(1L << 32, iaRadix);
+// 
+//    private static Apfloat iaNewApfloat(long n) {
+//      return new Apfloat(n, Mod1Fraction_IntArray.FACTORY.getPrecision(), iaRadix);
+//    }
+//
+//    public static void initIntArray(final int[] a,
+//        final long numerator, final long denominator, final long shift) {
+//      Apfloat x = iaNewApfloat(numerator).divide(iaNewApfloat(denominator));
+//      final long q = shift/32L;
+//      if (q < a.length) {
+//        final long r = shift & 0x1FL;
+//        if (r > 0)
+//          x = x.divide(ApintMath.pow(iaTWO, r));
+//  
+//        for(int i = (int)q; i < a.length; i++) {
+//          x = x.multiply(iaTWOto32);
+//          final Apint y = x.truncate();
+//          a[i] = (int)y.longValue();
+//          x = x.subtract(y);
+//        }
+//      }
+//    }
+//  }
+//}
Index: src/examples/org/apache/hadoop/mp/pi/math/Summation.java
===================================================================
--- src/examples/org/apache/hadoop/mp/pi/math/Summation.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/pi/math/Summation.java	(revision 0)
@@ -0,0 +1,355 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.pi.math;
+
+import java.lang.management.ManagementFactory;
+import java.lang.management.ThreadMXBean;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.hadoop.mp.pi.DistBbp;
+import org.apache.hadoop.mp.pi.TaskResult;
+import org.apache.hadoop.mp.util.Combinable;
+import org.apache.hadoop.mp.util.Container;
+import org.apache.hadoop.mp.util.JavaUtil.Timer;
+
+/** Represent the summation \sum \frac{2^e \mod n}{n}. */
+public class Summation implements Container<Summation>, Combinable<Summation> {
+  public final boolean ispositive;
+  /** Variable n in the summation. */
+  public final ArithmeticProgression N;
+  /** Variable e in the summation. */
+  public final ArithmeticProgression E;
+
+  /** Constructor */
+  public Summation(boolean ispositive, ArithmeticProgression N, ArithmeticProgression E) {
+    if (N.getSteps() != E.getSteps()) {
+      throw new IllegalArgumentException("N.getSteps() != E.getSteps(),"
+          + "\n  N.getSteps()=" + N.getSteps() + ", N=" + N
+          + "\n  E.getSteps()=" + E.getSteps() + ", E=" + E);
+    }
+    this.ispositive = ispositive;
+    this.N = N;
+    this.E = E;
+  }
+
+  /** Constructor */
+  Summation(boolean ispositive, long valueN, long deltaN, 
+            long valueE, long deltaE, long limitE) {
+    this(ispositive, valueN, deltaN, valueN - deltaN*((valueE - limitE)/deltaE),
+         valueE, deltaE, limitE);
+  }
+
+  /** Constructor */
+  Summation(boolean ispositive, long valueN, long deltaN, long limitN, 
+            long valueE, long deltaE, long limitE) {
+    this(ispositive, new ArithmeticProgression('n', valueN, deltaN, limitN),
+         new ArithmeticProgression('e', valueE, deltaE, limitE));
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public Summation get() {return this;}
+
+  /** Return the number of steps of this summation */
+  long getSteps() {return E.getSteps();}
+  
+  /** {@inheritDoc} */
+  @Override
+  public String toString() {
+    return (ispositive? "+[": "-[") + N + "; " + E + "]"; 
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public boolean equals(Object obj) {
+    if (obj == this)
+      return true;
+    if (obj != null && obj instanceof Summation) {
+      final Summation that = (Summation)obj;
+      return this.N.equals(that.N) && this.E.equals(that.E);
+    }
+    throw new IllegalArgumentException(obj == null? "obj == null":
+      "obj.getClass()=" + obj.getClass());
+  }
+
+  /** Not supported */
+  @Override
+  public int hashCode() {
+    throw new UnsupportedOperationException();
+  }
+
+  /** Covert a String to a Summation. */
+  public static Summation valueOf(final String s) {
+    final boolean ispositive = s.charAt(0) == '+';
+    int i = 2;
+    int j = s.indexOf("; ", i);
+    if (j < 0)
+      throw new IllegalArgumentException("i=" + i + ", j=" + j + " < 0, s=" + s);
+    final ArithmeticProgression N = ArithmeticProgression.valueOf(s.substring(i, j));
+
+    i = j + 2;
+    j = s.indexOf("]", i);
+    if (j < 0)
+      throw new IllegalArgumentException("i=" + i + ", j=" + j + " < 0, s=" + s);
+    final ArithmeticProgression E = ArithmeticProgression.valueOf(s.substring(i, j));
+    return new Summation(ispositive, N, E);
+  }
+
+  /** Compute the value of the summation. */
+  public Mod1Fraction compute(Timer timer) {
+    return new Computer(timer).run();
+  }
+
+  /** Compute the value of the summation. */
+  public TaskResult compute(int nThreads, Timer timer) {
+    DistBbp.printVersions();
+
+    final ThreadMXBean b = ManagementFactory.getThreadMXBean();
+    final long start = b.getCurrentThreadCpuTime();
+    final Mod1Fraction value = compute(timer);
+    final long duration = b.getCurrentThreadCpuTime() - start;
+    return new TaskResult(this, value, (duration + 500000)/1000000);
+  }
+
+
+  static final long SUB_STEPS = 8;
+
+  private class Computer {
+    private static final long MAX_MODULAR = 1L << 32;
+
+    private long n = N.value;
+    private long e = E.value;
+    private final long ntail;
+    private final Mod1Fraction s = Mod1Fraction.zero();
+
+    final Timer timer;
+
+    private Computer(Timer timer) {
+      this.timer = timer;
+
+      if (E.limit >= 0) {
+        ntail = N.limit;
+      } else if (e <= 0) {
+        ntail = n;
+      } else {
+        final long edelta = -E.delta;
+        final long r = e % edelta;
+        final long q = e / edelta;
+        final long nlimit =  n + (r == 0?q: q+1)* N.delta;
+        ntail = N.limit < nlimit? N.limit: nlimit;
+      }
+    }
+
+    /** Compute the value of the summation. */
+    public Mod1Fraction run() {
+      compute_modular();
+      compute_montgomery();
+      compute_tail();
+      return s;
+    }
+
+    void println(String mess) {
+      if (timer != null) {
+        timer.tick(mess);
+      }
+    }
+
+    /** Compute the value using {@link Modular#mod(long, long)}. */
+    void compute_modular() {
+      final long nlimit = ntail < MAX_MODULAR? ntail: MAX_MODULAR;
+      if (n < nlimit) {
+        final long substepsize = (nlimit - n)/(N.delta*SUB_STEPS);
+        println("compute_modular: n=" + n + ", nlimit=" + nlimit
+            + ", substepsize=" + substepsize + ", " + Summation.this);
+  
+        for(long i = 0; i < SUB_STEPS; ) {
+          for(long j = 0; j < substepsize; j++) {
+            s.addFractionMod1Equal(Modular.mod(e, n), n);
+            n += N.delta;
+            e += E.delta;
+          }
+          
+          i++;
+          println("compute_modular: sub-step=" + i + "/" + SUB_STEPS
+              + ", n=" + n + ", nlimit=" + nlimit + ", " + Summation.this);
+        }
+        for(; n < nlimit; ) {
+          s.addFractionMod1Equal(Modular.mod(e, n), n);
+          n += N.delta;
+          e += E.delta;
+        }
+      }
+    }
+  
+    private final Montgomery montgomery = new Montgomery();
+    /** Compute the value using {@link Montgomery#mod(long)}. */
+    void compute_montgomery() {
+      if (n < ntail) {
+        final long substepsize = (ntail - n)/(N.delta*SUB_STEPS);
+        println("compute_montgomery: n=" + n + ", ntail=" + ntail
+            + ", substepsize=" + substepsize + ", " + Summation.this);
+  
+        for(long i = 0; i < SUB_STEPS; ) {
+          for(long j = 0; j < substepsize; j++) {
+            s.addFractionMod1Equal(montgomery.set(n).mod(e), n);
+            n += N.delta;
+            e += E.delta;
+          }
+          
+          i++;
+          println("compute_montgomery: sub-step=" + i + "/" + SUB_STEPS
+              + ", n=" + n + ", ntail=" + ntail + ", " + Summation.this);
+        }
+        for(; n < ntail; ) {
+          s.addFractionMod1Equal(montgomery.set(n).mod(e), n);
+          n += N.delta;
+          e += E.delta;
+        }
+      }
+    }
+
+    //2^{E}(1/N) < 1/2^p
+    // 2^{E + p} < N
+    //     E + p < log n < log N
+    //
+    //log n >= Long.SIZE - 1 - Long.numberOfLeadingZeros(n)
+    //
+    //Therefore, set E = Long.SIZE - 1 - Long.numberOfLeadingZeros(n) - p
+    void compute_tail() {
+      if (n < N.limit) {
+        final long substepsize = (N.limit - n)/(N.delta*SUB_STEPS);
+        println("compute_tail: n=" + n + ", N.limit=" + N.limit
+            + ", substepsize=" + substepsize + ", " + Summation.this);
+  
+        for(long i = 0; i < SUB_STEPS; ) {
+          for(long j = 0; j < substepsize; j++) {
+            s.addShiftFractionMod1Equal(n, -e);
+            n += N.delta;
+            e += E.delta;
+          }
+  
+          i++;
+          println("compute_tail: sub-step=" + i + "/" + SUB_STEPS
+              + ", n=" + n + ", N.limit=" + N.limit + ", " + Summation.this);
+        }
+        for(; n < N.limit; ) {
+          s.addShiftFractionMod1Equal(n, -e);
+          n += N.delta;
+          e += E.delta;
+        }
+      }
+    }
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public int compareTo(Summation that) {
+    final int de = this.E.compareTo(that.E);
+    if (de != 0) return de;
+    return this.N.compareTo(that.N);
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public Summation combine(Summation that) {
+    if (this.ispositive != that.ispositive)
+      throw new IllegalArgumentException("this.ispositive != that.ispositive"
+          + ",\n  this=" + this
+          + ",\n  that=" + that);
+    if (this.N.delta != that.N.delta || this.E.delta != that.E.delta) 
+      throw new IllegalArgumentException(
+          "this.N.delta != that.N.delta || this.E.delta != that.E.delta"
+          + ",\n  this=" + this
+          + ",\n  that=" + that);
+    if (this.E.limit == that.E.value && this.N.limit == that.N.value) {
+      final Summation s = new Summation(ispositive,
+          new ArithmeticProgression(N.symbol, N.value, N.delta, that.N.limit),
+          new ArithmeticProgression(E.symbol, E.value, E.delta, that.E.limit));
+      return s;
+    }
+    return null;
+  }
+
+  /** Find the remaining terms. */
+  public <T extends Container<Summation>> List<Summation> remainingTerms(List<T> sorted) {
+    final List<Summation> results = new ArrayList<Summation>();
+    Summation remaining = this;
+
+    if (sorted != null)
+      for(Container<Summation> c : sorted) {
+        final Summation sigma = c.get();
+        if (!remaining.contains(sigma))
+          throw new IllegalArgumentException("!remaining.contains(s),"
+              + "\n  remaining = " + remaining
+              + "\n  s         = " + sigma          
+              + "\n  this      = " + this
+              + "\n  sorted    = " + sorted);
+
+        final Summation s = new Summation(sigma.ispositive,
+            sigma.N.limit, N.delta, remaining.N.limit,
+            sigma.E.limit, E.delta, remaining.E.limit);
+        if (s.getSteps() > 0)
+          results.add(s);
+        remaining = new Summation(sigma.ispositive,
+            remaining.N.value, N.delta, sigma.N.value,
+            remaining.E.value, E.delta, sigma.E.value);
+      }
+
+    if (remaining.getSteps() > 0)
+      results.add(remaining);
+  
+    return results;
+  }
+
+  /** Does this contains that? */
+  public boolean contains(Summation that) {
+    return this.ispositive == that.ispositive
+        && this.N.contains(that.N) && this.E.contains(that.E);    
+  }
+
+  /** Partition the summation. */
+  public List<Summation> partition(final int nParts) {
+    final List<Summation> parts = new ArrayList<Summation>();
+    final long steps = (E.limit - E.value)/E.delta + 1;
+
+    long prevN = N.value;
+    long prevE = E.value;
+
+    for(int i = 1; i < nParts; i++) {
+      final long k = (i * steps)/nParts;
+
+      final long currN = N.skip(k);
+      final long currE = E.skip(k);
+      if (currN != prevN || currE != prevE)
+        parts.add(new Summation(ispositive,
+            new ArithmeticProgression(N.symbol, prevN, N.delta, currN),
+            new ArithmeticProgression(E.symbol, prevE, E.delta, currE)));
+
+      prevN = currN;
+      prevE = currE;
+    }
+
+    
+    if (N.limit != prevN || E.limit != prevE)
+      parts.add(new Summation(ispositive,
+          new ArithmeticProgression(N.symbol, prevN, N.delta, N.limit),
+          new ArithmeticProgression(E.symbol, prevE, E.delta, E.limit)));
+    return parts;
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/pi/math/package.html
===================================================================
--- src/examples/org/apache/hadoop/mp/pi/math/package.html	(revision 0)
+++ src/examples/org/apache/hadoop/mp/pi/math/package.html	(revision 0)
@@ -0,0 +1,22 @@
+<html>
+<!--
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+-->
+<body>
+  This package provides useful mathematical library classes
+  for the distbbp program.
+</body>
+</html>
Index: src/examples/org/apache/hadoop/mp/pi/package.html
===================================================================
--- src/examples/org/apache/hadoop/mp/pi/package.html	(revision 0)
+++ src/examples/org/apache/hadoop/mp/pi/package.html	(revision 0)
@@ -0,0 +1,181 @@
+<html>
+<!--
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+-->
+<body>
+  This package consists of a map/reduce application,
+  <i>distbbp</i>,
+  which computes exact binary digits of the mathematical constant &pi;.
+  distbbp is designed for computing the n<sup>th</sup> bit of &pi;,
+  for large n, say n &gt; 100,000,000.
+  For computing the lower bits of &pi;, consider using <i>bbp</i>.
+
+  <h3>The distbbp Program</h3>
+  The main class is DistBbp
+  and the actually computation is done by DistSum jobs.
+  The steps for launching the jobs are:
+ 
+  <ol>
+    <li>Initialize parameters.</li>
+    <li>Create a list of sums.</li>
+    <li>Read computed values from the given local directory.</li>
+    <li>Remove the computed values from the sums.</li>
+    <li>Partition the remaining sums into computation jobs.</li>
+    <li>Submit the computation jobs to a cluster and then wait for the results.</li>
+    <li>Write job outputs to the given local directory.</li>
+    <li>Combine the job outputs and print the &pi; bits.</li>
+  </ol>
+
+<table><tr valign=top><td width=420>
+  <h3>The Bits of &pi;</h3>
+  <p>
+The table on the right are the results computed by distbbp.
+</p>
+<ul>
+<p><li>Row 0 to Row 7
+<ul><li>They were computed by a single machine.</li>
+
+    <li>A single run of Row 7 took several seconds.</li>
+</ul></li></p>
+<p><li>Row 8 to Row 14
+<ul><li>They were computed by a 7600-task-capacity cluster.</li>
+    <li>A single run of Row 14 took 27 hours.</li>
+    <li>The computations in Row 13 and Row 14 were completed on May 20, 2009. 
+        It seems that the corresponding bits were never computed before.</li>
+</ul></li></p>
+<p><li>The first part of Row 15 (<tt>6216B06</tt>)
+
+<ul><li>The first 30% of the computation was done in idle cycles of some 
+        clusters spread over 20 days.</li>
+    <li>The remaining 70% was finished over a weekend on <i>Hammer</i>,
+        a 30,000-task-capacity cluster, which was also used for the
+        <a href="http://developer.yahoo.net/blogs/hadoop/2009/05/hadoop_sorts_a_petabyte_in_162.html">petabyte sort benchmark</a>.</li>
+    <li>The log files are available
+        <a href="https://issues.apache.org/jira/secure/attachment/12408543/1e15log.zip">here</a>.</li>
+    <li>The result was posted in
+        <a href="http://developer.yahoo.net/blogs/hadoop/2009/05/hadoop_computes_the_10151st_bi.html">this YDN blog</a>.</li>
+
+</ul></li></p>
+<p><li>The second part of Row 15 (<tt>D3611</tt>)
+<ul><li>The starting position is 1,000,000,000,000,053, totally 20 bits.</li>
+    <li>Two computations, at positions <i>n</i> and <i>n</i>+4, were performed.
+    <li>A single computation was divided into 14,000 jobs
+        and totally 7,000,000 tasks.
+        It took 208 years of CPU-time
+        or 12 days of cluster (with 7600-task-capacity) time.  </li>
+    <li>The log files are available
+        <a href="https://issues.apache.org/jira/secure/attachment/12412297/D3611.tar.gz">here</a>.</li>
+
+    <li>The computations were completed on June 30, 2009.
+        The last bit, the 1,000,000,000,000,072<sup>nd</sup> bit,
+        probably is the highest bit (or the least significant bit) of &pi;
+        computed ever in the history.</li>
+</ul></li></p>
+
+</td><td width=20></td><td>
+<table border=1 width=400 cellpadding=5>
+<tr><th width=30></th><th>Position <i>n</i></th><th>&pi; bits (in hex) starting at <i>n</i></th></tr>
+
+<tr><td align=right>0</td><td align=right>1</td><td><tt>243F6A8885A3</tt><sup>*</sup></td></tr>
+<tr><td align=right>1</td><td align=right>11</td><td><tt>FDAA22168C23</tt></td></tr>
+<tr><td align=right>2</td><td align=right>101</td><td><tt>3707344A409</tt></td></tr>
+<tr><td align=right>3</td><td align=right>1,001</td><td><tt>574E69A458F</tt></td></tr>
+
+<tr><td align=right>4</td><td align=right>10,001</td><td><tt>44EC5716F2B</tt></td></tr>
+<tr><td align=right>5</td><td align=right>100,001</td><td><tt>944F7A204</tt></td></tr>
+<tr><td align=right>6</td><td align=right>1,000,001</td><td><tt>6FFFA4103</tt></td></tr>
+<tr><td align=right>7</td><td align=right>10,000,001</td><td><tt>6CFDD54E3</tt></td></tr>
+<tr><td align=right>8</td><td align=right>100,000,001</td><td><tt>A306CFA7</tt></td></tr>
+
+<tr><td align=right>9</td><td align=right>1,000,000,001</td><td><tt>3E08FF2B</tt></td></tr>
+<tr><td align=right>10</td><td align=right>10,000,000,001</td><td><tt>0A8BD8C0</tt></td></tr>
+<tr><td align=right>11</td><td align=right>100,000,000,001</td><td><tt>B2238C1</tt></td></tr>
+<tr><td align=right>12</td><td align=right>1,000,000,000,001</td><td><tt>0FEE563</tt></td></tr>
+<tr><td align=right>13</td><td align=right>10,000,000,000,001</td><td><tt>896DC3</tt></td></tr>
+
+<tr><td align=right>14</td><td align=right>100,000,000,000,001</td><td><tt>C216EC</tt></td></tr>
+<tr><td align=right>15</td><td align=right>1,000,000,000,000,001</td><td><tt>6216B06</tt> ... <tt>D3611</tt></td></tr>
+</table>
+
+<p><sup>*</sup>
+By representing &pi; in decimal, hexadecimal and binary, we have
+
+<ul><table><tr>
+  <td>&pi;</td><td>=</td><td><tt>3.1415926535 8979323846 2643383279</tt> ...</td>
+</tr><tr>
+  <td></td><td>=</td><td><tt>3.243F6A8885 A308D31319 8A2E037073</tt> ...</td>
+</tr><tr>
+  <td></td><td>=</td><td><tt>11.0010010000 1111110110 1010100010</tt> ...</td>
+
+</td></tr></table></ul>
+The first ten bits of &pi; are <tt>0010010000</tt>.
+</p>
+</td></tr></table>
+
+
+  <h3>Command Line Usages</h3>
+  The command line format is:
+  <ul><pre>
+$ hadoop org.apache.hadoop.examples.pi.DistBbp \
+         &lt;b&gt; &lt;nThreads&gt; &lt;nJobs&gt; &lt;type&gt; &lt;nPart&gt; &lt;remoteDir&gt; &lt;localDir&gt;</pre></ul>
+  And the parameters are:
+  <ul><table>
+    <tr>
+      <td>&lt;b&gt;</td>
+      <td>The number of bits to skip, i.e. compute the (b+1)th position.</td>
+    </tr>
+    <tr>
+      <td>&lt;nThreads&gt;</td>
+      <td>The number of working threads.</td>
+    </tr>
+    <tr>
+      <td>&lt;nJobs&gt;</td><td>The number of jobs per sum.
+    </tr>
+    <tr>
+      <td>&lt;type&gt;</td><td>'m' for map side job, 'r' for reduce side job, 'x' for mix type.</td>
+    </tr>
+    <tr>
+      <td>&lt;nPart&gt;</td>
+      <td>The number of parts per job.</td>
+    </tr>
+    <tr>
+      <td>&lt;remoteDir&gt;</td>
+      <td>Remote directory for submitting jobs.</td>
+    </tr>
+    <tr>
+      <td>&lt;localDir&gt;</td>
+      <td>Local directory for storing output files.</td>
+    </tr>
+  </table></ul>
+   Note that it may take a long time to finish all the jobs when &lt;b&gt; is large.
+   If the program is killed in the middle of the execution, the same command with
+   a different &lt;remoteDir&gt; can be used to resume the execution.  For example, suppose
+   we use the following command to compute the (10^15+57)th bit of &pi;.
+   <ul><pre>
+$ hadoop org.apache.hadoop.examples.pi.DistBbp \
+	 1,000,000,000,000,056 20 1000 x 500 remote/a local/output</pre></ul>
+   It uses 20 threads to summit jobs so that there are at most 20 concurrent jobs.
+   Each sum (there are totally 14 sums) is partitioned into 1000 jobs.
+   The jobs will be executed in map-side or reduce-side.  Each job has 500 parts.
+   The remote directory for the jobs is remote/a and the local directory
+   for storing output is local/output.  Depends on the cluster configuration,
+   it may take many days to finish the entire execution.  If the execution is killed,
+   we may resume it by
+   <ul><pre>
+$ hadoop org.apache.hadoop.examples.pi.DistBbp \
+         1,000,000,000,000,056 20 1000 x 500 remote/b local/output</pre></ul>
+</body>
+</html>
Index: src/examples/org/apache/hadoop/mp/math/BrentSalamin.java
===================================================================
--- src/examples/org/apache/hadoop/mp/math/BrentSalamin.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/math/BrentSalamin.java	(revision 0)
@@ -0,0 +1,117 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.math;
+import org.apache.hadoop.conf.Configured;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Print;
+import org.apache.hadoop.util.Tool;
+import org.apache.hadoop.util.ToolRunner;
+
+public class BrentSalamin extends Configured implements Tool {
+  public static final String DESCRIPTION = "BrentSalamin algorithm";
+
+  final JavaUtil.Timer timer = new JavaUtil.Timer(true, true);
+  final JavaUtil.WorkGroup workers = new JavaUtil.WorkGroup(BrentSalamin.class.getSimpleName(), 2, null);
+
+  final Zahlen Z = Zahlen.FACTORY.valueOf(32, 1 << 12, 1 << 10);
+  final FixedPointFraction R = FixedPointFraction.FACTORY.valueOf((1 << 16) - Z.digitsPerArray.value, Z);
+
+  final FixedPointFraction.Element a = R.valueOf(1);
+  final FixedPointFraction.Element b = R.valueOf(2).sqrtReciprocalEqual(workers);
+  final FixedPointFraction.Element next_a = R.valueOf(1).plusEqual(b).shiftRightEqual_bits(1);
+  final FixedPointFraction.Element t = R.valueOf(1).shiftRightEqual_bits(2);
+  int e = 0;
+  final FixedPointFraction.Element pi = R.newElement();
+  
+  private boolean computepi = false;
+  
+  synchronized void next() {
+    computepi = false;
+
+    //b_{n+1} = sqrt(a_n b_n)
+    b.multiplyEqual(a, workers);
+    final FixedPointFraction.Element tmp = R.newElement().set(b);
+    b.sqrtReciprocalEqual(workers).multiplyEqual(tmp, workers);
+
+    //t_{n+1} = t_n - 2^e(a_{n+1} - a_n)^2
+    tmp.set(next_a);
+    tmp.negateEqual().plusEqual(a);
+    tmp.multiplyEqual(tmp, workers).shiftLeftEqual_bits(e);
+    t.plusEqual(tmp.negateEqual());
+
+    //a_{n+1}
+    a.set(next_a);
+
+    //a_{n+2} = (a_{n+1} + b_{n+1})/2
+    next_a.plusEqual(b).shiftRightEqual_bits(1);
+    
+    //e = e + 1
+    e++;
+  }
+  
+  synchronized void computePi() {
+    if (!computepi) {
+      //pi = a_{n+2}^2 / t_{n+1}
+      final FixedPointFraction.Element tmp = R.newElement().set(t).reciprocalEqual(workers);
+      pi.set(next_a).multiplyEqual(next_a, workers).multiplyEqual(tmp, workers);
+      computepi = true;
+    }
+  }
+
+  @Override
+  public String toString() {
+    return "\n  a = " + a.toBrief()
+         + "\n  b = " + b.toBrief()
+         + "\n  t = " + t.toBrief()
+         + "\n  e = " + e
+         + "\npi  = " + pi.toBrief();
+  }
+
+  @Override
+  public int run(String[] args) throws Exception {
+    final int nIterations = 20;
+    Print.println("nIterations = " + nIterations);
+
+//    Print.isOutEnabled.set(false);
+//    Print.println(this);
+//    Print.isOutEnabled.set(true);
+
+    for(int i = 0; i < nIterations; i++) {
+      timer.tick("i = " + i);
+      next();
+      Print.printMemoryInfo();
+
+//      Print.println(this);
+    }
+
+    computePi();
+    Print.isOutEnabled.set(false);
+    Print.println();
+    pi.printDetail("pi");
+    Print.isOutEnabled.set(true);
+
+    timer.tick("DONE");
+    return 0;
+  }
+
+  public static void main(String[] args) throws Exception {
+    Print.initLogFile(BrentSalamin.class.getSimpleName());
+    Print.printSystemInfo();
+    System.exit(ToolRunner.run(null, new BrentSalamin(), args));
+  }
+}
Index: src/examples/org/apache/hadoop/mp/math/FixedPointFraction.java
===================================================================
--- src/examples/org/apache/hadoop/mp/math/FixedPointFraction.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/math/FixedPointFraction.java	(revision 0)
@@ -0,0 +1,388 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.math;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Random;
+
+import org.apache.hadoop.mp.util.Checksum;
+import org.apache.hadoop.mp.util.Container;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Parse;
+import org.apache.hadoop.mp.util.Print;
+import org.apache.hadoop.mp.util.Print.Level;
+import org.apache.hadoop.mp.util.serialization.DataSerializable;
+import org.apache.hadoop.mp.util.serialization.StringSerializable;
+
+/**
+ * Fractions with a fixed radix point. 
+ */
+public class FixedPointFraction
+    extends ArbitraryPrecision<FixedPointFraction, FixedPointFraction.Element>
+    implements Container<Zahlen> {
+  private static final int VERSION = -1; 
+  static final Print.Level PRINT_LEVEL = Print.Level.INFO;
+
+  //static final boolean debug = false;
+  //private static Stack<BigInteger> DEBUG_STACK = new Stack<BigInteger>();
+
+  /** The underlying integer set. */
+  final Zahlen Z;
+  /**
+   * The position of the decimal point in term of digits.
+   * Must be a multiple of Z.digitsPerArray.
+   */
+  final int pointPos;
+
+  private FixedPointFraction(final int pointPos, final Zahlen Z) {
+    Print.println("NEW: " + FixedPointFraction.class.getSimpleName()
+        + "(pointPos=" + pointPos
+        + ", Z=" + Z.toBrief() + ")");
+    this.pointPos = pointPos;
+    this.Z = Z;
+
+    Z.digitsPerArray.checkIsMultiple(pointPos);
+  }
+
+  @Override
+  String getKey() {return  pointPos + "," + Z.getKey();}
+  @Override
+  protected Element newElement_private() {return new Element();}
+  @Override
+  public Element random(final int nDigit, final Random r) {
+    final Element e = newElement();
+    e.fraction = Z.random(nDigit, r);
+    return e;
+  }
+
+  @Override
+  public Zahlen get() {return Z;}
+
+  @Override
+  public String toBrief() {
+    return getClass().getSimpleName()
+        + "(pointPos=" + pointPos
+        + ")";
+  }
+
+  @Override
+  public String toString() {
+    return getClass().getSimpleName()
+        + "\n  pointPos = " + pointPos
+        + "\n  Z        = " + Z;
+  }
+
+  @Override
+  public String serialize() {
+    return "pointPos=" + pointPos
+         + ", " + Z.serialize();
+  }
+
+  @Override
+  public Void serialize(DataOutput out) throws IOException {
+    //write version
+    out.writeInt(VERSION);
+    out.writeInt(pointPos);
+    Z.serialize(out);
+    return null;
+  }
+
+  public Element valueOf(final int n) {
+    final Zahlen.Element z = Z.newElement().plusEqual(n);
+    final Element e = newElement();
+    e.fraction = z.shiftLeftEqual_digits(pointPos);
+    return e;
+  }
+
+  public Element valueOf(final Zahlen.Element r) {
+    final Element e = newElement();
+    e.fraction = r;
+    return e;
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  public final class Element
+      extends ArbitraryPrecision<FixedPointFraction, FixedPointFraction.Element>.Element {
+    private Zahlen.Element fraction;
+    
+    Element() {this(Z.newElement());}
+
+    Element(Zahlen.Element fraction) {this.fraction = fraction;}
+
+    @Override
+    Element setZero() {
+      fraction.setZero();
+      return this;
+    }
+    @Override
+    Element set(Element that) {
+      this.fraction.set(that.fraction);
+      return this;
+    }
+    
+    public Zahlen.Element getFraction() {return fraction;}
+    
+    boolean isOne() {
+      return fraction.isOne(pointPos) && fraction.isAllDigitsZero(pointPos);
+    }
+
+    @Override
+    public int compareTo(final Element that) {
+      this.check(that);
+      return this.fraction.compareTo(that.fraction);
+    }
+    
+    private BigDecimal DIVISOR;
+
+    /** For verifying results in testing or debugging. */
+    synchronized BigDecimal toBigDecimal() {
+      if (fraction.isZero())
+        return BigDecimal.ZERO;
+      if (DIVISOR == null)
+        DIVISOR = new BigDecimal(BigInteger.valueOf(Z.digitLimit.value).pow(pointPos));
+      return new BigDecimal(fraction.toBigInteger()).divide(DIVISOR);
+    }
+
+    @Override
+    public Checksum serialize(DataOutput out) throws IOException {
+      FixedPointFraction.this.serialize(out);
+      return fraction.serialize(out);
+    }
+
+    @Override
+    public String toBrief() {
+      final int numOfDigits = fraction.numberOfDigits();
+      return "{fraction=" + fraction.toBrief() + ", pointPos=" + pointPos
+          + ", numOfDigits=" + numOfDigits + "}";
+    }
+    @Override
+    public String toString() {return toBrief();}
+    @Override
+    public void printDetail(final String firstlineprefix) {
+      if (firstlineprefix != null)
+        Print.print(firstlineprefix + ": ");
+      if (PRINT_LEVEL.is(Level.TRACE))
+        fraction.printDetail("fraction");
+      print(10);
+    }
+    @Override
+    public void print(int digitsPerLine) {
+      if (fraction.isZero()) {
+        Print.println("0.0");
+      } else {
+        final int numOfDigits = fraction.numberOfDigits();
+        Print.println((fraction.isPositive()? "+" : "-") + "[pointPos=" + pointPos
+            + ", numOfDigits=" + numOfDigits
+            + ", numOfBts=" + fraction.numberOfBits_long() + ":");
+        if (numOfDigits > pointPos) {
+          Print.print(" ");
+          fraction.printDigits(pointPos, numOfDigits, false, true, digitsPerLine);      
+          Print.println("  .");
+        } else {
+          Print.println(" 0.");
+        }
+        Print.print(" ");
+        fraction.printDigits(0, pointPos, true, false, digitsPerLine);      
+        Print.println("]");
+      }
+    }
+
+    @Override
+    public Element shiftRightEqual_bits(long shift_in_bits) {
+      fraction.shiftRightEqual_bits(shift_in_bits);
+      return this;
+    }
+    @Override
+    public Element shiftLeftEqual_bits(long shift_in_bits) {
+      fraction.shiftLeftEqual_bits(shift_in_bits);
+      return this;
+    }
+    @Override
+    public Element negateEqual() {
+      fraction.negateEqual();
+      return this;
+    }
+    @Override
+    public Element plusEqual(Element that) {
+      this.check(that);
+      this.fraction.plusEqual(that.fraction);
+      return this;
+    }
+    @Override
+    public Element multiplyEqual(final Element that, final JavaUtil.WorkGroup workers) {
+      if (this.fraction.numberOfDigits() + that.fraction.numberOfDigits() > Z.digitsSupported)
+        throw new ArithmeticException("this.fraction.numberOfDigits() + that.fraction.numberOfDigits() > Z.digitsSupported,"
+            + "\n  this.fraction.numberOfDigits() = " + this.fraction.numberOfDigits()
+            + "\n  that.fraction.numberOfDigits() = " + that.fraction.numberOfDigits()
+            + "\n  Z.digitsSupported              = " + Z.digitsSupported);
+      fraction.multiplyEqual(that.fraction, workers);
+      fraction.shiftRightEqual_digits(that.get().pointPos);
+      return this;
+    }
+    
+    /**
+     * Use Newton method to compute reciprocal.
+     * x_{n+1} = x_n(2 - a x_n)
+     */
+    public Element reciprocalEqual(final JavaUtil.WorkGroup workers) {
+      if (fraction.isZero()) {
+        throw new ArithmeticException("fraction.isZero()=" + fraction.isZero());
+      } else if (isOne()) {
+        return this;
+      } else {
+        if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+          Print.beginIndentation("reciprocalEqual: this = " + this + " = " + this.toBigDecimal());
+
+        //handle negative numbers
+        final boolean negative = fraction.isNegative();
+        if (negative) fraction.negateEqual();
+
+        //normalize
+        final int normalize_shift = fraction.normalize4division();
+        final int shift_in_digits = pointPos - fraction.numberOfDigits();
+        final int shift = normalize_shift + (shift_in_digits << (Z.bitsPerDigit.exponent + 1));
+        if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE)) {
+          Print.println("normalize_shift = " + normalize_shift);
+          Print.println("shift_in_digits = " + shift_in_digits);
+          Print.println("shift           = " + shift);
+        }
+
+        fraction.approximateReciprocalEqual(workers);
+
+        if (shift > 0) {
+          fraction.shiftLeftEqual_bits(shift);
+          //printDetail("ERROR");
+          //throw new ArithmeticException("Lossing precision, shift = " + shift);
+        }
+        else
+          fraction.shiftRightEqual_bits(-shift);
+
+        if (negative) fraction.negateEqual();
+
+        if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+          Print.endIndentation("return this = " + this.toBigDecimal());
+        return this;
+      }
+    }
+
+    /**
+     * Use Newton method to compute reciprocal.
+     * x_{n+1} = x_n(2 - a x_n)
+     */
+    public Element sqrtReciprocalEqual(final JavaUtil.WorkGroup workers) {
+      if (fraction.isNonPositive()) {
+        this.printDetail("this");
+        throw new ArithmeticException("fraction.isNonPositive()");
+      } else if (isOne()) {
+        return this;
+      } else {
+        if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+          Print.beginIndentation("sqrtReciprocalEqual: this = " + this.toBigDecimal());
+        
+        final int normalize_shift = fraction.normalize4sqrt();
+        final int n = fraction.numberOfDigits() - 1;
+        final int shift_in_digits = 3*(pointPos - n);
+        final int shift = (normalize_shift >> 1) + (shift_in_digits << (Z.bitsPerDigit.exponent - 1));
+
+        if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE)) {
+          Print.println("normalize_shift  = " + normalize_shift + ", fraction = " + fraction);
+          Print.println("n (degree)       = " + n);
+          Print.println("shift_in_digits  = " + shift_in_digits);
+          Print.println("shift            = " + shift);
+        }
+
+        fraction.approximateSqrtReciprocalEqual(workers);
+
+        if (shift > 0) {
+          fraction.shiftLeftEqual_bits(shift);
+//          printDetail("ERROR");
+//          throw new ArithmeticException("Losing precision, shift = " + shift);
+        }
+        else {
+          fraction.shiftRightEqual_bits(-shift);
+        }
+
+        if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+          Print.endIndentation("return this = " + this.toBigDecimal());
+        return this;
+      }
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  public static final Factory FACTORY = new Factory();
+  public static class Factory 
+      implements DataSerializable.ValueOf<FixedPointFraction>, StringSerializable.ValueOf<FixedPointFraction> {
+    private final Map<String, FixedPointFraction> cache = new HashMap<String, FixedPointFraction>();
+
+    public FixedPointFraction valueOf(final int pointPos, final Zahlen Z) {
+      final String key = pointPos + "," + Z.getKey();
+      FixedPointFraction z = cache.get(key);
+      if (z == null) {
+        cache.put(key, z = new FixedPointFraction(pointPos, Z));
+      }
+      return z;
+    }
+
+    @Override
+    public FixedPointFraction valueOf(DataInput in) throws IOException {
+      final int version = in.readInt();
+      if (version != VERSION) {
+        throw new IOException(version + " = version != VERSION = " + VERSION);
+      } else {
+        final int pointPos = in.readInt();
+        final Zahlen Z = Zahlen.FACTORY.valueOf(in);
+        return valueOf(pointPos, Z);
+      }
+    }
+
+    @Override
+    public FixedPointFraction valueOf(String s) {
+      int i = 0;
+      int j = s.indexOf(", ", i);
+      final int pointPos = Parse.parseIntVariable("pointPos", s.substring(i, j));
+
+      i = j + 2;
+      final Zahlen Z = Zahlen.FACTORY.valueOf(s.substring(i));
+
+      return FACTORY.valueOf(pointPos, Z);
+    }
+  }
+  public static final DataSerializable.ValueOf<Element> ELEMENT_FACTORY
+      = new DataSerializable.ValueOf<Element>() {
+    @Override
+    public Element valueOf(DataInput in) throws IOException {
+      final FixedPointFraction fpf = FACTORY.valueOf(in);
+      final Element e = fpf.newElement();
+      final Zahlen.Element fraction = Zahlen.ELEMENT_FACTORY.valueOf(in);
+      e.fraction = fraction;
+      return e;
+    }
+  };
+  
+  public static void main(String[] args) {
+    String s = "1461501637330902918144401915499223635557982291207";
+    Print.println("s = " + s);
+    BigInteger x = new BigInteger(s);
+    Print.println("x = " + x.toString(16));
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/math/RootOfUnity.java
===================================================================
--- src/examples/org/apache/hadoop/mp/math/RootOfUnity.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/math/RootOfUnity.java	(revision 0)
@@ -0,0 +1,42 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.math;
+
+public class RootOfUnity {
+  final int shift;
+  final boolean negation;
+  
+  /** 
+   * Shifts for the powers of a root of unity over Schonhage-Strassen modulus.
+   */
+  RootOfUnity(final int shift, final boolean negation, int m) {
+    if (shift < m) {
+      this.shift = shift;
+      this.negation = negation;
+    } else {
+      this.shift = shift - m;
+      this.negation = !negation;
+    }
+  }
+
+  @Override
+  public String toString() {
+    return (negation? "-2^" :"2^") + shift;
+  }
+
+}
Index: src/examples/org/apache/hadoop/mp/math/Zahlen.java
===================================================================
--- src/examples/org/apache/hadoop/mp/math/Zahlen.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/math/Zahlen.java	(revision 0)
@@ -0,0 +1,2468 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.math;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.PrintStream;
+import java.math.BigInteger;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Random;
+import java.util.Stack;
+
+import org.apache.hadoop.mp.gmp.GmpMultiplier;
+import org.apache.hadoop.mp.util.Checksum;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Parse;
+import org.apache.hadoop.mp.util.Print;
+import org.apache.hadoop.mp.util.Recycler;
+import org.apache.hadoop.mp.util.serialization.DataSerializable;
+import org.apache.hadoop.mp.util.serialization.StreamSerializable;
+import org.apache.hadoop.mp.util.serialization.StringSerializable;
+
+/**
+ * Zahlen, Z, the set of integers.
+ */
+public class Zahlen extends ArbitraryPrecision<Zahlen, Zahlen.Element>
+    implements StreamSerializable.ValueOf<Zahlen.Element, InputStream> {
+  private static final int VERSION = -1; 
+  static final Print.Level PRINT_LEVEL = Print.Level.INFO;
+
+  static final boolean debug = false;
+  private static ThreadLocal<Stack<BigInteger>> DEBUG_STACK = new ThreadLocal<Stack<BigInteger>>() {
+    @Override
+    protected Stack<BigInteger> initialValue() {
+      return new Stack<BigInteger>();
+    }
+  };
+
+  //choose 1 << 13
+  public static final int BIG_INTEGER_THRESHOLD = 1 << 9;
+  public static final int KARATSUBA_THRESHOLD = 1 << 13;
+
+  private final Recycler.IntArray arrayrecycler;
+  
+  public final PowerOfTwo_int bitsPerDigit; // must be either 8, 16 or 32
+  final PowerOfTwo_long digitLimit;
+  final int digitLimit_mask;
+  public final PowerOfTwo_int digitsPerArray;
+  final int numArrays;
+  final int digitsSupported;
+  final int hexPerDigit;
+  final String hexFormat;
+  
+  private Zahlen(final int bitsPerDigit, final int digitsPerArray, final int numArrays) {
+    Print.println("NEW: " + Zahlen.class.getSimpleName()
+        + "(bitsPerDigit=" + bitsPerDigit
+        + ", digitsPerArray=" + digitsPerArray
+        + ", numArrays=" + numArrays + ")");
+    if (bitsPerDigit % Byte.SIZE != 0)
+      throw new IllegalArgumentException("bitsPerDigit (=" + bitsPerDigit
+          + ") is not a multiple of Byte.SIZE (=" + Byte.SIZE + ")");
+    if (Integer.SIZE < bitsPerDigit || Integer.SIZE % bitsPerDigit != 0)
+      throw new IllegalArgumentException("bitsPerDigit (=" + bitsPerDigit
+          + ") is not a factor of Integer.SIZE (=" + Integer.SIZE + ")");
+
+    this.bitsPerDigit = PowerOfTwo_int.valueOf(bitsPerDigit);
+    this.digitLimit = PowerOfTwo_long.valueOf(1L << this.bitsPerDigit.value);
+    this.digitLimit_mask = (int)digitLimit.mask;
+    this.digitsPerArray = PowerOfTwo_int.valueOf(digitsPerArray);
+    this.numArrays = numArrays;
+    this.digitsSupported = numArrays << this.digitsPerArray.exponent;
+
+    this.hexPerDigit = bitsPerDigit >> 2;
+    this.hexFormat = "%0" + hexPerDigit + "X";
+    this.arrayrecycler = new Recycler.IntArray(RECYCLER_SIZE, this.digitsPerArray.value);
+  }
+
+  @Override
+  String getKey() {return bitsPerDigit + "," + digitsPerArray + "," + numArrays;}
+
+  @Override
+  public String toBrief() {
+    return getClass().getSimpleName()
+        + "(bitsPerDigit=" + bitsPerDigit.toBrief()
+        + ", digitLimit=" + digitLimit.toBrief()
+        + ", digitsPerArray=" + digitsPerArray.toBrief()
+        + ", numArrays=" + numArrays
+        + ")";
+  }
+
+  @Override
+  public String serialize() {
+    return "bitsPerDigit=" + bitsPerDigit.value
+         + ", digitsPerArray=" + digitsPerArray.value
+         + ", numArrays=" + numArrays;
+  }
+
+  @Override
+  public String toString() {
+    return getClass().getSimpleName()
+        + "\n  bitsPerDigit    = " + bitsPerDigit
+        + "\n  digitLimit      = " + digitLimit
+        + "\n  digitsPerArray  = " + digitsPerArray
+        + "\n  numArrays       = " + numArrays
+        + "\n  digitsSupported = " + digitsSupported;
+  }
+
+  @Override
+  public Void serialize(DataOutput out) throws IOException {
+    //write version
+    out.writeInt(VERSION);
+
+    bitsPerDigit.serialize(out);
+    digitsPerArray.serialize(out);
+    out.writeInt(numArrays);
+    return null;
+  }
+
+  @Override
+  protected Element newElement_private() {return new Element();}
+  /////////////////////////////////////////////////////////////////////////////
+  @Override
+  public Element valueOf(final InputStream in) throws IOException {
+    final Element e = newElement();
+    e.positive = true;
+
+    long hexcount = 0;
+    for(int c; (c = in.read()) != '\n'; ) {
+//      Print.println("c = " + (char)c);
+      hexcount *= 10;
+      hexcount += Parse.char2int(c);
+    }
+    e.nDigits = (((int)hexcount - 1)>> (bitsPerDigit.exponent - 2)) + 1;
+
+//    Print.println("e.nDigits = " + e.nDigits);
+    for(int i = e.nDigits - 1; hexcount > 0;) {
+      final int q = i >> digitsPerArray.exponent;
+      e.digits[q] = arrayrecycler.newObject();
+
+      for(int r = i & digitsPerArray.mask; r >= 0; r--, i--) {
+        int d = 0;
+        for(int j = ((int)hexcount - 1) % hexPerDigit; j >= 0; j--, hexcount--) {
+          d <<= 4;
+          final int c = in.read();
+//          Print.println("x = " + (char)c + ", hexcount=" + hexcount + ", i=" + i);
+          d += Parse.char2int(c);
+        }
+        e.digits[q][r] = d;
+      }
+    }
+    if (in.read() != '\n') {
+      throw new IllegalArgumentException("Expected <eol>.");
+    }
+    return e;
+  }
+
+  /** Return a positive element with nDigit or less digits */
+  public Element valueOf(boolean positive, final int[] digits) {
+    for (int i = 0; i < digits.length; i++) {
+      if (digits[i] < 0 || digits[i] >= digitLimit.value) {
+        throw new RuntimeException("digits[i] < 0 || digits[i] >= digitLimit.value, i="
+            + i + ", digits[i]=" + digits[i]);
+      }
+    }
+    
+    final Element e = newElement();
+    e.positive = positive;
+    e.nDigits = digits.length;
+    
+    int k = 0;
+    for (int i = 0; i < e.nDigits;) {
+      final int[] d = arrayrecycler.newObject();
+      e.digits[i >> digitsPerArray.exponent] = d;
+
+      for (int j = 0; i < e.nDigits && j < digitsPerArray.value; i++, j++) {
+        d[j] = digits[k++];
+      }
+    }
+    return e;
+  }
+
+  /** Return a positive element with nDigit or less digits */
+  public Element random(final int nDigit, final Random r) {
+    final Element e = newElement();
+    e.positive = true;
+    e.nDigits = nDigit;
+
+    for (int i = 0; i < nDigit;) {
+      final int[] d = arrayrecycler.newObject();
+      e.digits[i >> digitsPerArray.exponent] = d;
+
+      for (int j = 0; i < nDigit && j < digitsPerArray.value; i++, j++) {
+        d[j] = r.nextInt() & digitLimit_mask;
+      }
+    }
+    e.trimLeadingZeros();
+    return e;
+  }
+  
+  /////////////////////////////////////////////////////////////////////////////
+  public interface Multiplier {
+    Zahlen.Element multiply(
+        final Zahlen.Element l, final Zahlen.Element r) throws Exception;
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  /** Elements in Z */
+  public final class Element
+      extends ArbitraryPrecision<Zahlen, Zahlen.Element>.Element
+      implements StreamSerializable<PrintStream, PrintStream> {
+    /** Is this an positive integer?
+     *  Note that positive may be true or false for zero.
+     */
+    private boolean positive = false;
+    /** Digits stored in a 2d-array */
+    private final int[][] digits = new int[numArrays][];
+    /** Total number of digits, not including leading zeros, not digits.length */
+    private int nDigits = 0;
+
+    /** Only {@link #newElement_private()} is allow to call constructor. */ 
+    private Element() {}
+
+    boolean isOne(int digitPos) {
+      return digitPos < nDigits
+          && digits[digitPos >> digitsPerArray.exponent][digitPos & digitsPerArray.mask] == 1;
+    }
+    boolean isAllDigitsZero(final int endDigitPos) {
+      if (endDigitPos >= nDigits) {
+        throw new IllegalArgumentException(endDigitPos
+            + " = endDigitPos >= nDigits = " + nDigits);
+      }
+      
+      final int lastq = (endDigitPos - 1) >> digitsPerArray.exponent;
+      for(int q = 0; q < lastq; q++) {
+        for(int r = 0; r < digitsPerArray.value; r++)
+          if (digits[q][r] != 0)
+            return false;
+      }
+
+      if (lastq >= 0) {
+        final int lastr = (endDigitPos - 1) & digitsPerArray.mask;
+        for(int r = 0; r <= lastr; r++)
+          if (digits[lastq][r] != 0)
+            return false;
+      }
+
+      return true;
+    }
+
+    @Override
+    public Element setZero() {
+      this.positive = true;
+      this.nDigits = 0;
+      clearArrays(0);
+      return this;
+    }
+    @Override
+    public Element set(final Element that) {
+      this.positive = that.positive;
+      this.nDigits = that.nDigits;
+      int i = 0;
+      for (; i < that.digits.length && that.digits[i] != null; i++) {
+        if (this.digits[i] == null)
+          this.digits[i] = arrayrecycler.newObject();
+        System.arraycopy(that.digits[i], 0, this.digits[i], 0, that.digits[i].length);
+      }
+      clearArrays(i);
+      return this;
+    }
+
+    @Override
+    public Checksum serialize(final DataOutput out) throws IOException {
+      //write Zahlen, compute checksum
+      final Checksum c = Checksum.getChecksum();
+      out.write(c.update(Zahlen.this));
+      out.writeBoolean(c.update(positive));
+      
+      //write digits
+      out.writeInt(c.update(nDigits));
+      int q = 0;
+      int r = 0;
+      if (bitsPerDigit.value <= Integer.SIZE) {
+        for(int i = 0; i < nDigits; i++) {
+          out.writeInt(c.update((int)digits[q][r]));
+          
+          if (++r == digits[q].length) {
+            r = 0;
+            q++;
+          }
+        }
+      } else {
+        for(int i = 0; i < nDigits; i++) {
+          out.writeLong(c.update(digits[q][r]));
+          
+          if (++r == digits[q].length) {
+            r = 0;
+            q++;
+          }
+        }
+      }
+      
+      //write checksum
+      c.writeDigest(out);
+      return c;
+    }
+
+    @Override
+    public int compareTo(Element that) {
+      if (this == that || (this.nDigits == 0 && that.nDigits == 0)) {
+        return 0;
+      } else if (this.positive != that.positive) {
+        return this.positive? 1: -1;
+      } else {
+        final int d = this.compareMagnitudeTo(that);
+        if (d > 0)
+          return positive? 1: -1;
+        else if (d < 0)
+          return positive? -1: 1;
+        else
+          return 0;
+      }
+    }
+
+    public int compareMagnitudeTo(Element that) {
+      if (this == that || (this.nDigits == 0 & that.nDigits == 0)) {
+        return 0;
+      } else if (this.nDigits > that.nDigits) {
+        return 1;
+      } else if (this.nDigits < that.nDigits) {
+        return -1;
+      } else {
+        int r = (nDigits - 1) & digitsPerArray.mask;
+        for(int q = (nDigits - 1) >> digitsPerArray.exponent; q >= 0; q--) {
+          final int[] d = this.digits[q];
+          final int[] that_d = that.digits[q];
+
+          for(; r >= 0; r--)
+            if (d[r] != that_d[r])
+              return (d[r] & digitLimit.mask) > (that_d[r] & digitLimit.mask)? 1: -1;
+          
+          r = digitsPerArray.mask;
+        }
+        return 0;
+      }
+    }
+
+    public Element[] split(final int bitsPerElement, final int parts) {
+//      Print.beginIndentation("split(bitsPerElement=" + bitsPerElement + ", parts=" + parts + ") this = " + this);
+      bitsPerDigit.checkIsMultiple(bitsPerElement);
+
+      final Element[] elements = new Element[parts];
+      for (int i = 0; i < elements.length; i++)
+        elements[i] = newElement();
+      if (this.nDigits == 0)
+        return elements;
+
+      final int digitsPerElement = bitsPerElement >> bitsPerDigit.exponent;
+//      Print.println("digitsPerElement=" + digitsPerElement);
+      int q = 0, r = 0;
+      int[] a = this.digits[q];
+      int i = 0;
+      for (int d = 0; d < this.nDigits;) {
+        int j = 0;
+        for (; d < this.nDigits && j < digitsPerElement;) {
+          final int[] array = arrayrecycler.newObject();
+          for (int k = 0; d < this.nDigits && j < digitsPerElement && k < array.length; d++, j++, k++) {
+            array[k] = a[r];
+//            Print.println("array[" + k + "] = a[" + r + "] = " + array[k]);
+
+            if (++r == digitsPerArray.value) {
+              r = 0;
+              q++;
+              a = digits[q];   //may be null 
+            }
+          }
+//          Print.println("  i=" + i + ", j=" + j + ", d=" + d);
+          elements[i].digits[(j - 1) >> digitsPerArray.exponent] = array;
+        }
+        elements[i].positive = this.positive;
+        elements[i].nDigits = j;
+        elements[i].trimLeadingZeros();
+//        Print.println("elements[" + i + "] = " + elements[i] + ", d=" + d);
+        i++;
+      }
+
+//      Print.endIndentation("return");
+      return elements;
+    }
+
+    public Element[] splitAndReclaim(final int digitsPerElement, final SchonhageStrassen schonhagestrassen) {
+//    Print.beginIndentation("split(bitsPerElement=" + bitsPerElement + ", parts=" + parts + ") this = " + this);
+      digitsPerArray.checkIsMultiple(digitsPerElement);
+
+      final Element[] elements = new Element[schonhagestrassen.D.value];
+      for (int i = 0; i < elements.length; i++)
+        elements[i] = schonhagestrassen.Z.newElement();
+      if (this.nDigits > 0) {
+        final int arraysPerElement = digitsPerElement >> digitsPerArray.exponent;
+        boolean done = false;
+        int a = 0;
+        for(int i = 0; !done && i < elements.length; i++) {
+          elements[i].positive = this.positive;
+          for(int j = 0; !done && j < arraysPerElement; j++) {
+            elements[i].digits[j] = this.digits[a];
+            this.digits[a] = null;
+            done = elements[i].digits[j] == null;
+            if (!done) {
+              elements[i].nDigits += digitsPerArray.value;
+            }
+            a++;
+          }
+          elements[i].trimLeadingZeros();
+        }
+      }
+    
+//      Print.endIndentation("return");
+      this.reclaim();
+      return elements;
+    }
+    
+    public Element combine(final Element[] elements, final int digitsPerElement) {
+      if (!isZero()) {
+        setZero();
+      }
+      positive = elements[0].positive;
+      int[] d = arrayrecycler.newObject();
+      digits[0] = d;
+      int q = 0;
+      int r = 0;
+      for(int i = 0; i < elements.length; i++) {
+        if (!elements[i].isZero() && elements[i].positive != positive)
+          throw new RuntimeException("elements[" + i + "] = " + elements[i]);
+        for(int j = 0; j < digitsPerElement; j++) {
+          if (j < elements[i].nDigits)
+            d[r] = elements[i].digits[j >> digitsPerArray.exponent][j & digitsPerArray.mask];
+          
+          if (++r == digitsPerArray.value) {
+            r = 0;
+            if (++q < digits.length)
+              digits[q] = d = arrayrecycler.newObject();
+          }
+        }
+        
+        nDigits += digitsPerElement;
+      }
+      trimLeadingZeros();
+      return this;
+    }
+
+    /** Clear all arrays above or equal to the start index. */
+    private void clearArrays(final int startindex) {
+      for(int i = startindex; i < digits.length && digits[i] != null; i++) {
+        arrayrecycler.reclaim(digits[i]);
+        digits[i] = null;
+      }
+    }
+
+    private void set(final BigInteger x) {
+      if (PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.beginIndentation("set(x=" + x.toString(16)+ ")");
+      final int cmp = x.compareTo(BigInteger.ZERO);
+      positive = cmp >= 0;
+
+      if (cmp == 0) {
+        clearArrays(0);
+        nDigits = 0;
+      } else {
+        final int bytePerDigit = bitsPerDigit.value >> 3;
+        final byte[] bytes = (positive? x: x.negate()).toByteArray();
+
+
+        if (PRINT_LEVEL.is(Print.Level.DEBUG)) {
+          Print.println("bytes.length=" + bytes.length);
+          Print.println(Parse.byteArray2string(bytes));
+        }
+
+        int[] d = digits[0];
+        if (d == null)
+          digits[0] = d = arrayrecycler.newObject();
+
+        int i = bytes.length - 1;
+        int starti = bytes[0] == 0? 1: 0;
+        nDigits = (i - starti)/bytePerDigit + 1;
+        if (PRINT_LEVEL.is(Print.Level.DEBUG)) {
+          Print.println("i     =" + i);
+          Print.println("nDigit=" + nDigits);
+        }
+
+        d[0] = bytes[i--] & 0xFF;
+        int j = 1;
+        for(; i >= starti && j < bytePerDigit; j++) {
+          d[0] |= (bytes[i--] & 0xFFL) << (j << 3);
+        }
+        
+        int q = 1;
+        int r = 0;
+        for(; i >= starti;) {
+          if (++r == digitsPerArray.value) {
+            r = 0;
+            if (digits[q] == null)
+              digits[q] = arrayrecycler.newObject();
+            d = digits[q];
+            ++q;
+          }
+
+          if (i >= starti)
+            d[r] = bytes[i--] & 0xFF;
+          for(j = 1; i >= starti && j < bytePerDigit; j++) {
+            d[r] |= (bytes[i--] & 0xFFL) << (j << 3);
+          }
+        }
+        if (++r < d.length)
+          Arrays.fill(d, r, d.length, 0);
+
+        if (q < digits.length)
+          clearArrays(q);
+      }
+
+      //this.print(8, Print.out);
+      if (debug) {
+        final BigInteger c = toBigInteger();
+        if (!c.equals(x))
+          throw new RuntimeException("!c.equals(x)"
+              + "\n c = " + c.toString(16)
+              + "\n x = " + x.toString(16));
+      }
+      if (PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.endIndentation("set return " + this);
+    }
+
+    /** Is this > 0? */
+    public boolean isPositive() {return nDigits > 0 && positive;}
+    /** Is this < 0? */
+    public boolean isNegative() {return nDigits > 0 && !positive;}
+    /** Is this >= 0? */
+    public boolean isNonNegative() {return nDigits == 0 || positive;}
+    /** Is this <= 0? */
+    public boolean isNonPositive() {return nDigits == 0 || !positive;}
+    /** Is this == 0? */
+    public boolean isZero() {return nDigits == 0;}
+    /** Is this == 0? */
+    public boolean isOne() {return nDigits == 1 && digits[0][0] == 1L;}
+
+    public int numberOfDigits() {return nDigits;}
+    
+    /** @return ceiling(log_2 |n|),*/
+    public long numberOfBits_long() {
+      if (isZero())
+        return 0;
+
+      final int i = nDigits - 1;
+//this.print(10, Print.out);
+      final int last = digits[i >> digitsPerArray.exponent][i & digitsPerArray.mask];
+      return ((long)nDigits << bitsPerDigit.exponent) - bitsPerDigit.value
+          + Integer.SIZE - Integer.numberOfLeadingZeros(last);
+    }
+
+    public int numberOfBits_int() {
+      return JavaUtil.toInt(numberOfBits_long());
+    }
+    
+    public int toInt() {
+      if (isZero())
+        return 0;
+      if (nDigits > 1) {
+        throw new IllegalArgumentException(nDigits + " = nDigits > 1");
+      }
+      if (positive) {
+        final long d = digits[0][0] & digitLimit.mask;
+        if (d > Integer.MAX_VALUE)
+          throw new IllegalArgumentException(d + " = d > Integer.MAX_VALUE");
+        return (int)d;
+      } else {
+        final long d = -(digits[0][0] & digitLimit.mask);
+        if (d < Integer.MIN_VALUE)
+          throw new IllegalArgumentException(d + " = d < Integer.MIN_VALUE");
+        return (int)d;
+      }
+    }
+
+    public BigInteger toBigInteger() {
+      if (isZero())
+        return BigInteger.ZERO;
+
+      final long size = ((numberOfBits_long() - 1) >> 3) + 1;
+      if (size > Integer.MAX_VALUE) {
+        throw new IllegalArgumentException("size = " + size + " > Integer.MAX_VALUE = "
+            + Integer.MAX_VALUE);
+      }
+      final byte[] bytes = new byte[(int)size];
+      int k = bytes.length;
+      for (int i = 0; i < digits.length && digits[i] != null; i++)
+        for (int n : digits[i])
+          for (int j = 0; k > 0 && j < bitsPerDigit.value; j += Byte.SIZE)
+            bytes[--k] = (byte)(n >>> j);
+      //Print.println("bytes.length = " + bytes.length + ", bytes = " + Parse.byteArray2string(bytes));
+      return new BigInteger(positive ? 1: -1, bytes);
+    }
+
+    @Override
+    public void print(final int digitsPerLine) {
+      if (isZero())
+        Print.println("0");
+
+      Print.print((positive? "+" : "-") + "[nDigits=" + nDigits + ":\n ");
+      printDigits(0, nDigits, false, true, digitsPerLine);      
+      Print.println("]");
+    }
+
+    public void print(final int startdigit, final int enddigit, final int digitsPerLine) {
+      if (isZero())
+        Print.println("0");
+
+      Print.print("digits[" + startdigit + ", " + enddigit + ":\n ");
+      printDigits(startdigit, enddigit, false, true, digitsPerLine);      
+      Print.println("]");
+    }
+
+    void printDigits(int startdigit, final int enddigit,
+        final boolean leadingZeros, final boolean trailingZeros, final int digitsPerLine) {
+      if (!leadingZeros && enddigit > nDigits) {
+        throw new IllegalArgumentException(enddigit + "=enddigit>nDigit="
+            + nDigits + " && trailingZeros=" + trailingZeros);
+      } else if (!trailingZeros && startdigit > 0) {
+        throw new IllegalArgumentException(startdigit
+            + "=startdigit>0 && trailingZeros=" + trailingZeros);
+      }
+
+      int i = enddigit - 1;
+      int k = 0;
+      //print leading zeros
+      for (; i >= nDigits; i--) {
+        Print.print(" ");
+        Print.print(String.format(hexFormat, 0));
+        if (++k == digitsPerLine) {
+          k = 0;
+          Print.print("\n ");
+        }
+      }
+      
+      if (!trailingZeros) {
+        //find the least non-zero digit
+        int q = 0;
+        int r = 0;
+        for(boolean found = false; !found && startdigit <= i; ) {
+          if (digits[q][r] != 0)
+            found = true;
+          else {
+            startdigit++;
+            if (++r == digitsPerArray.value) {
+              r = 0;
+              q++;
+            }            
+          }
+        }        
+      }
+
+      int q = i >> digitsPerArray.exponent;
+      int r = i & digitsPerArray.mask;
+      for (; i >= startdigit && q >= 0; q--) {
+        for (; i >= startdigit && r >= 0; r--) {
+          Print.print(" ");
+          Print.print(String.format(hexFormat, digits[q][r]));
+          i--;
+          if (++k == digitsPerLine) {
+            k = 0;
+            Print.print("\n ");
+          }
+        }
+        r = digitsPerArray.value - 1;
+      }
+      if (k > 0)
+        Print.println();
+    }
+
+    /** For {@link GmpMultiplier} */
+    @Override
+    public PrintStream serialize(final PrintStream out) {
+      return printDigits(out, 0, nDigits, false, true);      
+    }
+
+    PrintStream printDigits(final PrintStream out, int startdigit, final int enddigit,
+        final boolean leadingZeros, final boolean trailingZeros) {
+      if (!leadingZeros && enddigit > nDigits) {
+        throw new IllegalArgumentException(enddigit + "=enddigit>nDigit="
+            + nDigits + " && trailingZeros=" + trailingZeros);
+      } else if (!trailingZeros && startdigit > 0) {
+        throw new IllegalArgumentException(startdigit
+            + "=startdigit>0 && trailingZeros=" + trailingZeros);
+      }
+
+      int i = enddigit - 1;
+      //print leading zeros
+      for (; i >= nDigits; i--) {
+        final String s = String.format(hexFormat, 0);
+        out.print(s);
+//        Print.println("L = " + s);
+      }
+      
+      if (!trailingZeros) {
+        //find the least non-zero digit
+        int q = 0;
+        int r = 0;
+        for(boolean found = false; !found && startdigit <= i; ) {
+          if (digits[q][r] != 0)
+            found = true;
+          else {
+            startdigit++;
+            if (++r == digitsPerArray.value) {
+              r = 0;
+              q++;
+            }            
+          }
+        }        
+      }
+
+      int q = i >> digitsPerArray.exponent;
+      int r = i & digitsPerArray.mask;
+      for (; i >= startdigit && q >= 0; q--) {
+        for (; i >= startdigit && r >= 0; r--) {
+          final String s = String.format(hexFormat, digits[q][r]);
+          out.print(s);
+//          Print.println("s = " + s);
+          i--;
+        }
+        r = digitsPerArray.value - 1;
+      }
+      return out;
+    }
+
+    @Override
+    public String toString() {
+      final String s = toOneLineDetails();
+      checkDigits();
+      return s;
+    }
+
+    public String toOneLineDetails() {
+      if (isZero())
+        return "0";
+
+      final StringBuilder b = new StringBuilder(positive ? "+" : "-");
+      int r = (nDigits - 1) & digitsPerArray.mask;
+      for (int q = (nDigits - 1) >> digitsPerArray.exponent; q >= 0; q--) {
+        for (; r >= 0; r--)
+          b.append(" ").append(String.format(hexFormat, digits[q][r]));
+        if (q > 0)
+          b.append(",");
+        r = digitsPerArray.value - 1;
+      }
+      b.append("(").append(nDigits).append(
+          nDigits <= 1 ? " digit, " : " digits, ");
+      final long bits = numberOfBits_long();
+      b.append(bits).append(bits <= 1L? " bit)" : " bits)");
+      return b.toString();
+    }
+
+    @Override
+    public String toBrief() {
+      if (isZero())
+        return "0";
+
+      final StringBuilder b = new StringBuilder(positive ? "+" : "-");
+      
+      int i = nDigits - 1;
+      for (int count = 0; count < 5 && i >= 0; count++, i--) {
+        final int q = i >> digitsPerArray.exponent;
+        final int r = i & digitsPerArray.mask;
+        b.append(" ").append(String.format(hexFormat, digits[q][r]));
+        if (r == 0 && q > 0) {
+          b.append(",");
+        }
+      }
+      if (i >= 5) {
+        b.append(" ... ");
+        i = 4;
+      }
+      for (int count = 0; count < 5 && i >= 0; count++, i--) {
+        final int q = i >> digitsPerArray.exponent;
+        final int r = i & digitsPerArray.mask;
+        b.append(" ").append(String.format(hexFormat, digits[q][r]));
+        if (r == 0 && q > 0) {
+          b.append(",");
+        }
+      }
+      b.append(" (").append(Parse.long2string(nDigits)).append(
+          nDigits <= 1 ? " digit, " : " digits, ");
+      final long bits = numberOfBits_long();
+      b.append(Parse.long2string(bits)).append(bits <= 1L? " bit)" : " bits)");
+      return b.toString();
+    }
+
+    @Override
+    public void printDetail(final String firstlineprefix) {
+      if (firstlineprefix != null)
+        Print.print(firstlineprefix + ": ");
+      Print.println("positive=" + positive
+          + ", nDigit=" + nDigits
+          + ", numberOfBits()=" + numberOfBits_long()
+          + ", digits = [#=" + digits.length + ":");
+      int j = digits.length - 1;
+      for(; j >= 0 && digits[j] == null; j--);
+      if (j < digits.length - 1)
+        Print.println("null: " + (digits.length-1) + " - " + (j+1));
+
+      for(; j >= 0; j--) {
+        Print.print(j + ": ");
+        final int[] d = digits[j];
+        for (int i = d.length - 1; i >= 0; i--) {
+          Print.print(String.format(hexFormat, d[i]));
+          Print.print(" ");
+          if (i % 50 == 0) {
+            Print.println();
+            Print.print("   ");
+          }
+        }
+        Print.println();
+      }
+      Print.println("]");
+    }
+
+    private void checkNonNegative() {
+      if (isNegative()) {
+        printDetail("ERROR");
+        throw new ArithmeticException("isNegative()");
+      }
+    }
+
+    private void checkDigits() {
+      if (nDigits == 0) {
+        if (digits.length != 0 && digits[0] != null) {
+          printDetail("ERROR");
+          throw new RuntimeException("nDigit == 0 but digits[0] != null");
+        }
+      } else {
+        //check leading digits
+        int i = nDigits - 1;
+        final int q = i >> digitsPerArray.exponent;
+        int[] d = digits[q];
+        int r = i & digitsPerArray.mask;
+        if (d[r] == 0) {
+          printDetail("ERROR");
+          throw new RuntimeException("Leading digit = "
+              + d[i & digitsPerArray.mask]);
+        }
+        
+        int j = digits.length - 1;
+        for(; j >= 0 && digits[j] == null; j--);
+        if (j != q) {
+          printDetail("ERROR");
+          throw new RuntimeException(j + " = j != q = " + q);
+        }
+        for(r++; r < d.length; r++)
+          if (d[r] != 0) {
+            printDetail("ERROR");
+            throw new RuntimeException("d[" + r + "] != 0");
+          }
+        
+        //check digit range
+        for(; i >= 0; i--) {
+          r = i & digitsPerArray.mask;
+          if ((bitsPerDigit.value < Integer.SIZE && d[r] < 0) || d[r] >= digitLimit.value) {
+            printDetail("ERROR");
+            throw new RuntimeException("d[r] < 0 || d[r] >= digitLimit.value, d["
+                + r + "] = " + d[r]);
+          }
+          if(--r < 0) {
+            r = digitsPerArray.mask;
+            d = digits[i >> digitsPerArray.exponent];
+          }
+          
+        }
+      }
+    }
+
+    private void trimLeadingZeros() {
+//      if (PRINT_LEVEL.is(Print.Level.TRACE))
+//        Print.beginIndentation("trimLeadingZeros(), this=" + toOneLineDetails());
+
+      clearArrays(((nDigits - 1) >> digitsPerArray.exponent) + 1);
+
+      //re-compute nDigits
+      for(; nDigits != 0; ) {
+        final int q = (nDigits - 1) >> digitsPerArray.exponent;
+        final int[] d = digits[q];
+        if (d == null) {
+          nDigits = q << digitsPerArray.exponent;
+        } else {
+          for (int i = (nDigits - 1) & digitsPerArray.mask; nDigits > 0 && i >= 0; i--) {
+            if (d[i] != 0) {
+//              if (PRINT_LEVEL.is(Print.Level.TRACE))
+//                Print.endIndentation("trimLeadingZeros 1returns " + this);
+              return;
+            }
+            nDigits--;
+          }
+          digits[q] = null;
+        }
+      }
+
+//      if (PRINT_LEVEL.is(Print.Level.TRACE))
+//        Print.endIndentation("trimLeadingZeros 2returns " + this);
+    }
+
+    public Element ssMultiplyEqual(RootOfUnity z, final int e) {
+      if (isZero())
+        return this;
+
+      if (PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.beginIndentation("ssMultiplyEqual(z=" + z + ", e=" + e + "), this=" + this);
+      checkNonNegative();
+
+      bitsPerDigit.checkIsMultiple(e);
+
+      if (z.shift != 0) {
+        shiftLeftEqual_bits(z.shift);
+        ssModEqual(e);
+      }
+      if (z.negation) {
+        negateEqual();
+        ssModEqualByAddition(e);
+      }
+
+      if (PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.endIndentation("ssMultiplyEqual returns " + this);
+      checkNonNegative();
+      return  this;
+    }
+
+    /**
+     * Plus equals Schonhage-Strassen modulus, i.e. this += 2^e + 1.
+     */
+    Element ssModEqualByAddition(final int e) {
+      if (PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.beginIndentation("ssPlusEqual(e=" + e + "), this=" + toOneLineDetails());
+  
+      if (isNegative()) {
+        if (debug)
+          DEBUG_STACK.get().push(this.toBigInteger());
+  
+        plusEqual_differentSign(1, e >> bitsPerDigit.exponent);
+        //Printer.println(this.toDetails());
+        if (positive)
+          plusEqual_sameSign(1, 0);
+        else
+          plusEqual_differentSign(1, 0);
+  
+        if (debug) {
+          final BigInteger a = DEBUG_STACK.get().pop();
+          final BigInteger c = this.toBigInteger();
+          final BigInteger ssModular = BigInteger.ONE.shiftLeft(e).add(BigInteger.ONE);
+          final BigInteger expected = a.compareTo(BigInteger.ZERO) < 0?
+              a.add(ssModular): a;
+          if (!c.equals(expected))
+            throw new RuntimeException(expected.toString(16) + " != c"
+                + "\nssModular = " + ssModular.toString(16)
+                + "\na = " + a.toString(16)
+                + "\nc = " + c.toString(16) + " = " + this);
+        }
+      }
+  
+      if (PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.endIndentation("ssPlusEqual returns " + this);
+      checkNonNegative();
+      return this;
+    }
+
+    /**
+     * Mod Schonhage-Strassen modulus given 0 <= this < 2M, where M = 2^e + 1)
+     */
+    Element ssModEqualBySubstraction(int e) {
+      if (PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.beginIndentation("ssModEqualBySubstraction(" + e + "), this=" + this);
+      checkNonNegative();
+      bitsPerDigit.checkIsMultiple(e);
+
+      final int startDigit = e >> bitsPerDigit.exponent;
+      if (startDigit >= nDigits) {
+        if (PRINT_LEVEL.is(Print.Level.DEBUG))
+          Print.println("trivial: " + startDigit + " = startDigit > nDigit = " + nDigits);
+      } else {
+        if (startDigit != nDigits - 1)
+          throw new IllegalArgumentException(startDigit
+              + " = startDigit != nDigit - 1, nDigit = " + nDigits);
+        digits[startDigit >> digitsPerArray.exponent][startDigit & digitsPerArray.mask]--;
+        trimLeadingZeros();
+        if (!isZero()) {
+          plusEqual(-1);
+        } else {
+          plusEqual(1).shiftLeftEqual_digits(startDigit);
+        }
+      }
+
+      if (PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.endIndentation("ssModEqualBySubstraction returns " + this);
+      checkNonNegative();
+      return this;
+    }
+
+    /** Mod Schonhage-Strassen modulus, i.e. mod (2^e + 1) */
+    Element ssModEqual(int e) {
+      if (PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.beginIndentation("ssModEqual(" + e + "), this=" + this);
+      checkNonNegative();
+
+      if (debug)
+        DEBUG_STACK.get().push(this.toBigInteger());
+
+      final int startDigit = e >> bitsPerDigit.exponent;
+      if (startDigit > nDigits) {
+        if (PRINT_LEVEL.is(Print.Level.DEBUG))
+          Print.println("trivial: " + startDigit + " = startDigit > nDigit = " + nDigits);
+      } else {
+        final Element higher = extractHigherDigits(startDigit);
+        higher.negateEqual();
+        clearHigherDigits(startDigit);
+        plusEqual(higher);
+        ssModEqualByAddition(e);
+      }
+
+      if (debug) {
+        final BigInteger a = DEBUG_STACK.get().pop();
+        final BigInteger c = this.toBigInteger();
+        final BigInteger ssModular = BigInteger.ONE.shiftLeft(e).add(BigInteger.ONE);
+        final BigInteger expected = a.mod(ssModular);
+        if (!c.equals(expected))
+          throw new RuntimeException(expected.toString(16) + " != c"
+              + "\nssModular = " + ssModular.toString(16)
+              + "\na = " + a.toString(16)
+              + "\nc = " + c.toString(16) + " = " + this);
+      }
+
+      if (PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.endIndentation("ssModEqual returns " + this);
+      checkNonNegative();
+      return this;
+    }
+
+    private void clearHigherDigits(final int startDigit) {
+      if (startDigit < nDigits) {
+        if (PRINT_LEVEL.is(Print.Level.DEBUG))
+          Print.beginIndentation("clearHigherDigits(startDigit=" + startDigit + "), this=" + this);
+        
+        nDigits = startDigit;
+        final int offset = nDigits & digitsPerArray.mask;
+        final int i = nDigits >> digitsPerArray.exponent;
+        Arrays.fill(digits[i], offset, digitsPerArray.value, 0);
+        clearArrays(i + 1);
+        trimLeadingZeros();
+
+        if (PRINT_LEVEL.is(Print.Level.DEBUG))
+          Print.endIndentation("clearHigherDigits returns " + this);
+      }
+    }
+
+    /**
+     * e        = exponent_in_digits * bitsPerDigit
+     * quotient = this / 2^e,
+     * this     = this % 2^e,
+     * @return quotient 
+     */
+    public Element divideRemainderEqual(final int exponent_in_digits) {
+      if (exponent_in_digits >= nDigits)
+        return newElement();
+      else {
+        if (PRINT_LEVEL.is(Print.Level.DEBUG))
+          Print.beginIndentation("divideRemainderEqual("
+              + exponent_in_digits + "), this=" + this);
+
+        final Element quotient = newElement();
+        quotient.positive = this.positive;
+        quotient.nDigits = this.nDigits - exponent_in_digits;
+
+        for(int i = 0; i < quotient.nDigits; i++) {
+          final int j = exponent_in_digits + i;
+          final int[] d = this.digits[j >> digitsPerArray.exponent];
+          final int r = j & digitsPerArray.mask;
+          
+          final int q = i >> digitsPerArray.exponent;
+          if (quotient.digits[q] == null)
+            quotient.digits[q] = arrayrecycler.newObject();
+          quotient.digits[q][i & digitsPerArray.mask] = d[r];
+          d[r] = 0;
+        }
+        this.trimLeadingZeros();
+
+        if (PRINT_LEVEL.is(Print.Level.DEBUG))
+          Print.endIndentation("divideRemainderEqual returns leading="
+              + quotient + ", this=" + this);
+        return quotient;
+      }
+    }
+
+    public int difference(final int exponent_in_digits, final int m) {
+      //Print.println("difference(exponent_in_digits=" + exponent_in_digits + ", m=" + m + "), this=" + this.toBrief());
+      if (m < 2 || m > digitLimit.value) {
+        throw new IllegalArgumentException(
+            "m < 2 || m > digitLimit.value = " + digitLimit + ", m=");
+      } else if (exponent_in_digits <= 0) {
+        throw new IllegalArgumentException(
+            exponent_in_digits + " = exponent_in_digits <= 0");
+      } else if (nDigits > exponent_in_digits) {
+        throw new IllegalArgumentException(
+            nDigits + " = nDigits > exponent_in_digits = " + exponent_in_digits);
+      } else if (nDigits < exponent_in_digits) {
+        return m;
+      } else {
+        int i = nDigits - 1, r = -1;
+        for(; i > 0 && r < 0; ) {
+          //Print.println("difference: i=" + i + ", r=" + r);
+          final int[] d = digits[i >> digitsPerArray.exponent];
+          for(r = i & digitsPerArray.mask;
+              i > 0 && r >= 0 && d[r] == digitLimit_mask;
+              i--, r--);
+        }
+        if (i > 0)
+          return m;
+        else {
+          final long d = digitLimit.value - (digits[0][0] & digitLimit.mask);
+          return  d < m? (int)d: m;
+        }
+      }
+    }
+
+    private Element extractHigherDigits(final int startDigit) {
+      if (PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.beginIndentation("extractHigherDigits(startDigit=" + startDigit + "), this=" + this);
+
+      final Element e = newElement();
+      if (startDigit < this.nDigits) {
+        //Printer.println("this = " + toDetails());
+
+        e.positive = this.positive;
+        e.nDigits = this.nDigits - startDigit;
+  
+        final int left = startDigit & digitsPerArray.mask;
+        final int right = digitsPerArray.value - left;
+  
+        final int nArray = e.nDigits >> digitsPerArray.exponent;
+        int srci = startDigit >> digitsPerArray.exponent;
+        int q = 0;
+        for (int i = 0; i < nArray; i++) {
+          final int[] d = arrayrecycler.newObject();
+          e.digits[q++] = d;
+          System.arraycopy(digits[srci], left, d, 0, right);
+          srci++;
+          if (left > 0)
+            System.arraycopy(digits[srci], 0, d, right, left);
+        }
+  
+        //Printer.println("1) e = " + e.toDetails());
+        int remaining = e.nDigits & digitsPerArray.mask;
+        //Printer.println("remaining = " + remaining);
+        if (remaining > 0) {
+          final int[] d = arrayrecycler.newObject();
+          e.digits[q++] = d;
+
+          final int len = remaining < right ? remaining : right;
+          System.arraycopy(digits[srci], left, d, 0, len);
+          remaining -= len;
+          if (remaining > 0) {
+            srci++;
+            System.arraycopy(digits[srci], 0, d, right, remaining);
+          }
+        }
+        //Printer.println("2) e = " + e.toDetails());
+      }
+      if (PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.endIndentation("extractHigherDigits returns " + e);
+      return e;
+    }
+
+    Element shiftRightEqual_digits(final int shift_in_digits) {
+      if (shift_in_digits == 0)
+        return this;
+      else if (shift_in_digits < 0)
+        throw new IllegalArgumentException("shift_in_digits = " + shift_in_digits + " < 0");
+
+      if (PRINT_LEVEL.is(Print.Level.TRACE)) {
+        Print.beginIndentation("shiftRightEqual_digits(shift_in_digits=" + shift_in_digits + ")");
+        Print.println("this = " + this);
+      }
+
+      if (shift_in_digits >= nDigits)
+        setZero();
+      else {
+        this.nDigits -= shift_in_digits;
+        
+        int shift_q = shift_in_digits >> digitsPerArray.exponent; 
+        int shift_r = shift_in_digits & digitsPerArray.mask; 
+        if (shift_r == 0) {
+          //shift arrays
+          final int nArray = ((this.nDigits - 1) >> digitsPerArray.exponent) + 1;
+          int q = 0;
+          for(; q < nArray; ) {
+            this.digits[q++] = this.digits[shift_q];
+            this.digits[shift_q++] = null;
+          }
+          for(; this.digits[q] != null; ) {
+            this.digits[q++] = null;            
+          }
+        } else {
+          //shift digits
+          int q = 0;
+          int r = 0;
+          for(int i = 0; i < this.nDigits; i++) {
+            this.digits[q][r] = this.digits[shift_q][shift_r];
+            
+            if (++r == digitsPerArray.value) {
+              r = 0;
+              q++;
+            }
+            if (++shift_r == digitsPerArray.value) {
+              shift_r = 0;
+              shift_q++;
+            }
+          }
+
+          //set leading zeros
+          if (r == 0) {
+            clearArrays(q);
+          } else {
+            clearArrays(q + 1);
+            Arrays.fill(digits[q], r, digitsPerArray.value, 0);
+          }
+        }
+      }
+      if (PRINT_LEVEL.is(Print.Level.TRACE)) {
+        Print.endIndentation("shiftRightEqual_digits return this=" + this);
+      }
+      return this;
+    }
+
+    @Override
+    public Element shiftRightEqual_bits(final long shift_in_bits) {
+      final int shift_in_digits = JavaUtil.toInt(shift_in_bits >> bitsPerDigit.exponent);
+      if (shift_in_bits < 0)
+        throw new IllegalArgumentException("shift_in_bits = " + shift_in_bits + " < 0");
+      else if (shift_in_bits == 0 || this.isZero())
+        return this;
+      else if ((shift_in_bits & bitsPerDigit.mask) == 0)
+        return this.shiftRightEqual_digits(shift_in_digits);
+      
+      if (PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.beginIndentation("shiftRightEqual_bits(" + shift_in_bits + "), this=" + this);
+
+      final long oldNOB = numberOfBits_long();
+      final long newNOB = oldNOB - shift_in_bits;
+      if (newNOB <= 0) {
+        return this.setZero();
+      }
+
+      //(0 < shift_in_bits < oldNOB) and (shift_in_bits % bitsPerDigit != 0)
+      final int right_shift = (int)shift_in_bits & bitsPerDigit.mask;
+      final int left_shift = bitsPerDigit.value - right_shift;
+      int i = shift_in_digits;
+      int i_q = i >> digitsPerArray.exponent;
+      int i_r = i & digitsPerArray.mask;
+      int q = 0;
+      int r = 0;
+      digits[q][r] = digits[i_q][i_r] >>> right_shift;
+      
+      for(i++; i < nDigits; i++) {
+        if (++i_r == digitsPerArray.value) {i_r = 0;   i_q++;}
+        digits[q][r] |= (digits[i_q][i_r] << left_shift) & digitLimit_mask;
+
+        if (++r == digitsPerArray.value) {r = 0;   q++;}
+        digits[q][r] = digits[i_q][i_r] >>> right_shift;
+      }
+      if (++r < digitsPerArray.value) {
+        Arrays.fill(digits[q], r, digitsPerArray.value, 0);
+      } 
+
+      nDigits = JavaUtil.toInt(((newNOB - 1) >> bitsPerDigit.exponent) + 1);
+      clearArrays(((nDigits - 1) >> digitsPerArray.exponent) + 1);
+
+      if (PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.endIndentation("shiftRightEqual_bits returns " + this);
+      return this;      
+    }
+
+    Element shiftLeftEqual_digits(final int shift_in_digits) {
+      //TODO: Optimize this method; see shiftRightEqual_xxx(..)
+      return shiftLeftEqual_bits(shift_in_digits << bitsPerDigit.exponent);
+    }
+
+    /** Shift this to left. */
+    @Override
+    public Element shiftLeftEqual_bits(final long shift_in_bits) {
+      if (shift_in_bits == 0 || this.isZero())
+        return this;
+
+      if (PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.beginIndentation("shiftLeftEqual_bits(" + shift_in_bits + "), this=" + this);
+
+      if (debug)
+        DEBUG_STACK.get().push(this.toBigInteger());
+      
+      final long oldNOB = numberOfBits_long();
+      final long newNOB = oldNOB + shift_in_bits;
+      final int oldNDigit = nDigits;
+      nDigits = JavaUtil.toInt(((newNOB - 1) >> bitsPerDigit.exponent) + 1);
+      final int nArray = ((nDigits - 1) >> digitsPerArray.exponent) + 1;
+      for (int i = ((oldNDigit - 1) >> digitsPerArray.exponent) + 1; i < nArray; i++)
+        digits[i] = arrayrecycler.newObject();
+
+      final int digitdiff = JavaUtil.toInt(shift_in_bits >> bitsPerDigit.exponent);
+      //Printer.println("oldNOB=" + oldNOB + ", newNOB=" + newNOB
+      //    + ", oldNDigit=" + oldNDigit + ", nDigit=" + nDigit + ", digitdiff=" + digitdiff);
+      if (digitdiff > 0) {
+        {
+          int i = oldNDigit + digitdiff;
+          int j = oldNDigit;
+          for (int k = 0; k < oldNDigit; k++) {
+            --i;
+            --j;
+            // TODO: need optimization 
+            digits[i >> digitsPerArray.exponent][i & digitsPerArray.mask]
+                = digits[j >> digitsPerArray.exponent][j & digitsPerArray.mask];
+          }
+        }
+
+        for (int k = 0; k < digitdiff; k++)
+          digits[k >> digitsPerArray.exponent][k & digitsPerArray.mask] = 0;
+      }
+
+      final int bitOffset = (int)shift_in_bits & bitsPerDigit.mask;
+      final int reverseBitOffset = bitsPerDigit.value - bitOffset;
+      if (bitOffset > 0) {
+        int i = nDigits - 1;
+        int row = i >> digitsPerArray.exponent;
+        int col = i & digitsPerArray.mask;
+        for (; i > digitdiff;) {
+          digits[row][col] <<= bitOffset;
+          digits[row][col] &= digitLimit_mask;
+          i--;
+          final int prevRow = row;
+          final int prevCol = col;
+          row = i >> digitsPerArray.exponent;
+          col = i & digitsPerArray.mask;
+          digits[prevRow][prevCol] |= digits[row][col] >>> reverseBitOffset;
+        }
+        digits[row][col] <<= bitOffset;
+        digits[row][col] &= digitLimit_mask;
+      }
+
+      if (debug) {
+        final BigInteger a = DEBUG_STACK.get().pop();
+        final BigInteger c = this.toBigInteger();
+        final BigInteger expected = a.shiftLeft(JavaUtil.toInt(shift_in_bits));
+        if (!c.equals(expected))
+          throw new RuntimeException("a << " + shift_in_bits + " != " + expected.toString(16)
+              + "\na = " + a.toString(16)
+              + "\nc = " + c.toString(16) + " = " + this);
+      }
+
+      if (PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.endIndentation("shiftLeftEqual_bits returns " + this);
+      return this;
+    }
+
+    public Element plusEqual(final int singleDigit) {
+      if (singleDigit >= digitLimit.value || -singleDigit >= digitLimit.value)
+        throw new IllegalArgumentException(
+            "singleDigit >= digitLimit.value || singleDigit <= digitLimit.value"
+                + "\n  singleDigit      = " + singleDigit
+                + "\n  digitLimit.value = " + digitLimit.value);
+      if (singleDigit == 0)
+        return this;
+      else {
+        //final BigInteger a = this.toBigInteger();
+  
+        if (singleDigit > 0) {
+          if (positive)
+            plusEqual_sameSign(singleDigit, 0);
+          else
+            plusEqual_differentSign(singleDigit, 0);
+        }
+        else {
+          if (positive)
+            plusEqual_differentSign(-singleDigit, 0);
+          else
+            plusEqual_sameSign(-singleDigit, 0);
+        }
+        /*
+        final BigInteger c = this.toBigInteger();
+        if (!c.equals(a.add(BigInteger.valueOf(singleDigit))))
+          throw new RuntimeException("a + b != c"
+              + "\na = " + a
+              + "\nb = " + singleDigit
+              + "\nc = " + c + " = " + this);
+              */
+        return this;
+      }
+    }
+
+    /**
+     * @param n n >= 0.
+     */
+    Element plusEqual_sameSign(final int n, final int startDigit) {
+      if (PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.beginIndentation("plusEqual_sameSign(n=" + n + ", startDigit=" + startDigit + "), this=" + toOneLineDetails());
+      if (n == 0) {
+        if (PRINT_LEVEL.is(Print.Level.TRACE))
+          Print.endIndentation("plusEqual_sameSign 1trivial");
+        return this;
+      }
+      else if (startDigit >= nDigits) {
+        final int q = startDigit >> digitsPerArray.exponent;
+        for (int i = ((nDigits - 1) >> digitsPerArray.exponent) + 1; i <= q; i++)
+          digits[i] = arrayrecycler.newObject();
+        digits[q][startDigit & digitsPerArray.mask] = n;
+        nDigits = startDigit + 1;
+        if (PRINT_LEVEL.is(Print.Level.TRACE))
+          Print.endIndentation("plusEqual_sameSign 2returns " + this);
+        return this;
+      } else {
+        int[] d = digits[startDigit >> digitsPerArray.exponent];
+        long carry = n;
+        for(int i = startDigit; i < nDigits; i++) {
+          final int r = i & digitsPerArray.mask;
+          if (r == 0)
+            d = digits[i >> digitsPerArray.exponent];
+
+          carry += (d[r] & digitLimit.mask);
+          d[r] = (int)carry & digitLimit_mask;
+          carry >>>= digitLimit.exponent;
+
+          if (carry == 0) {
+            if (PRINT_LEVEL.is(Print.Level.TRACE))
+              Print.endIndentation("plusEqual_sameSign 3returns " + this);
+            return this;
+          }
+        }
+
+        //carry > 0
+        final int r = nDigits & digitsPerArray.mask;
+        if (r == 0) {
+          final int q = nDigits >> digitsPerArray.exponent;
+          if (digits[q] == null)
+            digits[q] = d = arrayrecycler.newObject();
+          else
+            d = digits[q];
+        }
+        d[r] = (int)carry;
+        nDigits++;
+        if (PRINT_LEVEL.is(Print.Level.TRACE))
+          Print.endIndentation("plusEqual_sameSign 4returns " + this);
+        return this;
+      }
+    }
+
+    private Element plusEqual_differentSign(int n, final int startDigit) {
+      if (isZero()) {
+        positive = !positive;
+        return plusEqual_sameSign(n, startDigit);
+      } else {
+        if (PRINT_LEVEL.is(Print.Level.TRACE))
+          Print.beginIndentation("plusEqual_differentSign(n=" + n + ", startDigit=" + startDigit + "), this=" + toOneLineDetails());
+
+        final int q = startDigit >> digitsPerArray.exponent;
+        for (int i = ((nDigits - 1) >> digitsPerArray.exponent) + 1; i <= q; i++)
+          digits[i] = arrayrecycler.newObject();
+
+        final boolean changeSign = startDigit == nDigits - 1?
+            (digits[q][startDigit & digitsPerArray.mask] & digitLimit.mask) < (n & digitLimit.mask)
+            : startDigit >= nDigits;
+        if (changeSign) {
+          positive = !positive;
+          if (startDigit > 0) {
+            int[] d = digits[0];
+            int i = 0;
+            for(boolean iszero = d[0] == 0; iszero && i < startDigit; ) {
+              i++;
+              final int r = i & digitsPerArray.mask;
+              if (r == 0)
+                d = digits[i >> digitsPerArray.exponent];
+              iszero = d[r] == 0;
+            }
+
+            if (i < startDigit) {
+              n--;
+              final int r = i & digitsPerArray.mask;
+              if (r == 0)
+                d = digits[i >> digitsPerArray.exponent];
+              d[r] = (int)(digitLimit.value - (d[r] & digitLimit.mask));
+              
+              i++;
+              if (nDigits < i)
+                nDigits = i;
+            }
+            for(; i < startDigit; ) {
+              final int r = i & digitsPerArray.mask;
+              if (r == 0)
+                d = digits[i >> digitsPerArray.exponent];
+              d[r] = (d[r] ^ digitLimit_mask);
+              
+              i++;
+              if (nDigits < i)
+                nDigits = i;
+            }
+          }
+        }
+
+        if (n == 0) {
+          trimLeadingZeros();
+          if (PRINT_LEVEL.is(Print.Level.TRACE))
+            Print.endIndentation("plusEqual_differentSign 1returns " + this);
+          return this;
+        } else {
+          //n > 0
+          int[] d = digits[q];
+          if (startDigit >= nDigits) {
+            d[startDigit & digitsPerArray.mask] = n;
+            nDigits = startDigit + 1;
+            if (PRINT_LEVEL.is(Print.Level.TRACE))
+              Print.endIndentation("plusEqual_differentSign 2returns " + this);
+            return this;
+          } else if (startDigit == nDigits - 1) {
+            final int r = startDigit & digitsPerArray.mask;
+            final long diff = (d[r] & digitLimit.mask) - n;
+            if (diff == 0) {
+              d[r] = 0;
+              trimLeadingZeros();
+            } else if (diff < 0) { 
+              d[r] = (int)(-diff);
+            } else {
+              d[r] = (int)diff;
+            }
+            if (PRINT_LEVEL.is(Print.Level.TRACE))
+              Print.endIndentation("plusEqual_differentSign 3returns " + this);
+            return this;
+          } else {
+            for(int i = startDigit; i < nDigits; i++) {
+              final int r = i & digitsPerArray.mask;
+              if (r == 0)
+                d = digits[i >> digitsPerArray.exponent];
+
+              final long diff = (d[r] & digitLimit.mask) - n;
+              if (diff >= 0) {
+                d[r] = (int)diff;
+                if (i == nDigits - 1 && diff == 0) {
+                  trimLeadingZeros();
+                }
+                if (PRINT_LEVEL.is(Print.Level.TRACE))
+                  Print.endIndentation("plusEqual_differentSign 4returns " + this);
+                return this;
+              } else {
+                d[r] = (int)(diff + digitLimit.value);
+                n = 1;
+              }
+            }
+            throw new RuntimeException("Something wrong: n=" + n + ", this=" + this);
+          }
+        }
+      }
+    }
+
+    @Override
+    public Element negateEqual() {
+      positive = !positive;
+      if (PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.println("negationEqual: " + (positive? "+ => -": "- => +") + ", this=" + this);
+      return this;
+    }
+
+    @Override
+    public Element plusEqual(final Element that) {
+      if (that.isZero())
+        return this;
+      if (this == that)
+        return shiftLeftEqual_bits(1);
+      this.check(that);
+
+      if (PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.beginIndentation("plusEqual(that=" + that.toOneLineDetails() + "), this=" + toOneLineDetails());
+      
+      if (debug)
+        DEBUG_STACK.get().push(this.toBigInteger());
+      
+      if (this.positive == that.positive)
+        plusEqual_sameSign(that);
+      else
+        plusEqual_differentSign(that);
+
+      if (debug) {
+        final BigInteger a = DEBUG_STACK.get().pop();
+        final BigInteger b = that.toBigInteger();
+        final BigInteger c = this.toBigInteger();
+        if (!c.equals(a.add(b)))
+          throw new RuntimeException("a + b != c"
+              + "\na = " + a
+              + "\nb = " + b + " = " + that
+              + "\nc = " + c + " = " + this);
+      }
+
+      if (PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.endIndentation("plusEqual returns " + this);
+      return this;
+    }
+
+    private Element plusEqual_sameSign(final Element that) {
+      this.check(that);
+
+      if (PRINT_LEVEL.is(Print.Level.TRACE)) {
+        Print.beginIndentation("plusEqual_sameSign(that=" + that + ")");
+        Print.println("                 this=" + this);
+      }
+
+      final int thatArraySize = ((that.nDigits - 1) >> digitsPerArray.exponent) + 1;
+      for (int i = ((this.nDigits - 1) >> digitsPerArray.exponent) + 1; i < thatArraySize; i++)
+        digits[i] = arrayrecycler.newObject();
+      this.nDigits = Math.max(this.nDigits, that.nDigits);
+
+      int that_pos = 0;
+      long carry = 0;
+      for (int j = 0; j < thatArraySize; j++) {
+        final int[] d = this.digits[j];
+        final int[] that_d = that.digits[j];
+        for(int i = 0; i < digitsPerArray.value; i++) {
+          carry += (d[i] & digitLimit.mask);
+          if (that_pos < that.nDigits) {
+            that_pos++;
+            carry += (that_d[i] & digitLimit.mask);
+          }
+          d[i] = (int)carry & digitLimit_mask;
+          carry >>>= digitLimit.exponent;
+
+          if (carry == 0 && that_pos >= that.nDigits) {
+            nDigits = Math.max(nDigits, (j << digitsPerArray.exponent) + i + 1);
+
+            if (PRINT_LEVEL.is(Print.Level.TRACE))
+              Print.endIndentation("plusEqual_sameSign returns " + this);
+            return this;
+          }
+        }
+      }
+
+      if (carry <= 0)
+        throw new RuntimeException(carry + " = carry <= 0");
+
+      plusEqual_sameSign((int)carry, thatArraySize << digitsPerArray.exponent);
+
+      if (PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.endIndentation("plusEqual_sameSign returns " + this);
+      return this;
+    }
+
+    private Element plusEqual_differentSign(final Element that) {
+      this.check(that);
+      
+      if (PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.beginIndentation("plusEqual_differentSign(that=" + that.toOneLineDetails()
+            + "), this=" + toOneLineDetails());
+
+      final int magitude = this.compareMagnitudeTo(that);
+      if (magitude == 0) {
+        this.positive = true;
+        this.nDigits = 0;
+        clearArrays(0);
+      } else {
+        final Element large;
+        final Element small;
+        if (magitude < 0) {
+          this.positive = that.positive;
+          large = that;
+          small = this;          
+        } else {
+          large = this;
+          small = that;          
+        }
+        
+        int[] largeArray = null;
+        int[] smallArray = null;
+        int[] thisArray = null;
+        long borrow = 0;
+        int i = 0;
+        for (; i < small.nDigits; i++) {
+          final int r = i & digitsPerArray.mask;
+          if (r == 0) {
+            final int q = i >> digitsPerArray.exponent;
+            largeArray = large.digits[q];
+            smallArray = small.digits[q];
+            thisArray = this.digits[q];
+          }
+          
+          borrow += (largeArray[r] & digitLimit.mask);
+          borrow -= (smallArray[r] & digitLimit.mask);
+          if (borrow >= 0) {
+            thisArray[r] = (int)borrow;
+            borrow = 0;
+          } else {
+            thisArray[r] = (int)(borrow + digitLimit.value);
+            borrow = -1;
+          }
+        }
+        
+        for(; borrow != 0 && i < large.nDigits; i++) {
+          final int r = i & digitsPerArray.mask;
+          if (r == 0) {
+            final int q = i >> digitsPerArray.exponent;
+            largeArray = large.digits[q];
+            if (this.digits[q] != null)
+              thisArray = this.digits[q];
+            else
+              this.digits[q] = thisArray = arrayrecycler.newObject();
+          }
+
+          borrow += (largeArray[r] & digitLimit.mask);
+          if (borrow >= 0) {
+            thisArray[r] = (int)borrow;
+            borrow = 0;
+          } else {
+            thisArray[r] = (int)(borrow + digitLimit.value);
+            borrow = -1;
+          }
+        }
+
+        if (this != large) {
+          for(; i < large.nDigits; i++) {
+            final int r = i & digitsPerArray.mask;
+            if (r == 0) {
+              final int q = i >> digitsPerArray.exponent;
+              largeArray = large.digits[q];
+              this.digits[q] = thisArray = arrayrecycler.newObject();
+            }
+            thisArray[r] = largeArray[r];
+          }
+          
+          this.nDigits = large.nDigits;
+        }
+        trimLeadingZeros();
+      }
+
+      if (PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.endIndentation("plusEqual_differentSign returns " + this);
+      return this;
+    }
+
+    /** Multiplication using BigInteger, i.e. classical multiplication */
+    void multiplyEqual_BigInteger(final Element that) {
+      if (PRINT_LEVEL.is(Print.Level.DEBUG)) {
+        Print.beginIndentation("multiplyEqual(that=" + that + ")");
+        Print.println(         "            this=" + this);
+      }
+
+      final BigInteger thisBI = this.toBigInteger();
+      final BigInteger thatBI = that.toBigInteger();
+//      if (PRINT_LEVEL.is(Print.Level.DEBUG)) {
+//        Print.println("thisBI = " + thisBI.toString(16));
+//        Print.println("thatBI = " + thatBI.toString(16));
+//      }
+      this.set(thisBI.multiply(thatBI));
+
+      if (PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.endIndentation("multiplyEqual returns " + this);
+    }
+
+//    public void multiplyEqual_Apfloat(final Element that) {
+//      if (PRINT_LEVEL.is(Print.Level.DEBUG)) {
+//        Print.beginIndentation("multiplyEqual_Apfloat(..)");
+//        Print.println("this=" + this.toBrief());
+//        Print.println("that=" + that.toBrief());
+//      }
+//      final Apint thisAPINT = new Apint(this.toBigInteger());
+//      final Apint thatAPINT = new Apint(that.toBigInteger());
+//      final Apint r = thisAPINT.multiply(thatAPINT);
+//      set(r.toBigInteger());
+//      if (PRINT_LEVEL.is(Print.Level.DEBUG)) {
+//        Print.endIndentation("multiplyEqual_Apfloat returns " + this.toBrief());
+//      }
+//    }
+
+    /**
+     * Karatsuba's method.
+     * 
+     * Let a2*B^2 + a1*B + a0 = (x1*B + x0)(y1*B + y0).
+     * 
+     * Then, a2 = x1*y1,
+     *       a0 = x0*y0,
+     *       a1 = (x1 + x0)(y1 + y0) - a2 - a0.
+     */
+    public void multiplyEqual_Karatsuba(final Element that, final int max_nDigits,
+        final JavaUtil.WorkGroup workers) {
+//      Print.beginIndentation("multiplyEqual_Karatsuba: max_nDigits=" + max_nDigits);
+//      Print.println("this = " + this);
+//      Print.println("that = " + that);
+
+      final int digitsPerElement = (max_nDigits + 1) >> 1;
+      final int bitsPerElement = digitsPerElement << bitsPerDigit.exponent;
+//      Print.println("digitsPerElement=" + digitsPerElement + ", bitsPerElement=" + bitsPerElement);
+      final Element[] x = this.split(bitsPerElement, 2);
+//      Print.print("x", x);
+      final Element[] y = that.split(bitsPerElement, 2);
+//      Print.print("y", y);
+
+      //a2 = x1*y1
+      this.set(x[1]).multiplyEqual(y[1], workers);
+      //y1 + y0
+      y[1].plusEqual(y[0]);
+      //(x1 + x0)(y1 + y0)
+      x[1].plusEqual(x[0]).multiplyEqual(y[1], workers);
+      //a0 = x0*y0
+      x[0].multiplyEqual(y[0], workers);
+      //a1 = (x1 + x0)(y1 + y0) - a2 - a0
+      x[1].plusEqual(this.negateEqual()).plusEqual(x[0].negateEqual());
+      
+      //a2*B^2
+      this.negateEqual().shiftLeftEqual_digits(digitsPerElement << 1);
+      //a2*B^2 + a1*B
+      this.plusEqual(x[1].shiftLeftEqual_digits(digitsPerElement));
+      //a2*B^2 + a1*B + a0
+      this.plusEqual(x[0].negateEqual());
+
+      x[0].reclaim();
+      x[1].reclaim();
+      y[0].reclaim();
+      y[1].reclaim();
+      
+//      Print.endIndentation("return this = " + this);
+    }
+    
+    public void multiplyEqual_SchonhageStrassen(final Element that, final int max_nDigits,
+        final JavaUtil.WorkGroup workers) {
+      if (SchonhageStrassen.PRINT_LEVEL.is(Print.Level.DEBUG)) {
+        Print.beginIndentation("multiplyEqual_SchonhageStrassen: ");
+        Print.println("this = " + this.toBrief());
+        Print.println("that = " + that.toBrief());
+      }
+
+      final SchonhageStrassen ss = SchonhageStrassen.FACTORY.valueOf(
+          max_nDigits, Zahlen.this);
+
+      ss.multiplyEquals(this, that, ss.parallel, workers);
+
+      if (SchonhageStrassen.PRINT_LEVEL.is(Print.Level.DEBUG))
+        Print.endIndentation("return " + this.toBrief());
+    }
+
+    @Override
+    public Element multiplyEqual(final Element that, final JavaUtil.WorkGroup workers) {
+      if (this.isZero()) {
+        return this;
+      } else if (that.isZero()) {
+        return this.setZero();
+      }
+
+      final boolean thispositive = !(this.positive ^ that.positive);
+      final boolean thatpositive = that.positive;
+      this.positive = that.positive = true;
+
+      this.set(GmpMultiplier.get().multiply(this, that));
+//      final int max = this.nDigits > that.nDigits? this.nDigits: that.nDigits;
+//      if (max <= BIG_INTEGER_THRESHOLD) {
+//        multiplyEqual_BigInteger(that);
+//      } else if (max <= KARATSUBA_THRESHOLD) {
+//        multiplyEqual_Karatsuba(that, max, workers);
+//      } else {
+////        final Element expected = newElement().set(this);
+////        final Element this_copy = newElement().set(this);
+////        final Element that_copy = newElement().set(that);
+//
+//        multiplyEqual_SchonhageStrassen(that, max, workers);
+//
+////        expected.multiplyEqual_BigInteger(that);
+////        if (!this.equals(expected)) {
+////          this_copy.printDetail("this_copy");
+////          that_copy.printDetail("that_copy");
+////          expected.printDetail("expected");
+////          this.printDetail("computed");
+////          JavaUtil.sleepms(100, null);
+////          throw new ArithmeticException();
+////        }
+//      }
+      
+      this.positive = thispositive;
+      that.positive = thatpositive;
+      return this;
+    }
+
+    public Element multiply(final Element that) {
+      if (this.isZero() || that.isZero()) {
+        return newElement();
+      }
+
+      final boolean sign = !(this.positive ^ that.positive);
+      final boolean thispositive = this.positive;
+      final boolean thatpositive = that.positive;
+      this.positive = that.positive = true;
+
+      final Element e = GmpMultiplier.get().multiply(this, that);
+      e.positive = sign;
+      this.positive = thispositive;
+      that.positive = thatpositive;
+      return e;
+    }
+
+    /**
+     * Use Newton method to compute reciprocal.
+     * x_{n+1} = x_n(2 - a x_n)
+     */
+    Element approximateReciprocalEqual(final JavaUtil.WorkGroup workers) {
+      if (isZero()) {
+        throw new ArithmeticException("isZero()=" + isZero());
+      }
+
+      /*
+      //find trailing zeros
+      int q = 0;
+      int r = 0;
+      int i = 0;
+      for(; i < nDigits && digits[q][r] == 0; i++) {
+        if (++r == digitsPerArray.value) {
+          r = 0;
+          q++;
+        }
+      }
+      if (i == nDigits) {
+        //unexpected case, print details for debug.
+        printDetail();
+        throw new RuntimeException(i + " = shift_in_digits == nDigits");
+      }
+      
+      //right shift, reciprocal, left shift
+      final int shift_in_digits = i;
+      shiftRightEqual_digits(shift_in_digits);
+      */
+
+      approximateReciprocalEqual_private(workers);
+
+//      shiftLeftEqual_digits(shift_in_digits);
+      return this;
+    }
+    
+    int normalize4division() {
+      final int q = (nDigits - 1) >> digitsPerArray.exponent;
+      final int r = (nDigits - 1) & digitsPerArray.mask;
+      final int leading = Integer.numberOfLeadingZeros(digits[q][r]) - (Integer.SIZE - bitsPerDigit.value);  
+      shiftLeftEqual_bits(leading);
+      return leading;      
+    }
+
+    /**
+     * Use Newton's method to compute reciprocal.
+     * x_{n+1} = 2x_n - a x_n^2
+     * 
+     * Algorithm 3.5 in page 112
+     * Richard Brent and Paul Zimmermann.  Modern Computer Arithmetic.
+     * Preprint Version 0.5
+     */
+    private void approximateReciprocalEqual_private(final JavaUtil.WorkGroup workers) {
+      if ((digits[(nDigits - 1) >> digitsPerArray.exponent][(nDigits - 1) & digitsPerArray.mask] & digitLimit.mask) < (digitLimit.value >> 1))
+        throw new ArithmeticException("Require normalization, this=" + this);
+
+      if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE)) {
+        Print.beginIndentation("approximateReciprocalEqual_private(..)");
+        Print.println("this = " + this + " = " + toBigInteger());
+      }
+
+      //TODO: need optimization
+      if (nDigits <= 1) {
+        final BigInteger a = BigInteger.ONE.shiftLeft(bitsPerDigit.value << 1).subtract(BigInteger.ONE);
+        set(a.divide(BigInteger.valueOf(digits[0][0] & digitLimit.mask)));
+        if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+          Print.endIndentation("return " + this + " (nDigits = 1)");
+        return;
+      } else if (nDigits == 2) {
+        final BigInteger a = BigInteger.ONE.shiftLeft(bitsPerDigit.value << 2).subtract(BigInteger.ONE);
+        set(a.divide(toBigInteger()));
+        if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+          Print.endIndentation("return " + this + " (nDigits = 2)");
+        return;
+      }
+
+      final int n = this.nDigits;
+      final int k = (n - 1) >> 1;
+      final int h = n - k;
+      if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.println("n = " + n + ", k = " + k + ", h = " + h);
+
+      final Element x = newElement().set(this);
+      x.shiftRightEqual_digits(k);
+      if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.println("a_h = " + x + " = " + x.toBigInteger());
+
+      x.approximateReciprocalEqual_private(workers);
+      if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.println("x_h = " + x + " = " + x.toBigInteger());
+
+      final Element a = newElement().set(this);
+      this.multiplyEqual(x, workers);
+      if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.println("t   = a x_h = " + this+ " = " + this.toBigInteger());
+
+      a.negateEqual();
+      if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.println("-a  = " + a + " = " + a.toBigInteger());
+
+      //T >= B^(n+h)
+      int count = 0;
+      for(; this.nDigits > n + h; ) {
+        this.plusEqual(a);
+        count++;
+        if (count > 5) {
+          throw new RuntimeException("count > 5, n=" + n + ", h=" + h);
+        }
+      }
+      a.reclaim();
+      x.plusEqual(-count);
+      
+      // T = (B^(n+h) - T)B^(-k) = B^(2h) - TB^(-k)
+      this.shiftRightEqual_digits(k);
+      this.substractBy_private(h << 1);
+      
+      this.multiplyEqual(x, workers);
+      this.shiftRightEqual_digits((h << 1) - k);
+      x.shiftLeftEqual_digits(k);
+      this.plusEqual(x);
+      x.reclaim();
+      if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE)) {
+        Print.endIndentation("return this = " + this + " = " + toBigInteger());
+      }
+    }
+    
+    /**
+     * B^e - this, given this < B^e,
+     * where B is the base, i.e. B = digitLimit.
+     */
+    private Element substractBy_private(final int exponent_in_digits) {
+//      Print.println("substractBy_private: exponent=" + exponent);
+      if (isZero()) {
+        nDigits = exponent_in_digits + 1;
+        final int last_q = exponent_in_digits >> digitsPerArray.exponent;
+        for(int i = last_q; i >= 0; i--) {
+          digits[i] = arrayrecycler.newObject();
+        }
+        digits[last_q][exponent_in_digits & digitsPerArray.mask] = 1;
+      } else if (nDigits > exponent_in_digits) {
+        this.plusEqual_differentSign(1, exponent_in_digits).negateEqual();
+      } else {
+        //0 < this < B^e, therefore, two's complement
+        int q = 0;
+        int r = 0;
+        int i = 0;
+        long carry = 1;
+        for(; i < nDigits && carry > 0; i++) {
+          carry += ((digits[q][r] ^ digitLimit_mask) & digitLimit.mask);
+          digits[q][r] = (int)carry & digitLimit_mask;
+          carry >>>= digitLimit.exponent;
+          
+          if (++r == digitsPerArray.value) {
+            r = 0;
+            q++;
+          }
+        }
+        //no more carry
+        for(; i < exponent_in_digits && digits[q] != null; i++) {
+          digits[q][r] ^= digitLimit_mask;
+          if (++r == digitsPerArray.value) {
+            r = 0;
+            q++;
+          }
+        }
+        //digits[q] are null
+        if (i < exponent_in_digits) {
+          final int last_q = (exponent_in_digits - 1) >> digitsPerArray.exponent;
+          for(; q < last_q; i++) {
+            digits[q] = arrayrecycler.newObject();
+            Arrays.fill(digits[q], digitLimit_mask);
+          }
+          r = ((exponent_in_digits - 1) & digitsPerArray.mask) + 1;
+          Arrays.fill(digits[q], 0, r, digitLimit_mask);
+        }
+        this.nDigits = exponent_in_digits;
+        this.trimLeadingZeros();
+      }
+      return this;
+    }
+
+    
+    int normalize4sqrt() {
+      final int q = (nDigits - 1) >> digitsPerArray.exponent;
+      final int r = (nDigits - 1) & digitsPerArray.mask;
+      final int bits = Integer.SIZE - Integer.numberOfLeadingZeros(digits[q][r]);
+      if (bits <= 2) {
+        return 0;
+      } else {
+        final int shift_in_bits = bitsPerDigit.value - bits + 2 - (bits & 1);  
+        shiftLeftEqual_bits(shift_in_bits);
+        return shift_in_bits;
+      }
+    }
+
+    public void approximateSqrtReciprocalEqual(final JavaUtil.WorkGroup workers) {
+      if (isZero()) {
+        throw new ArithmeticException("isZero()=" + isZero());
+      }
+      final int q = (nDigits - 1) >> digitsPerArray.exponent;
+      final int r = (nDigits - 1) & digitsPerArray.mask;
+      if (digits[q][r] == 1L)
+        if (nDigits == 1 || isAllDigitsZero(nDigits - 1)) {
+          if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+            Print.println("approximateSqrtReciprocalEqual (easy case), this = " + this);
+          return;
+        }
+
+      approximateSqrtReciprocalEqual_private(workers);
+    }
+
+    void approximateSqrtReciprocalEqual_bisection(final JavaUtil.WorkGroup workers) {
+      if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.beginIndentation("approximateSqrtReciprocalEqual_bisection: this = " + this + " = " + this.toBigInteger());
+      final int n = this.nDigits - 1;
+      final Element a = newElement().set(this);
+      final Element beta2 = newElement().plusEqual(1).shiftLeftEqual_digits(n << 1);
+//      Print.println("beta2=" + beta2);
+
+      final Element upper = newElement().setAllOne(n);
+      final Element lower = newElement();
+      final Element tmp = newElement();
+      
+      for(boolean done = false; !done; ) {
+        this.set(lower).plusEqual(upper).shiftRightEqual_bits(1);
+//        Print.println();
+//        Print.println("upper=" + upper.toBigInteger());
+//        Print.println("lower=" + lower.toBigInteger());
+//        Print.println("this =" + this.toBigInteger());
+        tmp.set(this)
+           .multiplyEqual(tmp, workers)
+           .shiftRightEqual_digits(n)
+           .multiplyEqual(a, workers);
+//        Print.println("tmp  =" + tmp);
+
+        if (this.compareTo(lower) == 0) {
+          tmp.plusEqual(beta2.negateEqual());
+          lower.set(tmp);
+//          Print.println("l=" + lower.toBigInteger());
+          tmp.set(upper)
+             .multiplyEqual(tmp, workers)
+             .shiftRightEqual_digits(n)
+             .multiplyEqual(a, workers)
+             .plusEqual(beta2)
+             .negateEqual();
+//          Print.println("u=" + tmp.toBigInteger());
+          tmp.plusEqual(lower);
+          if (tmp.isNegative()) {
+            this.set(upper);
+          }
+          done = true;
+        } else {
+          final int d = tmp.compareTo(beta2);
+//          Print.println("d=" + d);
+          if (d == 0) {
+            done = true;
+          } else if (d > 0) {
+            upper.set(this);
+          } else {
+            lower.set(this);
+          }
+        }
+      }
+
+      if (this.nDigits > n) {
+        this.setAllOne(n);
+      }
+      a.reclaim();
+      beta2.reclaim();
+      upper.reclaim();
+      lower.reclaim();
+      tmp.reclaim();
+      if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.endIndentation("return this=" + this + " = " + this.toBigInteger());
+    }
+
+    /**
+     * Given nDigits > 2 and 1 <= the leading coefficient < 4.
+     * 
+     * Algorithm 3.9 in page 112
+     * Richard Brent and Paul Zimmermann.  Modern Computer Arithmetic.
+     * Preprint Version 0.5.9
+     */
+    private void approximateSqrtReciprocalEqual_private(final JavaUtil.WorkGroup workers) {
+      if (nDigits <= 3) {
+        approximateSqrtReciprocalEqual_bisection(workers);
+        return;
+      }
+      if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.beginIndentation("approximateReciprocalSqrtEqual_private: this = " + this);
+      //JavaUtil.sleepsecond(1, null);
+
+      final int n = this.nDigits - 1;
+      final int k = (n - 1) >> 1;
+      final int h = n - k;
+
+      if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE)) {
+        Print.println("n = " + n + ", k = " + k + ", h = " + h);
+        Print.println("a    = " + this + " = " + this.toBigInteger());
+      }
+
+      final Element x = newElement().set(this);
+      x.shiftRightEqual_digits(k);
+      if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.println("a_h  = " + x + " = " + x.toBigInteger());
+
+      x.approximateSqrtReciprocalEqual_private(workers);
+      if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.println("x_h  = " + x + " = " + x.toBigInteger());
+      
+      this.multiplyEqual(x, workers).multiplyEqual(x, workers);
+      if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.println("t    = " + this + " = " + this.toBigInteger());
+
+      this.shiftRightEqual_digits(n);
+      if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.println("t_h  = " + this + " = " + this.toBigInteger());
+
+      this.substractBy_private(h << 1);
+      if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.println("t_l  = " + this + " = " + this.toBigInteger());
+
+      this.multiplyEqual(x, workers);
+      if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.println("u    = " + this + " = " + this.toBigInteger());
+
+      final int shift_in_digits = (h << 1) - k;
+      final int shift_in_bits = (shift_in_digits << bitsPerDigit.exponent) + 1;
+      if (shift_in_bits >= this.numberOfBits_int()) {
+        this.setZero();
+      } else {
+        final long d = digits[shift_in_digits >> digitsPerArray.exponent][shift_in_digits & digitsPerArray.mask];
+        this.shiftRightEqual_bits(shift_in_bits);
+        if ((d & 1) == 1)
+          this.plusEqual(1);
+      }
+      if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.println("u*B^(l-2h)/2 = " + this + " = " + this.toBigInteger());
+
+      this.plusEqual(x.shiftLeftEqual_digits(k));
+      if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.println("this         = " + this + " = " + this.toBigInteger());
+
+      if (this.nDigits > n)
+        this.setAllOne(n);
+      if (FixedPointFraction.PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.endIndentation("return: this = " + this);
+    }
+    
+    /** Set this to B^n - 1. */
+    private Element setAllOne(final int n) {
+      if (n == 0) {
+        setZero();
+      } else {
+//        Print.beginIndentation("setAllOne(" + n + ") this = " + this);
+        this.clearHigherDigits(n);
+        int q = (n - 1) >> digitsPerArray.exponent;
+        if (digits[q] == null)
+          digits[q] = arrayrecycler.newObject();
+        Arrays.fill(digits[q], 0, ((n - 1) & digitsPerArray.mask) + 1, digitLimit_mask);
+        for(q--; q >= 0; q--) {
+          Arrays.fill(digits[q], digitLimit_mask);
+        }
+  
+        this.nDigits = n;
+        this.positive = true;
+//        Print.endIndentation("return this = " + this);
+      }
+      return this;
+    }
+
+    /**
+     * Take integer square root and store the remainder in this object 
+     * @return a new object storing the integer square root
+     */
+    Element sqrtRemainderEqual(final JavaUtil.WorkGroup workers) {
+      if (isZero()) {
+        return newElement();
+      } else if (!positive) {
+        printDetail("ERROR");
+        throw new ArithmeticException("positive = " + positive);
+      }
+
+      final int k = (nDigits - 1) >> 2;
+      if (k == 0) {
+        return sqrtRemainderEqual_baseCase(workers);
+      } else {
+        throw new UnsupportedOperationException();
+      }
+    }
+    /**
+     * Given 0 < nDigits <= 4,
+     * take integer square root and store the remainder in this object 
+     * @return a new object storing hte integer square root
+     */
+    private Element sqrtRemainderEqual_baseCase(final JavaUtil.WorkGroup workers) {
+      if (this.nDigits == 1) {
+        final int s = (int)MathUtil.sqrt_long(this.digits[0][0]);
+        final Element sqrt = newElement();
+        sqrt.nDigits = 1;
+        sqrt.positive = true;
+        sqrt.digits[0] = arrayrecycler.newObject();
+        sqrt.digits[0][0] = s;
+        this.digits[0][0] -= s*s;
+        if (this.digits[0][0] == 0) {
+          this.nDigits = 0;
+          arrayrecycler.reclaim(this.digits[0]);
+          this.digits[0] = null;          
+        }
+        return sqrt;
+      } else {
+        final int half_nBits = this.numberOfBits_int() >> 1;
+        final Element original = newElement().set(this);
+        final Element tmp = newElement();
+  
+        Element upper;
+        Element lower;
+
+        {
+          final Element mid = newElement().set(this).shiftRightEqual_bits(half_nBits);
+          this.plusEqual(tmp.set(mid).multiplyEqual(mid, workers).negateEqual());
+
+          if (this.isNonNegative() && this.compareTo(tmp.set(mid).shiftRightEqual_bits(1)) <= 0) {
+            original.reclaim();
+            tmp.reclaim();
+            return mid;
+          } else if (this.isPositive()) {
+            upper = newElement().set(original).shiftRightEqual_bits(half_nBits - 1);
+            lower = mid;
+          } else {
+            upper = mid;
+            lower = newElement().set(original).shiftRightEqual_bits(half_nBits + 1);
+          }
+        }
+        
+        
+        for(tmp.set(lower).negateEqual().plusEqual(upper);
+            !tmp.isZero() && !tmp.isOne();
+            tmp.set(lower).negateEqual().plusEqual(upper)) {
+          //Print.println("lower=" + lower + ", upper=" + upper);
+          final Element mid = newElement().set(lower).plusEqual(upper).shiftRightEqual_bits(1);
+          this.set(original).plusEqual(tmp.set(mid).multiplyEqual(mid, workers).negateEqual());
+
+          if (this.isNonNegative() && this.compareTo(tmp.set(mid).shiftRightEqual_bits(1)) <= 0) {
+            original.reclaim();
+            tmp.reclaim();
+            upper.reclaim();
+            lower.reclaim();
+            return mid;
+          } else if (this.isPositive()) {
+            lower.reclaim();
+            lower = mid;
+          } else {
+            upper.reclaim();
+            upper = mid;
+          }
+        }
+
+        this.set(original).plusEqual(tmp.set(lower).multiplyEqual(lower, workers).negateEqual());
+        upper.reclaim();
+        original.reclaim();
+        tmp.reclaim();
+        return lower;
+      }
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  public static final Factory FACTORY = new Factory();
+  public static class Factory 
+      implements DataSerializable.ValueOf<Zahlen>, StringSerializable.ValueOf<Zahlen> {
+    protected final Map<String, Zahlen> cache = new HashMap<String, Zahlen>();
+
+    public Zahlen valueOf(final int bitsPerDigit, final int digitsPerArray, final int numArrays) {
+      final String key = bitsPerDigit + "," + digitsPerArray + "," + numArrays;
+      Zahlen z = cache.get(key);
+      if (z == null)
+        cache.put(key, z = new Zahlen(bitsPerDigit, digitsPerArray, numArrays));
+      return z;
+    }
+
+    @Override
+    public Zahlen valueOf(String s) {
+      int i = 0;
+      int j = s.indexOf(", ", i);
+      final int bitsPerDigit = Parse.parseIntVariable("bitsPerDigit", s.substring(i, j));
+
+      i = j + 2;
+      j = s.indexOf(", ", i);
+      final int digitsPerArray = Parse.parseIntVariable("digitsPerArray", s.substring(i, j));
+
+      i = j + 2;
+      final int numArrays = Parse.parseIntVariable("numArrays", s.substring(i));
+
+      return valueOf(bitsPerDigit, digitsPerArray, numArrays);
+    }
+
+    @Override
+    public Zahlen valueOf(DataInput in) throws IOException {
+      final int version = in.readInt();
+      if (version != VERSION) {
+        throw new IOException(version + " = version != VERSION = " + VERSION);
+      } else {
+        final PowerOfTwo_int bitsPerDigit = PowerOfTwo_int.valueOf(in);
+        final PowerOfTwo_int digitsPerArray = PowerOfTwo_int.valueOf(in);
+        final int numArrays = in.readInt();
+        return valueOf(bitsPerDigit.value, digitsPerArray.value, numArrays);
+      }
+    }
+  }
+
+  public static final DataSerializable.ValueOf<Element> ELEMENT_FACTORY
+      = new DataSerializable.ValueOf<Element>() {
+    @Override
+    public Element valueOf(final DataInput in) throws IOException {
+      //read Zahlen, positive
+      final Checksum c = Checksum.getChecksum();
+      final Zahlen z = FACTORY.valueOf(in);
+      c.update(z);
+      final Element e = z.newElement();
+      e.positive = c.update(in.readBoolean());
+    
+      //read digits
+      e.nDigits = c.update(in.readInt());
+      if (e.nDigits > 0) {
+        int q = -1;
+        int r = z.digitsPerArray.value - 1;
+    
+        if (z.bitsPerDigit.value <= Integer.SIZE) {
+          for(int i = 0; i < e.nDigits; i++) {
+            if (++r == z.digitsPerArray.value) {
+              r = 0;
+              e.digits[++q] = z.arrayrecycler.newObject();
+            }
+            e.digits[q][r] = c.update(in.readInt()) & z.digitLimit_mask;;
+          }
+        } else {
+          for(int i = 0; i < e.nDigits; i++) {
+            if (++r == z.digitsPerArray.value) {
+              r = 0;
+              e.digits[++q] = z.arrayrecycler.newObject();
+            }
+            e.digits[q][r] = c.update(in.readInt());
+          }
+        }
+      }
+      
+      //read and verify checksum
+      c.readAndVerify(in);
+      return e;
+    }
+  };
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/math/SchonhageStrassen.java
===================================================================
--- src/examples/org/apache/hadoop/mp/math/SchonhageStrassen.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/math/SchonhageStrassen.java	(revision 0)
@@ -0,0 +1,779 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.math;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
+
+import org.apache.hadoop.mp.math.Zahlen.Element;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Parse;
+import org.apache.hadoop.mp.util.Print;
+import org.apache.hadoop.mp.util.serialization.StringSerializable;
+
+
+/**
+ * Schonhage-Strassen Integer Multiplication
+ */
+public class SchonhageStrassen implements StringSerializable {
+  static final String VERSION = "20110123";
+  static Print.Level PRINT_LEVEL = Print.Level.INFO;
+  static final JavaUtil.Timer timer = new JavaUtil.Timer(false, false);
+  
+  public final Zahlen Z;
+  /** modulus = 2^m + 1 */
+  public final int modulusExponent;
+
+  public final PowerOfTwo_int bitsPerElement;
+
+  /** Dimension */
+  public final PowerOfTwo_int D;
+  final RootOfUnity D_inverse;
+
+  final RootOfUnity[] zeta;
+
+  private SchonhageStrassen(final Factory.Key k) {
+    Print.println("NEW: " + SchonhageStrassen.class.getSimpleName() + k);
+
+    this.modulusExponent = k.modulusExponent;
+    this.D = k.D;
+    
+    final int orderOfTwo = modulusExponent << 1;
+    this.D_inverse = new RootOfUnity(orderOfTwo - D.exponent, false, modulusExponent);
+    this.bitsPerElement = k.bitsPerElement;
+    this.Z = k.Z;
+
+    zeta = new RootOfUnity[D.value];
+    zeta[0] = new RootOfUnity(0, false, modulusExponent);
+    final int z = orderOfTwo >> D.exponent;
+    zeta[1] = z == modulusExponent?
+        new RootOfUnity(0, true, modulusExponent): new RootOfUnity(z, false, modulusExponent);
+    for(int i = 2; i < zeta.length; i++) {
+      zeta[i] = new RootOfUnity(zeta[i - 1].shift + zeta[1].shift,
+                                zeta[i - 1].negation, modulusExponent);
+    }
+
+    validate();
+  }
+
+  private void validate() {
+    // require: modulus > D M^2, where M is the digit limit.
+    if (modulusExponent < D.exponent + (bitsPerElement.value << 1)) {
+      Print.print("this = " + this);
+      throw new IllegalArgumentException(
+          "m < D.exponent + 2*bitsPerElement,\n  m=" + modulusExponent
+          + ", D=" + D + ", bitsPerElement=" + bitsPerElement);
+    }
+    // require: D | orderOfTwo
+    final int orderOfTwo = modulusExponent << 1;
+    if ((orderOfTwo & D.mask) != 0)
+      throw new IllegalArgumentException();
+    // require: digitsPerElement < digitsPerArray
+//    final int digitsPerElement = bitsPerElement.value >> Z.bitsPerDigit.exponent;
+//    if (digitsPerElement > Z.digitsPerArray.value)
+//      throw new IllegalArgumentException(digitsPerElement
+//          + " = digitsPerElement > Z.digitsPerArray = " + Z.digitsPerArray);
+  }
+
+  public long digitsPerOperand() {
+    //digitsPerOperand = (D.value >> 1)*(bitsPerElement/bitsPerDigit);
+    final int left = bitsPerElement.exponent - Z.bitsPerDigit.exponent - 1;
+    return left > 0? (long)D.value << left: D.value >> -left;
+  }
+
+  public int digitsPerElement() {
+    return bitsPerElement.value >> Z.bitsPerDigit.exponent;
+  }
+
+  public static final Factory FACTORY = new Factory();
+  public static class Factory {
+    private static class Key {
+      final Zahlen Z;
+      final int modulusExponent;
+      final PowerOfTwo_int bitsPerElement;
+      final PowerOfTwo_int D;
+      
+      private Key(final int modulusExponent, final PowerOfTwo_int bitsPerElement,
+          final PowerOfTwo_int D, final Zahlen Z) {
+        this.modulusExponent = modulusExponent;
+        this.bitsPerElement = bitsPerElement;
+        this.D = D;
+        this.Z = Z;
+      }
+      
+      @Override
+      public String toString() {
+        return "[modulas=2^" + modulusExponent + " + 1"
+            + ", D=" + D
+            + ", bitsPerElement=" + bitsPerElement
+            + ", Z=" + Z.toBrief() + "]";
+      }
+
+      @Override
+      public int hashCode() {
+        return modulusExponent ^ bitsPerElement.value ^ D.value;
+      }
+
+      @Override
+      public boolean equals(Object obj) {
+        if (this == obj)
+          return true;
+        else if (obj instanceof Key) {
+          final Key that = (Key)obj;
+          return this.Z == that.Z
+              && this.D == that.D
+              && this.modulusExponent == that.modulusExponent
+              && this.bitsPerElement == that.bitsPerElement;
+        }
+        return false;
+      }
+    }
+    private final Map<Key, SchonhageStrassen> cache = new HashMap<Key, SchonhageStrassen>();
+
+    private SchonhageStrassen valueOf(final Key k) {
+      SchonhageStrassen ss = cache.get(k);
+      if (ss == null)
+        cache.put(k, ss = new SchonhageStrassen(k));
+      return ss;
+    }
+
+    /** For serialization */
+    public SchonhageStrassen valueOf(final int modulusExponent,
+        final PowerOfTwo_int bitsPerElement, final PowerOfTwo_int D, final Zahlen Z) {
+      return valueOf(new Key(modulusExponent, bitsPerElement, D, Z));
+    }
+
+    public SchonhageStrassen valueOf(final String s, final Zahlen Z) {
+      int i = 0;
+      int j = s.indexOf(", ", i);
+      final PowerOfTwo_int D = PowerOfTwo_int.valueOf(
+          Parse.parseIntVariable("D", s.substring(i, j)));
+
+      i = j + 2;
+      j = s.indexOf(", ", i);
+      final PowerOfTwo_int bitsPerElement = PowerOfTwo_int.valueOf(
+          Parse.parseIntVariable("bitsPerElement", s.substring(i, j)));
+
+      i = j + 2;
+      final int modulusExponent = Parse.parseIntVariable("modulusExponent", s.substring(i));
+
+      return FACTORY.valueOf(modulusExponent, bitsPerElement, D, Z);
+    }
+
+    /** For Map/Reduce tasks */
+    public SchonhageStrassen valueOf(final int D, final SchonhageStrassen ss) {
+      return valueOf(new Key(ss.modulusExponent,
+          ss.bitsPerElement, PowerOfTwo_int.valueOf(D), ss.Z));
+    }
+
+    private Set<PowerOfTwo_long> PRINTED_NUM_DIGITS = new TreeSet<PowerOfTwo_long>();
+    /** For initial use */
+    public SchonhageStrassen valueOf(final long numDigits, final Zahlen Z) {
+      final long highest = Long.highestOneBit(numDigits);
+      final PowerOfTwo_long digitsPerOperand = PowerOfTwo_long.valueOf(
+          highest == numDigits? numDigits: (highest << 1));
+
+      final int D_exponent = (digitsPerOperand.exponent + Z.bitsPerDigit.exponent + 1) >> 1;
+      final PowerOfTwo_int D = PowerOfTwo_int.values()[D_exponent < 4? 4: (D_exponent >> 1) << 1];
+
+      final PowerOfTwo_int bitsPerElement;
+      {
+        final int e = D.exponent - 1 - Z.bitsPerDigit.exponent;
+        final int bpe = (int)(e > 0? digitsPerOperand.value >> e: digitsPerOperand.value << -e);
+        bitsPerElement = PowerOfTwo_int.valueOf(bpe);
+      }
+
+      final int ss_exponent = Z.bitsPerDigit.toMultipleOf((D.exponent >> 1) + (bitsPerElement.value << 1));
+      final int modulusExponent = D.toMultipleOf(ss_exponent << 1) >> 1;
+
+      if (!PRINTED_NUM_DIGITS.contains(digitsPerOperand)) {
+        PRINTED_NUM_DIGITS.add(digitsPerOperand);
+        Print.beginIndentation("SchonhageStrassen.Factory.valueOf(numDigits=" + numDigits + "): ");
+        Print.println("digitsPerOperand = " + digitsPerOperand + " (highest=" + highest + ")");
+        Print.println("bitsPerElement   = " + bitsPerElement);
+        Print.println("D                = " + D); 
+        Print.println("modulusExponent  = " + modulusExponent + " (ss_e=" + ss_exponent + ")");
+        
+        final PowerOfTwo_long N = PowerOfTwo_long.valueOf(digitsPerOperand.value << (Z.bitsPerDigit.exponent + 1));
+        final double efficiency = ((N.value >> (D.exponent - 1)) + D.exponent)*1.0/modulusExponent;
+        Print.println("efficiency       = " + efficiency + " (N=" + N + ", n=" + modulusExponent + ")");
+        Print.endIndentation("");
+      }
+      return valueOf(new Key(modulusExponent, bitsPerElement, D, Z));
+    }
+    
+    public static void main(final String[] args) {
+      final Zahlen Z = Zahlen.FACTORY.valueOf(32, 1024, 1024); 
+      for(int i = 10; i < 31; i++) {
+        FACTORY.valueOf(1 << i, Z);
+      }
+    }
+  }
+
+  @Override
+  public String serialize() {
+    return "D=" + D.value
+         + ", bitsPerElement=" + bitsPerElement.value
+         + ", modulusExponent=" + modulusExponent;
+  }
+
+  /**
+   * Digit scrambling 
+   */
+  static void scramble(Zahlen.Element[] x) {
+    final int n = x.length;
+    int j = 0;
+    for(int i = 0; i < n - 1; i++) {
+      if (i < j) {
+        final Zahlen.Element tmp = x[i];
+        x[i] = x[j];
+        x[j] = tmp;
+      }
+      int k = n >> 1;
+      for(; k <= j; k >>= 1) j -= k;
+      j += k;
+    }
+  }
+
+  /** x += y */
+  public void plusEqual(final Zahlen.Element x, final int y) {
+    x.plusEqual(y).ssModEqual(modulusExponent);
+  }
+
+  /** x += y */
+  public void plusEqual(final Zahlen.Element x, final Zahlen.Element y) {
+    x.plusEqual(y).ssModEqual(modulusExponent);
+  }
+
+  /** x *= zeta^i */
+  public void multiplyEqual(final Zahlen.Element x, final int i) {
+    x.ssMultiplyEqual(zeta[i], modulusExponent);
+  }
+
+  /** x *= y */
+  public void multiplyEqual(final Zahlen.Element x, final Zahlen.Element y) {
+    x.multiplyEqual(y, null).ssModEqual(modulusExponent);
+  }
+
+  /** x[i] *= y[i] */
+  public void componentwiseMultiplications(
+      final Zahlen.Element[] x, final Zahlen.Element[] y,
+      final JavaUtil.WorkGroup workers) {
+    if (workers == null) {
+      for(int i = 0; i < x.length; i++) {
+        x[i].multiplyEqual(y[i], null).ssModEqual(modulusExponent);
+      }
+    } else {
+      final String postfix = "] mod (2^" + modulusExponent + " + 1)";
+      for(int i = 0; i < x.length; i++) {
+        final int index = i;
+        workers.submit("x[" + i + "] *= y[" + i + postfix, new Runnable() {
+          @Override
+          public void run() {
+            x[index].multiplyEqual(y[index], null).ssModEqual(modulusExponent);
+          }
+        });
+      }
+      workers.waitUntilZero();
+    }
+  }
+
+  /** Schonhage-Strassen Integer Multiplication */
+  public Zahlen.Element multiplyEquals(final Zahlen.Element x, final Zahlen.Element y,
+      final FastFourierTransform algorithm, final JavaUtil.WorkGroup workers) {
+    if (PRINT_LEVEL.is(Print.Level.VERBOSE)) {
+      timer.tick("multiply(x.numberOfBits()=" + x.numberOfBits_long()
+          + ", y.numberOfBits()=" + y.numberOfBits_long() + ")");
+    }
+
+    //split
+    final Zahlen.Element[] X = x.split(bitsPerElement.value, D.value);
+    if (PRINT_LEVEL.is(Print.Level.TRACE))
+      Print.print("X", X);
+    final Zahlen.Element[] Y = y.split(bitsPerElement.value, D.value);
+    if (PRINT_LEVEL.is(Print.Level.TRACE))
+      Print.print("Y", Y);
+
+    //x = DFT(x)
+    algorithm.fft(X, workers);
+    if (PRINT_LEVEL.is(Print.Level.VERBOSE))
+      timer.tick(algorithm.getClass().getSimpleName() + ".dft X.length=" + X.length);
+    if (PRINT_LEVEL.is(Print.Level.TRACE))
+      Print.print("DFT(X)", X);
+
+    //y = DFT(y)
+    algorithm.fft(Y, workers);
+    if (PRINT_LEVEL.is(Print.Level.VERBOSE))
+      timer.tick(algorithm.getClass().getSimpleName() + ".dft Y.length=" + Y.length);
+    if (PRINT_LEVEL.is(Print.Level.TRACE))
+      Print.print("DFT(Y)", Y);
+
+    //x *= y
+    long d = 0;
+    long b = 0;
+    for(int i = 0; i < X.length; i++) {
+      d += X[i].numberOfDigits() + Y[i].numberOfDigits();
+      b += X[i].numberOfBits_long() + Y[i].numberOfBits_long();
+    }
+    componentwiseMultiplications(X, Y, workers);
+    if (PRINT_LEVEL.is(Print.Level.VERBOSE))
+      timer.tick("Componentwise-Multiplications: "
+          + X.length + " operations, average "
+          + String.format("%.2f digits, %.2f bits", d/2.0/X.length, b/2.0/X.length));
+    if (PRINT_LEVEL.is(Print.Level.TRACE))
+      Print.print("DFT(X)*DFT(Y)", X);
+
+    //DFT^{-1}(x)
+    algorithm.fft_inverse(X, workers);
+    if (PRINT_LEVEL.is(Print.Level.VERBOSE))
+      timer.tick(algorithm.getClass().getSimpleName() + ".dft_inverse, X.length=" + X.length);
+    normalize(X);
+    if (PRINT_LEVEL.is(Print.Level.VERBOSE))
+      timer.tick("Normalize");
+    if (PRINT_LEVEL.is(Print.Level.TRACE))
+      Print.print("DFT^-1", X);
+
+    //carrying
+    carrying(X);
+    if (PRINT_LEVEL.is(Print.Level.VERBOSE))
+      timer.tick("Carrying");
+
+    if (PRINT_LEVEL.is(Print.Level.TRACE)) {
+      Print.print("return", X);
+    }
+
+    x.combine(X, bitsPerElement.value >> Z.bitsPerDigit.exponent);
+    for(int i = 0; i < D.value; i++) {
+      X[i].reclaim();
+      Y[i].reclaim();
+    }
+    return x;
+  }
+
+  /** Normalize reverse DFT */
+  public void normalize(Zahlen.Element[] x) {
+    for(int i = 0; i < x.length; i++) {
+      x[i].ssMultiplyEqual(D_inverse, modulusExponent);
+    }
+  }
+
+  public void carrying(final Zahlen.Element[] z) {
+    final int exponent_in_digits = this.digitsPerElement();
+
+    Zahlen.Element carry = Z.newElement();
+    for(int i = 0; i < D.value; i++) {
+      z[i].plusEqual(carry);
+      carry.reclaim();
+      carry = z[i].divideRemainderEqual(exponent_in_digits);
+    }
+    carry.reclaim();
+  }
+
+  @Override
+  public String toString() {
+    final StringBuilder b = new StringBuilder("[").append(zeta[0]);
+    int i = 1;
+    for(; i < zeta.length && i < 10; i++)
+      b.append(", ").append(zeta[i]);
+    if (i < zeta.length)
+      b.append(", ...");
+    b.append("]");
+    
+    return getClass().getSimpleName()
+        + "\n  D              = " + D
+        + "\n  D^(-1)         = " + D_inverse
+        + "\n  modulus        = 2^" + modulusExponent + " + 1"
+        + "\n  bitsPerElement = " + bitsPerElement
+        + "\n  zeta           = " + b;
+  }
+  //////////////////////////////////////////////////////////////////////////////
+  final DiscreteFourierTransform discretefouriertransform = new DiscreteFourierTransform();
+
+  /** Compute DFT directly from the definition. */
+  class DiscreteFourierTransform implements FastFourierTransform {
+    void dft(final Zahlen.Element[] x, final boolean inverse) {
+//      Print.beginIndentation("DiscreteFourierTransform.dft: inverse = " + inverse);
+//      for(int k = 0; k < x.length; k++) {
+//        Print.println("x[" + k + "] = " + x[k]);
+//      }
+      final Zahlen.Element[] y = new Zahlen.Element[x.length];
+      for(int k = 0; k < y.length; k++) {
+        y[k] = Z.newElement();
+        for(int j = 0; j < x.length; j++) {
+          int index = (-j*k) % D.value;
+          if (index < 0)
+            index += D.value;
+          if (index > 0 && inverse)
+            index = D.value - index;
+
+//          Print.println("zeta[" + index + "] = " + zeta[index]);
+          final Zahlen.Element tmp = Z.newElement().set(x[j]);
+//          Print.println("x[" + j+ "] = " + x[j] + ", tmp = " + tmp);
+          tmp.ssMultiplyEqual(zeta[index], modulusExponent);
+          y[k].plusEqual(tmp);
+//          Print.println("y[" + k + "] = " + y[k] + ", tmp = " + tmp);
+          y[k].ssModEqualBySubstraction(modulusExponent);
+//          Print.println("y[" + k + "] = " + y[k]);
+          tmp.reclaim();
+        }
+      }
+      for(int k = 0; k < y.length; k++) {
+        x[k].reclaim();
+        x[k] = y[k];
+      }
+//      Print.endIndentation("reutrn x = " + x);
+    }
+
+    @Override
+    public void fft(Element[] x, final JavaUtil.WorkGroup workers) {dft(x, false);}
+    @Override
+    public void fft_inverse(Element[] x, final JavaUtil.WorkGroup workers) {dft(x, true);}
+  }
+  //////////////////////////////////////////////////////////////////////////////
+  final DanielsonLanczos danielsonlanczos = new DanielsonLanczos();
+
+  /** Compute DFT by recursion. */
+  class DanielsonLanczos implements FastFourierTransform {
+    void fft(final Zahlen.Element[] x, final int offset, final int step,
+        final int length_exponent, final boolean inverse) {
+      if (length_exponent == 0)
+        return;
+      else if (length_exponent == 1) {
+        final Zahlen.Element tmp = Z.newElement().set(x[offset]);
+        final int i = offset + step;
+        x[offset].plusEqual(x[i]);
+        x[offset].ssModEqualBySubstraction(modulusExponent);
+        
+        tmp.plusEqual(x[i].negateEqual());
+        tmp.ssModEqualByAddition(modulusExponent);
+        x[i].reclaim();
+        x[i] = tmp;
+      } else {
+        final int length = 1 << length_exponent;
+        final int halflength = length >> 1;
+        final int doublestep = step << 1;
+        fft(x, offset, doublestep, length_exponent - 1, inverse);
+        fft(x, offset + step, doublestep, length_exponent - 1, inverse);
+  
+        final Zahlen.Element[] y = new Zahlen.Element[length];
+        final int ratio_exponent = D.exponent - length_exponent;
+        for(int k = 0; k < y.length; k++) {
+          int index = -k;
+          if (index < 0)
+            index += length;
+          if (index > 0 && inverse)
+            index = length - index;
+          index <<= ratio_exponent;
+        
+          final int even_k = offset + doublestep*(k < halflength? k: k - halflength);
+          final int odd_k = even_k + step;
+          y[k] = Z.newElement().set(x[odd_k]);
+          y[k].ssMultiplyEqual(zeta[index], modulusExponent);
+          y[k].plusEqual(x[even_k]);
+          y[k].ssModEqualBySubstraction(modulusExponent);
+        }
+  
+        for(int k = 0; k < y.length; k++) {
+          final int j = offset + step*k;
+          x[j].reclaim();
+          x[j] = y[k];
+        }
+      }
+    }
+
+    @Override
+    public void fft(Element[] x, final JavaUtil.WorkGroup workers) {
+      final int exponent = Integer.numberOfTrailingZeros(x.length);
+      fft(x, 0, 1, exponent, false);
+    }
+
+    @Override
+    public void fft_inverse(Element[] x, final JavaUtil.WorkGroup workers) {
+      final int exponent = Integer.numberOfTrailingZeros(x.length);
+      fft(x, 0, 1, exponent, true);
+    }
+  }
+  //////////////////////////////////////////////////////////////////////////////
+  public final Parallel parallel = new Parallel();
+
+  /** Compute DFT by recursion. */
+  public class Parallel implements FastFourierTransform {
+    private void inner(final int k0, final PowerOfTwo_int K_step,
+        final PowerOfTwo_int J, final int ratio_exponent,
+        final Zahlen.Element[] x, final int offset, final PowerOfTwo_int step,
+        final PowerOfTwo_int length, final boolean inverse,
+        final Zahlen.Element[] x_tmp, final JavaUtil.WorkGroup workers) {
+      //inner DFT
+      int start = offset + (k0 << step.exponent);
+      if (PRINT_LEVEL.is(Print.Level.TRACE))
+        Print.println("inner DFT: k0 = " + k0);
+      fft(x, start, K_step, J, inverse, x_tmp, null);
+
+      //scale multiplication
+      for(int j0 = 0; j0 < J.value; j0++) {
+        int index = j0*k0;
+        if (index > 0 && inverse)
+          index = length.value - index;
+        index <<= ratio_exponent;
+
+        x[start].ssMultiplyEqual(zeta[index], modulusExponent);
+        start += K_step.value;
+      }
+    }
+
+    void fft(final Zahlen.Element[] x, final int offset, final PowerOfTwo_int step,
+        final PowerOfTwo_int length, final boolean inverse,
+        final Zahlen.Element[] x_tmp, final JavaUtil.WorkGroup workers) {
+      if (length.value == 1)
+        return;
+      else if (length.value == 2) {
+        final Zahlen.Element tmp = Z.newElement().set(x[offset]);
+        final int i = offset + step.value;
+        x[offset].plusEqual(x[i]);
+        x[offset].ssModEqualBySubstraction(modulusExponent);
+        
+        tmp.plusEqual(x[i].negateEqual());
+        tmp.ssModEqualByAddition(modulusExponent);
+        x[i].reclaim();
+        x[i] = tmp;
+      } else {
+        final int ratio_exponent = D.exponent - length.exponent;
+
+        final PowerOfTwo_int J = PowerOfTwo_int.values()[length.exponent >> 1];
+        final PowerOfTwo_int K = PowerOfTwo_int.values()[length.exponent - J.exponent];
+
+        if (PRINT_LEVEL.is(Print.Level.TRACE)) {
+          Print.beginIndentation("ParallelDft.dft");
+          Print.println("offset=" + offset + ", step=" + step
+            + ", length=" + length + "=2^" + length.exponent
+            + ", J=" + J + ", K=" + K);
+        }
+
+        final PowerOfTwo_int K_step = PowerOfTwo_int.values()[step.exponent + K.exponent];
+        if (workers == null) {
+          for(int k0 = 0; k0 < K.value; k0++) {
+            inner(k0, K_step, J, ratio_exponent, x, offset, step, length, inverse, x_tmp, workers);
+          }
+        } else {
+          for(int i = 0; i < K.value; i++) {
+            final int k0 = i;
+            workers.submit("k0=" + k0, new Runnable() {
+              @Override
+              public void run() {
+                inner(k0, K_step, J, ratio_exponent, x, offset, step, length, inverse, x_tmp, workers);
+              }
+            });
+          }
+          workers.waitUntilZero();
+        }
+
+        if (workers == null) {
+          int start = offset;
+          for(int j0 = 0; j0 < J.value; j0++) {
+            //outer DFT
+            fft(x, start, step, K, inverse, x_tmp, null);
+            start += K_step.value;
+          }
+        } else {
+          for(int j0 = 0; j0 < J.value; j0++) {
+            //outer DFT
+            final int start = (j0 << K_step.exponent) + offset;
+            workers.submit("j0=" + j0, new Runnable() {
+              @Override
+              public void run() {
+                fft(x, start, step, K, inverse, x_tmp, null);
+              }
+            });
+          }
+          workers.waitUntilZero();
+        }
+        
+        //Transpose
+        synchronized(x_tmp) {
+          System.arraycopy(x, offset, x_tmp, offset, (step.value << length.exponent) - step.value + 1);
+          for(int j1 = 0; j1 < K.value; j1++) {
+            int x_tmp_i = j1 << step.exponent;
+            int xi = offset + (x_tmp_i << J.exponent);
+            x_tmp_i += offset;
+  
+            for(int j0 = 0; j0 < J.value; j0++) {
+              x[xi] = x_tmp[x_tmp_i];
+              xi += step.value;
+              x_tmp_i += K_step.value;
+            }
+          }
+          if (PRINT_LEVEL.is(Print.Level.TRACE))
+            Print.endIndentation("return");
+        }
+      }
+    }
+
+    @Override
+    public void fft(Element[] x, final JavaUtil.WorkGroup workers) {
+      fft(x, 0, PowerOfTwo_int.TWO_00, PowerOfTwo_int.valueOf(x.length),
+          false, new Element[x.length], workers);
+    }
+
+    @Override
+    public void fft_inverse(Element[] x, final JavaUtil.WorkGroup workers) {
+      fft(x, 0, PowerOfTwo_int.TWO_00, PowerOfTwo_int.valueOf(x.length),
+          true, new Element[x.length], workers);
+    }
+  }
+  //////////////////////////////////////////////////////////////////////////////
+  public final CooleyTukey cooleytukey = new CooleyTukey();
+
+  /**
+   * Cooley-Tukey, decimation-in-time FFT
+   */
+  public class CooleyTukey implements FastFourierTransform {
+    /**
+     * Cooley-Tukey without digit-scrambling.
+     */
+    void fft_withoutScramble(final Zahlen.Element[] x, final boolean inverse) {
+      final boolean forward = !inverse;
+      int m_e = 0;
+      for(int m = 1; m < D.value; m <<= 1) {
+        final int two_m = m << 1;
+
+        for(int j = 0; j < m; j++) {
+          int index = -j<<(D.exponent - m_e - 1);
+          if (index < 0)
+            index += D.value;
+          if (index > 0 && forward)
+            index = D.value - index;
+          final RootOfUnity z = zeta[index];
+
+          for(int i = j; i < D.value; i += two_m) {
+            final int iPm = i + m;
+            final Zahlen.Element b = Z.newElement();
+            b.set(x[iPm].ssMultiplyEqual(z, modulusExponent));
+
+            x[iPm].negateEqual().plusEqual(x[i]);
+            x[iPm].ssModEqualByAddition(modulusExponent);
+
+            x[i].plusEqual(b);
+            x[i].ssModEqualBySubstraction(modulusExponent);
+
+            b.reclaim();
+          }
+        }
+        m_e++;
+      }
+    }
+
+    @Override
+    public void fft(Element[] x, final JavaUtil.WorkGroup workers) {
+      scramble(x);
+      fft_withoutScramble(x, false);
+    }
+
+    @Override
+    public void fft_inverse(Element[] x, final JavaUtil.WorkGroup workers) {
+      scramble(x);
+      fft_withoutScramble(x, true);
+    }
+  }
+  //////////////////////////////////////////////////////////////////////////////
+  final GentlemanSande gentlemansande = new GentlemanSande();
+
+  /**
+   * Gentleman-Sande, decimation-in-frequency FFT
+   */
+  class GentlemanSande implements FastFourierTransform {
+    /**
+     * Gentleman-Sande without digit-scrambling
+     */
+    void fft_withoutScramble(final Zahlen.Element[] x, final boolean inverse) {
+      final boolean forward = !inverse;
+      int m_eP1 = D.exponent;
+      int two_m = D.value;
+      for(int m = D.value >>> 1; m >= 1; m >>>= 1) {
+        for(int j = 0; j < m; j++) {
+          int index = -j << (D.exponent - m_eP1);
+          if (index < 0)
+            index += D.value;
+          if (index > 0 && forward)
+            index = D.value - index;
+          final RootOfUnity z = zeta[index];
+
+          for(int i = j; i < D.value; i += two_m) {
+            final int iPm = i + m;
+            final Zahlen.Element b = x[iPm];
+
+            x[iPm] = Z.newElement().set(x[i]);
+            x[i].plusEqual(b);
+            x[i].ssModEqualBySubstraction(modulusExponent);
+            
+            x[iPm].plusEqual(b.negateEqual());
+            x[iPm].ssModEqualByAddition(modulusExponent);
+            x[iPm].ssMultiplyEqual(z, modulusExponent);
+            
+            b.reclaim();
+          }
+        }
+        m_eP1--;
+        two_m = m;
+      }
+    }
+    
+    @Override
+    public void fft(Element[] x, final JavaUtil.WorkGroup workers) {
+      fft_withoutScramble(x, false);
+      scramble(x);
+    }
+
+    @Override
+    public void fft_inverse(Element[] x, final JavaUtil.WorkGroup workers) {
+      fft_withoutScramble(x, true);
+      scramble(x);
+    }
+  }
+  //////////////////////////////////////////////////////////////////////////////
+  final GentlemanSande_CooleyTukey gentlemansande_cooleytukey = new GentlemanSande_CooleyTukey();
+
+  class GentlemanSande_CooleyTukey implements FastFourierTransform {
+    @Override
+    public void fft(Element[] x, final JavaUtil.WorkGroup workers) {
+      gentlemansande.fft_withoutScramble(x, false);
+    }
+    @Override
+    public void fft_inverse(Element[] x, final JavaUtil.WorkGroup workers) {
+      cooleytukey.fft_withoutScramble(x, true);
+    }
+  }
+  //////////////////////////////////////////////////////////////////////////////
+  /**
+   * Fast Fourier Transform over Schonhage-Strassen modular.
+   */
+  public interface FastFourierTransform {
+    void fft(final Zahlen.Element[] x, final JavaUtil.WorkGroup workers);
+    void fft_inverse(final Zahlen.Element[] x, final JavaUtil.WorkGroup workers);
+  }
+  
+  final FastFourierTransform[] algorithms = {
+      cooleytukey,
+      parallel,
+      gentlemansande_cooleytukey,
+      gentlemansande,
+      danielsonlanczos,
+//    discretefouriertransform,
+  };
+}
Index: src/examples/org/apache/hadoop/mp/math/PowerOfTwo_int.java
===================================================================
--- src/examples/org/apache/hadoop/mp/math/PowerOfTwo_int.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/math/PowerOfTwo_int.java	(revision 0)
@@ -0,0 +1,107 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.math;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.hadoop.mp.util.Print;
+import org.apache.hadoop.mp.util.serialization.DataSerializable;
+import org.apache.hadoop.mp.util.serialization.StringSerializable;
+
+public enum PowerOfTwo_int implements Print.Brief, Print.Detail,
+    DataSerializable<Void>, StringSerializable {
+  TWO_00(0), TWO_01(1), TWO_02(2), TWO_03(3), TWO_04(4),
+  TWO_05(5), TWO_06(6), TWO_07(7), TWO_08(8), TWO_09(9),
+  TWO_10(10), TWO_11(11), TWO_12(12), TWO_13(13), TWO_14(14),
+  TWO_15(15), TWO_16(16), TWO_17(17), TWO_18(18), TWO_19(19),
+  TWO_20(20), TWO_21(21), TWO_22(22), TWO_23(23), TWO_24(24),
+  TWO_25(25), TWO_26(26), TWO_27(27), TWO_28(28), TWO_29(29),
+  TWO_30(30);
+
+  /** value is a power of 2 */
+  public final int value;
+  /** 2^exponent = value */
+  public final int exponent;
+  /** mask = value - 1 */
+  public final int mask;
+  /** reverseMask = ~mask */
+  public final int reverseMask;
+  
+  private PowerOfTwo_int(final int e) {
+    exponent = e;
+    value = 1 << exponent;
+    mask = value - 1;
+    reverseMask = ~mask;
+  }
+
+  /** Is n a multiple of this? */
+  public void checkIsMultiple(final int n) {
+    if ((n & mask) != 0)
+      throw new IllegalArgumentException("(n & mask) != 0, n="
+          + n + ", this=" + this);
+  }
+  
+  /** Is n a multiple of this? */
+  public int toMultipleOf(final int n) {
+    return n + ((value - (n & mask)) & mask);
+  }
+  
+  @Override
+  public String toBrief() {return "2^" + exponent;}
+  @Override
+  public String serialize() {return toBrief() + " (=" + value + ")";}
+  @Override
+  public String toString() {return serialize();}
+  @Override
+  public void printDetail(final String firstlineprefix) {
+    Print.print(firstlineprefix);
+    Print.print(this);
+    Print.println(String.format(", mask=%08X, reverseMask=%08X", mask, reverseMask));
+  }
+
+  public static final StringSerializable.ValueOf<PowerOfTwo_int> VALUE_OF_STR
+      = new StringSerializable.ValueOf<PowerOfTwo_int>() {
+    @Override
+    public PowerOfTwo_int valueOf(final String s) {
+      final int i = s.indexOf("2^") + 2;
+      final int j = s.indexOf(" (=", i);
+      return values()[Integer.parseInt(s.substring(i, j))];    
+    }
+  };
+
+  @Override
+  public Void serialize(DataOutput out) throws IOException {
+    out.writeInt(ordinal());
+    return null;
+  }
+
+  public static PowerOfTwo_int valueOf(DataInput in) throws IOException {
+    return values()[in.readInt()];    
+  }
+
+  public static PowerOfTwo_int valueOf(final int n) {
+    if (n <= 0)
+      throw new IllegalArgumentException(n + " = n < 0");
+    final int b = Integer.bitCount(n);
+    if (b != 1)
+      throw new IllegalArgumentException(b + " = Integer.bitCount(n) != 1");
+    return values()[Integer.numberOfTrailingZeros(n)];
+  }
+}
Index: src/examples/org/apache/hadoop/mp/math/MathUtil.java
===================================================================
--- src/examples/org/apache/hadoop/mp/math/MathUtil.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/math/MathUtil.java	(revision 0)
@@ -0,0 +1,58 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.math;
+
+public class MathUtil {
+  /** @return integer square root */
+  public static long sqrt_long(final long x) {
+    if (x == 0)
+      return 0;
+    else if (x < 0)
+      throw new ArithmeticException("sqrt(" + x + ")");
+    
+    final int half_nBits = (Long.SIZE - Long.numberOfLeadingZeros(x)) >> 1;
+    long upper;
+    long lower;
+    {
+      final long mid = x >> half_nBits;
+      final long r = x - mid*mid;
+      if (r >= 0 && r <= (mid << 1)) {
+        return mid;
+      } else if (r > 0) {
+        upper = x >> (half_nBits - 1);
+        lower = mid;
+      } else {
+        upper = mid;
+        lower = x >> (half_nBits + 1);
+      }
+    }
+
+    for(; upper - lower > 1; ) {
+      final long mid = (upper + lower) >> 1;
+      final long r = x - mid*mid;
+      if (r >= 0 && r <= (mid << 1)) {
+        return mid;
+      } else if (r > 0) {
+        lower = mid;
+      } else {
+        upper = mid;
+      }
+    }
+    return lower;
+  }
+}
Index: src/examples/org/apache/hadoop/mp/math/PowerOfTwo_long.java
===================================================================
--- src/examples/org/apache/hadoop/mp/math/PowerOfTwo_long.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/math/PowerOfTwo_long.java	(revision 0)
@@ -0,0 +1,112 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.math;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.hadoop.mp.util.Print;
+import org.apache.hadoop.mp.util.serialization.DataSerializable;
+import org.apache.hadoop.mp.util.serialization.StringSerializable;
+
+public enum PowerOfTwo_long implements Print.Brief, Print.Detail,
+  DataSerializable<Void>, StringSerializable {
+  TWO_00(0), TWO_01(1), TWO_02(2), TWO_03(3), TWO_04(4),
+  TWO_05(5), TWO_06(6), TWO_07(7), TWO_08(8), TWO_09(9),
+  TWO_10(10), TWO_11(11), TWO_12(12), TWO_13(13), TWO_14(14),
+  TWO_15(15), TWO_16(16), TWO_17(17), TWO_18(18), TWO_19(19),
+  TWO_20(20), TWO_21(21), TWO_22(22), TWO_23(23), TWO_24(24),
+  TWO_25(25), TWO_26(26), TWO_27(27), TWO_28(28), TWO_29(29),
+  TWO_30(30), TWO_31(31), TWO_32(32), TWO_33(33), TWO_34(34),
+  TWO_35(35), TWO_36(36), TWO_37(37), TWO_38(38), TWO_39(39),
+  TWO_40(40), TWO_41(41), TWO_42(42), TWO_43(43), TWO_44(44),
+  TWO_45(45), TWO_46(46), TWO_47(47), TWO_48(48), TWO_49(49),
+  TWO_50(50), TWO_51(51), TWO_52(52), TWO_53(53), TWO_54(54),
+  TWO_55(55), TWO_56(56), TWO_57(57), TWO_58(58), TWO_59(59),
+  TWO_60(60), TWO_61(61), TWO_62(62);
+
+  /** value is a power of 2 */
+  public final long value;
+  /** 2^exponent = value */
+  public final int exponent; 
+  /** mask = value - 1 */
+  public final long mask;
+  /** reverseMask = ~mask */
+  public final long reverseMask;
+  
+  private PowerOfTwo_long(final int e) {
+    exponent = e;
+    value = 1L << exponent;
+    mask = value - 1;
+    reverseMask = ~mask;
+  }
+
+  /** Is n a multiple of this? */
+  public void checkIsMultiple(final long n) {
+    if ((n & mask) != 0)
+      throw new IllegalArgumentException("(n & mask) != 0, n="
+          + n + ", this=" + this);
+  }
+
+  @Override
+  public String toBrief() {return "2^" + exponent;}
+  @Override
+  public String serialize() {return toBrief() + " (=" + value + ")";}
+  @Override
+  public String toString() {return serialize();}
+  @Override
+  public void printDetail(final String firstlineprefix) {
+    Print.print(firstlineprefix);
+    Print.print(this);
+    Print.println(String.format(", mask=%016X, reverseMask=%016X", mask, reverseMask));
+  }
+
+  public static final StringSerializable.ValueOf<PowerOfTwo_long> VALUE_OF_STR
+      = new StringSerializable.ValueOf<PowerOfTwo_long>() {
+    @Override
+    public PowerOfTwo_long valueOf(final String s) {
+      final int i = s.indexOf("2^") + 2;
+      final int j = s.indexOf(" (=", i);
+      return values()[Integer.parseInt(s.substring(i, j))];    
+    }
+  };
+
+  @Override
+  public Void serialize(DataOutput out) throws IOException {
+    out.writeInt(ordinal());
+    return null;
+  }
+
+  public static PowerOfTwo_long valueOf(DataInput in) throws IOException {
+    return values()[in.readInt()];    
+  }
+
+  public static PowerOfTwo_long valueOf(final long n) {
+    if (n <= 0)
+      throw new IllegalArgumentException(n + " = n < 0");
+    final int b = Long.bitCount(n);
+    if (b != 1)
+      throw new IllegalArgumentException(b + " = Long.bitCount(n) != 1");
+    return values()[Long.numberOfTrailingZeros(n)];
+  }
+
+  public static boolean isPowerOfTwo(final long n) {
+    return n > 0 && Long.bitCount(n) == 1;
+  }
+}
Index: src/examples/org/apache/hadoop/mp/math/ArbitraryPrecision.java
===================================================================
--- src/examples/org/apache/hadoop/mp/math/ArbitraryPrecision.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/math/ArbitraryPrecision.java	(revision 0)
@@ -0,0 +1,119 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.math;
+
+import java.util.Random;
+
+import org.apache.hadoop.mp.util.Checksum;
+import org.apache.hadoop.mp.util.Container;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Print;
+import org.apache.hadoop.mp.util.Recycler;
+import org.apache.hadoop.mp.util.serialization.DataSerializable;
+import org.apache.hadoop.mp.util.serialization.StringSerializable;
+
+/** Numbers implemented with arbitrary precision arithmetic. */
+abstract class ArbitraryPrecision<T, E extends ArbitraryPrecision<T,E>.Element>
+    implements DataSerializable<Void>, StringSerializable, Print.Brief {
+  /** Get the key of this object. */
+  abstract String getKey();
+
+  /** @return a new element. */
+  public final E newElement() {return elementrecycler.newObject();}
+  /** Call the private element constructor. */
+  abstract E newElement_private();
+
+  public abstract E random(final int nDigit, final Random r);
+  /////////////////////////////////////////////////////////////////////////////
+  /** Elements */
+  public abstract class Element
+      implements Comparable<E>, Container<T>, DataSerializable<Checksum>,
+                 Print.Brief, Print.Detail {
+    @Override
+    public final T get() {
+      @SuppressWarnings("unchecked")
+      final T t = (T)ArbitraryPrecision.this;
+      return t;
+    }
+
+    /** Set this to zero. */
+    abstract E setZero();
+    /** Set this to that. */
+    abstract E set(E that);
+
+    /** Check whether their containers are the same. */
+    public void check(E that) {
+      if (this.get() != that.get())
+        throw new IllegalArgumentException("this.get() != that.get()"
+            + "\nthis=" + this.toBrief() + ", this.get()=" + this.get()
+            + "\nthat=" + that.toBrief() + ", that.get()=" + that.get());
+    }
+
+    @Override
+    public final boolean equals(Object that) {
+      if (this == that)
+        return true;
+      else if (this.getClass() == that.getClass()) {
+        @SuppressWarnings("unchecked")
+        final E t = (E)that;
+        return this.compareTo(t) == 0;
+      } else
+        return false;
+    }
+
+    public final void reclaim() {
+      @SuppressWarnings("unchecked")
+      final E e = (E)this;
+      elementrecycler.reclaim(e);
+    }
+
+    public abstract void print(final int digitsPerLine);
+
+    /** Shift this to left in bits. */
+    public abstract E shiftLeftEqual_bits(final long shift_in_bits);
+    /** Shift this to right in bits. */
+    public abstract E shiftRightEqual_bits(final long shift_in_bits);
+
+    /** this = -this */
+    public abstract E negateEqual();
+    /** this += that */
+    public abstract E plusEqual(final E that);
+    /** this *= that */
+    public abstract E multiplyEqual(final E that, final JavaUtil.WorkGroup workers);
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  protected static final int RECYCLER_SIZE = 1 << 16;
+  private final ElementRecycler elementrecycler = new ElementRecycler();
+
+  private final class ElementRecycler extends Recycler<E> {
+    private ElementRecycler() {super(RECYCLER_SIZE);}
+
+    @Override
+    public final E newObject() {
+      if (size > 0) {
+        size--;
+        @SuppressWarnings("unchecked")
+        final E a = (E)array[size];
+        array[size] = null;
+        a.setZero();
+        return a;
+      } else
+        return newElement_private();
+    }
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/newton/DistMpSqrt.java
===================================================================
--- src/examples/org/apache/hadoop/mp/newton/DistMpSqrt.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/newton/DistMpSqrt.java	(revision 0)
@@ -0,0 +1,79 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.newton;
+
+import java.util.Arrays;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.mp.Function;
+import org.apache.hadoop.mp.FunctionDescriptor;
+import org.apache.hadoop.mp.ZahlenDescriptor;
+import org.apache.hadoop.mp.fft.DistFft;
+import org.apache.hadoop.mp.fft.DistMpMult;
+import org.apache.hadoop.mp.math.PowerOfTwo_int;
+import org.apache.hadoop.mp.math.PowerOfTwo_long;
+import org.apache.hadoop.mp.math.SchonhageStrassen;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Print;
+
+public class DistMpSqrt {
+  public static final String VERSION = "20110308";
+
+  static final Print.Level PRINT_LEVEL = Print.Level.VERBOSE;
+  static final boolean IS_VERBOSE = PRINT_LEVEL.is(Print.Level.VERBOSE);
+
+  private static final String PREFIX = DistMpMult.class.getSimpleName();
+  public static final String NAME = PREFIX.toLowerCase();
+  public static final String DESCRIPTION = "Distributed Multi-precision Sqrt";
+
+  static final AtomicBoolean printversions = new AtomicBoolean(false);
+
+  public static void printVersions() {
+    if (!printversions.getAndSet(true)) {
+      Print.println();
+      Print.println(DistFft.NAME + ".VERSION = " + DistFft.VERSION);
+      Print.println(NAME + ".VERSION = " + VERSION);
+      Print.println(NAME + ".LOCAL_THRESHOLD = " + LOCAL_THRESHOLD);
+      Print.printSystemInfo();
+    }
+  }
+
+  public static final PowerOfTwo_long LOCAL_THRESHOLD = PowerOfTwo_long.values()[16];
+
+  private static ZahlenDescriptor sqrt_local(final Function.Variable out,
+      final SchonhageStrassen schonhagestrassen, final Zahlen largeZ,
+      final PowerOfTwo_int J, final PowerOfTwo_int K,
+      final JavaUtil.Timer timer, final JavaUtil.WorkGroup workers,
+      final String dir, final Configuration conf,
+      final Function x) throws Exception {
+    final Function f = new Function.Sqrt(x);
+    if (IS_VERBOSE)
+      Print.beginIndentation("sqrt_local: " + out + " = " + f);
+
+    FunctionDescriptor.evaluateLocal(out, f, schonhagestrassen, largeZ, workers, dir, conf);
+    final ZahlenDescriptor p = new ZahlenDescriptor(out, J, K.value);
+    if (IS_VERBOSE)
+      Print.endIndentation("sqrt_local: return " + p);
+    if (timer != null) {
+      timer.tick("sqrt_local: " + out);
+    }
+    return p;
+  }
+}
Index: src/examples/org/apache/hadoop/mp/DistMpBase.java
===================================================================
--- src/examples/org/apache/hadoop/mp/DistMpBase.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/DistMpBase.java	(revision 0)
@@ -0,0 +1,224 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp;
+
+import java.io.IOException;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.io.IntWritable;
+import org.apache.hadoop.mapreduce.Job;
+import org.apache.hadoop.mapreduce.Partitioner;
+import org.apache.hadoop.mapreduce.TaskInputOutputContext;
+import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
+import org.apache.hadoop.mp.ZahlenSerialization.ZahlenOutputFormat;
+import org.apache.hadoop.mp.math.PowerOfTwo_int;
+import org.apache.hadoop.mp.math.SchonhageStrassen;
+import org.apache.hadoop.mp.math.Zahlen;
+import org.apache.hadoop.mp.util.JavaUtil;
+import org.apache.hadoop.mp.util.Print;
+import org.apache.hadoop.mp.util.serialization.ConfSerializable;
+
+
+public class DistMpBase implements ConfSerializable, Print.Detail {
+  public static final String VERSION = "20110124";
+
+  static final Print.Level PRINT_LEVEL = Print.Level.VERBOSE;
+  static final boolean IS_VERBOSE = PRINT_LEVEL.is(Print.Level.VERBOSE);
+
+  public static final String NAME = DistMpBase.class.getSimpleName().toLowerCase();
+  public static final String N_WORKERS_CONF_KEY = NAME + ".nWorkers";
+
+  private static final String PROPERTY_ZAHLEN = NAME + "." + Zahlen.class.getSimpleName();
+  private static final String PROPERTY_SCHONHAGE_STRASSEN = NAME + "." + SchonhageStrassen.class.getSimpleName();
+  private static final String PROPERTY_J = NAME + ".J";
+  private static final String PROPERTY_K = NAME + ".K";
+  private static final String PROPERTY_DIR = NAME + ".dir";
+
+  public final SchonhageStrassen schonhagestrassen;
+  public final PowerOfTwo_int J, K;
+  public final String dir;
+
+  public DistMpBase(final SchonhageStrassen schonhagestrassen,
+      final PowerOfTwo_int J, final PowerOfTwo_int K,
+      final String dir) {
+    this.schonhagestrassen = schonhagestrassen;
+    this.J = J;
+    this.K = K;
+    this.dir = dir;
+  }
+
+  public static DistMpBase valueOf(final Configuration conf) {
+    final Zahlen Z = Zahlen.FACTORY.valueOf(conf.get(PROPERTY_ZAHLEN));
+    final SchonhageStrassen schonhagestrassen = SchonhageStrassen.FACTORY.valueOf(
+        conf.get(PROPERTY_SCHONHAGE_STRASSEN), Z);
+    final PowerOfTwo_int J = PowerOfTwo_int.VALUE_OF_STR.valueOf(conf.get(PROPERTY_J));
+    final PowerOfTwo_int K = PowerOfTwo_int.VALUE_OF_STR.valueOf(conf.get(PROPERTY_K));
+    final String dir = conf.get(PROPERTY_DIR);
+    return new DistMpBase(schonhagestrassen, J, K, dir);
+  }
+
+  @Override
+  public String toString() {
+    return getClass().getSimpleName()
+        + "(J=" + J + ", K=" + K + ", dir=" + dir + ")";
+  }
+
+  @Override
+  public void printDetail(final String name) {
+    Print.beginIndentation(NAME + ": " + name);
+    Print.println("Z                 = " + schonhagestrassen.Z);
+    Print.println("schonhagestrassen = " + schonhagestrassen);
+    Print.println("J                 = " + J);
+    Print.println("K                 = " + K);
+    Print.println("dir               = " + dir);
+    Print.endIndentation();
+  }
+  
+  @Override
+  public void serialize(final Configuration conf) {
+    conf.set(PROPERTY_ZAHLEN, schonhagestrassen.Z.serialize());
+    conf.set(PROPERTY_SCHONHAGE_STRASSEN, schonhagestrassen.serialize());
+    conf.set(PROPERTY_J, J.serialize());
+    conf.set(PROPERTY_K, K.serialize());
+    conf.set(PROPERTY_DIR, dir);
+  }
+  
+  public static class TaskHelper {
+    public final TaskInputOutputContext<?,?,?,?> context;
+    public final JavaUtil.Timer timer = new JavaUtil.Timer(true, true);
+    private int step = 0;
+    
+    public TaskHelper(final TaskInputOutputContext<?,?,?,?> context, final String message) {
+      this.context = context;
+      Print.println("JobName      : " + context.getJobName());
+      Print.println("TaskAttemptID: " + context.getTaskAttemptID());
+      Print.printSystemInfo();
+    }
+
+    public void show(final String message) {
+      final String s = ++step + ") DONE " + message;
+      timer.tick(s);
+      Print.printMemoryInfo();
+      context.setStatus(s);
+      context.progress();
+    }
+
+    public static void write(final Zahlen.Element[] a, 
+        final int offset, final PowerOfTwo_int step, final int numElements,
+        TaskInputOutputContext<?,?,IntWritable,ZahlenSerialization.E> context
+        ) throws IOException, InterruptedException {
+      final IntWritable key = new IntWritable();
+      final ZahlenSerialization.E value = new ZahlenSerialization.E();
+      for(int j = 0; j < numElements; j++) {
+        final int i = (j << step.exponent) + offset;
+        if (j < 10 || j + 10 >= numElements)
+          Print.println("i=" + i + ") a[" + j + "]=" + a[j].toBrief());
+        else if (j == 10)
+          Print.println("...");
+    
+        key.set(i);
+        value.set(a[j]);
+        context.write(key, value);
+      }
+    }
+  }
+
+  /** Use the index as the partition. */
+  public static class IndexPartitioner<T> extends Partitioner<IntWritable, T> {
+    /** @return the index as the partition. */
+    @Override
+    public int getPartition(IntWritable index, T value, int numPartitions) {
+      return index.get();
+    }
+  }
+
+  public class MpJob {
+    public final FunctionDescriptor descriptor;
+    public final Job job;
+    public final String jobname;
+    
+    public MpJob(final Function input, final Function.Variable output,
+        final Configuration conf) throws IOException {
+      this(new FunctionDescriptor(input, output, J, K.value), conf);
+    }
+
+    public MpJob(final FunctionDescriptor descriptor,
+        final Configuration conf) throws IOException {
+      this.descriptor = descriptor;
+      if (IS_VERBOSE) {
+        Print.println("descriptor = " + descriptor);
+      }
+
+      //initialize a job
+      job = newJob(conf);
+
+      final Configuration jobconf = job.getConfiguration();
+      serialize(jobconf);
+      descriptor.serialize(jobconf);
+
+      FileOutputFormat.setOutputPath(job, descriptor.getOutputPath(dir));
+
+      jobname = jobName(descriptor);
+      job.setJobName(jobname);
+    }
+
+    /** @return whether the job is submitted. */
+    public boolean submit() throws IOException, InterruptedException, ClassNotFoundException {
+      final FileSystem fs = FileSystem.get(job.getConfiguration());
+      final Path outdir = ZahlenOutputFormat.getOutputPath(job);
+      final boolean b = fs.exists(outdir);
+      if (b) {
+        Print.println("outdir=" + outdir + " already exists.  Skipping job " + jobname);
+      } else {
+        job.submit();
+      }
+      return !b;
+    }
+    
+    public void wait4job(final boolean verbose) throws IOException, InterruptedException, ClassNotFoundException {
+      if (!job.waitForCompletion(verbose)) {
+        throw new IOException(jobname + " job failed.");
+      }
+    }
+  }
+
+  protected Job newJob(final Configuration conf) throws IOException {
+    //final Cluster cluster = new Cluster(JobTracker.getAddress(conf), conf);
+    final Job job = new Job(conf);
+    final Configuration jobconf = job.getConfiguration();
+    job.setJarByClass(getClass());
+    job.setNumReduceTasks(0);
+    
+    // disable task timeout
+    //jobconf.setLong(JobContext.TASK_TIMEOUT, 0);
+    jobconf.setLong("mapred.task.timeout", 0);
+    
+    // use speculative execution
+    jobconf.setBoolean("mapred.map.tasks.speculative.execution", true);
+    jobconf.setBoolean("mapred.reduce.tasks.speculative.execution", true);
+    
+    jobconf.setBoolean("mapred.compress.map.output", false);
+    return job; 
+  }
+
+  protected String jobName(final FunctionDescriptor f) {
+    return dir + ": " + f.output + " = " + f.functionString();
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/util/JavaUtil.java
===================================================================
--- src/examples/org/apache/hadoop/mp/util/JavaUtil.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/util/JavaUtil.java	(revision 0)
@@ -0,0 +1,289 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.util;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicInteger;
+
+
+/** Utility methods */
+public class JavaUtil {
+  /** Timer */
+  public static class Timer {
+    private final boolean isAccumulative;
+    private final long start = System.currentTimeMillis();
+    private long previous = start;
+  
+    /** Timer constructor
+     * @param isAccumulative  Is accumulating the time duration?
+     */
+    public Timer(final boolean isAccumulative, final boolean printStartMessage) {
+      this.isAccumulative = isAccumulative;
+      if (printStartMessage) {
+        final StackTraceElement[] stack = Thread.currentThread().getStackTrace();
+        final int last = stack.length - 1;
+        Print.beginIndentation("STARTUP " + new Date(start));
+        Print.println("Started at " + stack[last]);
+        Print.println("Printed at " + stack[Math.min(2, last)]);
+        Print.endIndentation();
+      }
+    }
+    
+    public long getStart() {return start;}
+  
+    /** Same as tick(null). */
+    public long tick() {return tick(null);}
+
+    /**
+     * Tick
+     * @param mess Output message.  No output if it is null.
+     * @return delta
+     */
+    public synchronized long tick(final Object mess) {
+      final long t = System.currentTimeMillis();
+      final long delta = t - (isAccumulative? start: previous);
+      if (mess != null) {
+        final String s = mess instanceof String? (String)mess: mess.toString();
+        Print.println(String.format("%15dms (=%-15s: %s", delta, Parse.millis2String(delta) + ")", s));
+      }
+      previous = t;
+      return delta;
+    }
+  }
+
+  /** Execute the callables by a number of threads */
+  public static <T, E extends Callable<T>> void execute(final int nThreads,
+      List<E> callables, JavaUtil.Timer timer
+      ) throws InterruptedException, ExecutionException {
+    final int n = callables.size();
+    timer.tick("EXECUTOR: " + n + " computation(s)");
+
+    final ExecutorService executor = Executors.newFixedThreadPool(nThreads); 
+    final List<Future<T>> futures = new ArrayList<Future<T>>(n);
+    for(int i = 0; i < n; i++) {
+      futures.add(executor.submit(callables.get(i)));
+    }
+
+    long sleeptime = Math.min(n*100L, 300*1000L);
+    for(int done = 0; done < n; ) {
+      Thread.sleep(sleeptime);
+
+      int count = 0;
+      for(Future<T> f : futures) {
+        if (f.isDone())
+          count++;
+      }
+      if (count > done) {
+        done = count;
+        sleeptime = Math.min((n-done)*100L + 1000L, 300*1000L);
+        final long ms = timer.tick();
+        final double total = (ms/(double)done)*n;
+        final double remaining = total - ms;
+        Print.println("EXECUTOR: " + done + "/" + n
+            + " done, estimated time: remaining=" + Parse.millis2String(remaining, 2)
+            + ", total=" + Parse.millis2String(total, 2)
+        		+ ", sleep=" + Parse.millis2String(sleeptime));
+      }
+    }
+  }
+  
+  public static class WorkGroup {
+    private final String name;
+    private final Timer timer;
+    private final AtomicInteger count = new AtomicInteger(0);
+    private final ExecutorService executor;
+    
+    public WorkGroup(final String name, final int nWorkers, final Timer timer) {
+      this.name = name;
+      this.timer = timer;
+      this.executor = Executors.newFixedThreadPool(nWorkers);
+      Print.println(getClass().getSimpleName() + ": Created " + name
+          + " with " + nWorkers + " threads.");
+    }
+
+    public synchronized void submit(final String task, final Runnable r) {
+      final int increment = count.incrementAndGet();
+      if (timer != null)
+        timer.tick("++" + name + ".count=" + increment + " for " + task);
+      executor.submit(new Callable<Object>() {
+        @Override
+        public Object call() throws Exception {
+          try {
+            r.run();
+          } catch(Throwable t) {
+            Print.print("In " + WorkGroup.class.getSimpleName() + " " + name
+                + ", " + task + " threw ");
+            Print.printStackTrace(t);
+            throw new Exception(t);
+          } finally {
+            final int decrement = count.decrementAndGet();
+            if (timer != null)
+              timer.tick("--" + name + ".count=" + decrement + " for " + task);
+          }
+          return null;
+        }
+      });
+    }
+
+    private static final int SLEEP_TIME = 100;
+    private static final int SLEEP_COUNT = 60000/SLEEP_TIME;
+
+    public void waitUntilZero() {waitUntil(0);}
+
+    public void waitUntil(final int n) {
+      int c;
+      for(int j = 1; (c = count.get()) > n; j = (j + 1) % SLEEP_COUNT) {
+        if (j == 0) {
+          if (timer != null)
+            timer.tick("wait4Zero " + name + ".count=" + c);
+        }
+        sleepms(SLEEP_TIME, null);
+      }
+    }
+  }
+  
+  public static Random newRandom(long seed) {
+    Print.println("seed = " + seed + "L");
+    return new Random(seed);
+  }
+
+  public static Random newRandom() {
+    final Random r = new Random();
+    final long seed = r.nextLong();
+    Print.println("seed = " + seed + "L");
+    r.setSeed(seed);
+    return r;
+  }
+
+  /** Combine a list of items. */
+  public static <T extends Combinable<T>> List<T> combine(Collection<T> items) {
+    final List<T> sorted = new ArrayList<T>(items);
+    if (sorted.size() <= 1)
+      return sorted;
+
+    Collections.sort(sorted);
+    //println("sorted", "", sorted);
+
+    final List<T> combined = new ArrayList<T>(items.size());
+    T prev = sorted.get(0);
+    for(int i = 1; i < sorted.size(); i++) {
+      final T curr = sorted.get(i);
+      final T c = curr.combine(prev);
+
+      if (c != null)
+        prev = c;
+      else {
+        combined.add(prev);
+        prev = curr;
+      }
+    }
+    combined.add(prev);
+    return combined;
+  }
+
+  public static int toInt(final long n) {
+    if (n > Integer.MAX_VALUE)
+      throw new ArithmeticException(n + " = n > Integer.MAX_VALUE = " + Integer.MAX_VALUE);
+    if (n < Integer.MIN_VALUE)
+      throw new ArithmeticException(n + " = n > Integer.MIN_VALUE = " + Integer.MIN_VALUE);
+    return (int)n;
+  }
+
+  public static byte toByte(int n) {
+    if (n > Byte.MAX_VALUE)
+      throw new ArithmeticException(n + " = n > Byte.MAX_VALUE = " + Byte.MAX_VALUE);
+    if (n < Byte.MIN_VALUE)
+      throw new ArithmeticException(n + " = n < Byte.MIN_VALUE = " + Byte.MIN_VALUE);
+    return (byte)n;
+  }
+
+  /** Check local directory. */
+  public static void checkDirectory(final File dir) {
+    if (!dir.exists())
+      if (!dir.mkdirs())
+        throw new IllegalArgumentException("!dir.mkdirs(), dir=" + dir);
+    if (!dir.isDirectory())
+      throw new IllegalArgumentException("dir (=" + dir + ") is not a directory.");
+  }
+
+  /** Create a writer of a local file. */
+  public static File createFile(final File dir,
+      final String prefix, final String suffix) throws FileNotFoundException {
+    if (dir != null)
+      checkDirectory(dir);
+
+    for(;;) {
+      final File f = new File(dir, prefix + "-" + Parse.currentTime2String() + suffix);
+      if (!f.exists()) {
+        Print.println("Create file " + f);
+        return f;
+      }
+
+      try {Thread.sleep(10);} catch (InterruptedException e) {}
+    }
+  }
+
+  public static void sleepms(final long ms, final String message) {
+    if (message != null)
+      Print.println(message + ": sleep " + Parse.millis2String(ms));
+    try {
+      Thread.sleep(ms);
+    } catch (InterruptedException e) {
+      Print.printStackTrace(e);
+    }
+  }
+
+  public static void sleepsecond(final long s, final String message) {
+    sleepms(s * 1000, message);
+  }
+
+  public static void main(String[] args) {
+    Print.printSystemInfo();
+    
+    final long a = 1L << 53;
+    final double d = 1.0/a;
+    final double e = 2*d;
+    final double x  = 1;
+    final double y = x + d;
+    final double z = x + e;
+    Print.println("a = " + a);
+    Print.println("d = " + d);
+    Print.println("e = " + e);
+    Print.println("x = " + x);
+    Print.println("y = " + y);
+    Print.println("z = " + z);
+    
+    {
+      double macheps = 1.0;
+      for(; 1.0 + (macheps/2.0) != 1.0; macheps /= 2.0);
+      Print.println( "Calculated Machine epsilon: " + macheps );
+    }
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/util/MachineComputable.java
===================================================================
--- src/examples/org/apache/hadoop/mp/util/MachineComputable.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/util/MachineComputable.java	(revision 0)
@@ -0,0 +1,31 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.util;
+
+import org.apache.hadoop.io.Writable;
+import org.apache.hadoop.mp.util.JavaUtil.Timer;
+import org.apache.hadoop.mp.util.serialization.ConfSerializable;
+
+/** {@link Machine}*/
+public interface MachineComputable<TYPE, RESULT extends MachineComputable.Result<RESULT>>
+    extends Partitionable<TYPE>, Writable, ConfSerializable {
+  /** Compute a result. */
+  public RESULT compute(int nThreads, Timer timer);
+  
+  public interface Result<R> extends Combinable<R>, Writable {}
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/util/Checksum.java
===================================================================
--- src/examples/org/apache/hadoop/mp/util/Checksum.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/util/Checksum.java	(revision 0)
@@ -0,0 +1,121 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.util;
+
+import java.io.ByteArrayOutputStream;
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
+
+import org.apache.hadoop.mp.util.serialization.DataSerializable;
+
+
+
+public class Checksum {
+  private static final ThreadLocal<Checksum> CHECKSUM = new ThreadLocal<Checksum>() {
+    protected Checksum initialValue() {return new Checksum();}
+  };
+
+  public static Checksum getChecksum() {return CHECKSUM.get();}
+
+  private final MessageDigest md5;
+  private final ByteBuffer buffer = ByteBuffer.allocate(1 << 16);
+
+  private Checksum() {
+    try {
+      md5 = MessageDigest.getInstance("MD5");
+    } catch (NoSuchAlgorithmException e) {
+      throw new RuntimeException(e);
+    }
+  }
+  
+  private void update() {
+    buffer.limit(buffer.position()).position(0);
+    md5.update(buffer);
+    buffer.limit(buffer.capacity()).position(0);
+  }
+
+  public long update(final long i) {
+    if (buffer.remaining() < 8)
+      update();
+    buffer.putLong(i);
+    return i;
+  }
+  
+  public int update(final int i) {
+    if (buffer.remaining() < 4)
+      update();
+    buffer.putInt(i);
+    return i;
+  }
+
+  public boolean update(final boolean b) {
+    if (buffer.remaining() < 1)
+      update();
+    buffer.put(b? (byte)1: (byte)0);
+    return b;
+  }
+
+  public void update(final int[] integers, final int start, final int end) {
+    for(int i = start; i < end; i++)
+      update(integers[i]);
+  }
+
+  public byte[] update(final byte[] bytes) {
+    update();
+    md5.update(bytes);
+    return bytes;
+  }
+
+  public byte[] update(final DataSerializable<?> ios) throws IOException {
+    //serialize the object
+    final ByteArrayOutputStream ba = new ByteArrayOutputStream();
+    final DataOutputStream baout = new DataOutputStream(ba);
+    ios.serialize(baout);
+    baout.flush();
+    
+    //update checksum
+    return update(ba.toByteArray());
+  }
+
+  private byte[] digest() {
+    if (buffer.position() > 0)
+      update();
+    return md5.digest();
+  }
+
+  public void writeDigest(final DataOutput out) throws IOException {
+    final byte[] d = digest();
+    out.writeInt(d.length);
+    out.write(d);
+  }
+
+  /** Read a checksum from in and then verify with this. */
+  public void readAndVerify(final DataInput in) throws IOException {
+    final byte[] checksum = new byte[in.readInt()];
+    in.readFully(checksum);
+
+    if (!Arrays.equals(digest(), checksum))
+      throw new IOException("Checksums not matched");
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/util/Container.java
===================================================================
--- src/examples/org/apache/hadoop/mp/util/Container.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/util/Container.java	(revision 0)
@@ -0,0 +1,29 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.util;
+
+/**
+ * A class is a Container if it contains an element. 
+ * @param <T> The generic type
+ */
+public interface Container<T> {
+  /**
+   * @return The contained element.
+   */
+  public T get(); 
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/util/Interval.java
===================================================================
--- src/examples/org/apache/hadoop/mp/util/Interval.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/util/Interval.java	(revision 0)
@@ -0,0 +1,100 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.util;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/** Interval [start, end) */
+public class Interval implements Partitionable<Interval>, Combinable<Interval> {
+  public final long start; //inclusive
+  public final long end;   //exclusive
+
+  /** Construct [start, end) */
+  public Interval(long start, long end) {
+    if (start >= end) {
+      throw new IllegalArgumentException("start = " + start + " <= end =" + end);
+    }
+    this.start = start;
+    this.end = end;
+  }
+
+  /** Is x in this interval? */
+  public boolean contains(long x) {return x >= start && x < end;}
+
+  @Override
+  public List<Interval> partition(int nParts) {
+    final long d = end - start;
+    if (d < nParts)
+      nParts = (int)d;
+    
+    final List<Interval> a = new ArrayList<Interval>();
+    final long size = d/nParts;
+    long remainder = d % nParts;
+    for(long x = start; x < end; ) {
+      long y = x + size;
+      if (remainder > 0) {
+        y++;
+        remainder--;
+      }
+      a.add(new Interval(x, y));
+      x = y;
+    }
+    return a;
+  }
+
+  @Override
+  public Interval combine(Interval that) {
+    if (this.start != that.end)
+      throw new IllegalArgumentException("this.start != that.end, this="
+          + this + ", that=" + that);
+    return new Interval(that.start, this.end);
+  }
+
+  @Override
+  public int compareTo(Interval that) {
+    final long d = this.start - that.start;
+    return d > 0? 1: d < 0? -1: 0;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (obj != null && obj instanceof Interval) {
+      final Interval that = ((Interval)obj);
+      return this.start == that.start && this.end == that.end;
+    }
+    return false;
+  }
+
+  @Override
+  public String toString() {
+    return "[" +  start + ", " + end + ")";
+  }
+
+  public static Interval valueOf(final String s, int beginIndex, int endIndex) {
+    beginIndex++;
+    final int i = s.indexOf(", ", beginIndex);
+    return new Interval(
+        Parse.string2long(s.substring(beginIndex, i)),
+        Parse.string2long(s.substring(i+2, endIndex-1)));
+  }
+
+  public static Interval valueOf(final String s) {
+    return valueOf(s, 0, s.length());
+  }
+}
Index: src/examples/org/apache/hadoop/mp/util/Machine.java
===================================================================
--- src/examples/org/apache/hadoop/mp/util/Machine.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/util/Machine.java	(revision 0)
@@ -0,0 +1,613 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.util;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.io.IntWritable;
+import org.apache.hadoop.io.NullWritable;
+import org.apache.hadoop.io.Writable;
+import org.apache.hadoop.mapred.ClusterStatus;
+import org.apache.hadoop.mapred.JobClient;
+import org.apache.hadoop.mapred.JobTracker;
+import org.apache.hadoop.mapreduce.InputFormat;
+import org.apache.hadoop.mapreduce.InputSplit;
+import org.apache.hadoop.mapreduce.Job;
+import org.apache.hadoop.mapreduce.JobContext;
+import org.apache.hadoop.mapreduce.Mapper;
+import org.apache.hadoop.mapreduce.Partitioner;
+import org.apache.hadoop.mapreduce.RecordReader;
+import org.apache.hadoop.mapreduce.RecordWriter;
+import org.apache.hadoop.mapreduce.Reducer;
+import org.apache.hadoop.mapreduce.TaskAttemptContext;
+import org.apache.hadoop.mapreduce.TaskInputOutputContext;
+import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
+import org.apache.hadoop.mp.util.serialization.ConfSerializable;
+import org.apache.hadoop.mp.util.serialization.DataSerializable;
+import org.apache.hadoop.mp.util.serialization.ValueOf;
+
+/** Abstract machine for job execution. */
+public abstract class Machine {
+  protected static final Log LOG = LogFactory.getLog(Machine.class);
+  static final Random RANDOM = new Random();;
+
+  private static final String PREFIX = Machine.class.getName();
+  private static final String N_PARTS =  PREFIX + ".nParts";
+  private static final String N_THREADS = PREFIX + ".nThreads";
+
+  /** Initialize a job */
+  abstract void submit(Job job)
+      throws IOException, InterruptedException, ClassNotFoundException;
+
+  /** The number of "machine core", e.g. #parts*#threads. */
+  public abstract int getCore();
+  
+  /** {@inheritDoc} */
+  public String toString() {return getClass().getSimpleName();}
+
+  /** Create a job */
+  public static Job createJob(final String name, final Class<?> clazz,
+      final ConfSerializable sigma,
+      final Configuration conf) throws IOException {
+//    final Cluster cluster = new Cluster(JobTracker.getAddress(conf), conf);
+    final Job job = new Job(conf);
+    final Configuration jobconf = job.getConfiguration();
+    job.setJobName(name);
+    job.setJarByClass(clazz);
+    job.setOutputFormatClass(WritableOutputFormat.class);
+
+    sigma.serialize(jobconf);
+
+    // disable task timeout
+    //jobconf.setLong(JobContext.TASK_TIMEOUT, 0);
+    jobconf.setLong("mapred.task.timeout", 0);
+
+    // do not use speculative execution
+    //jobconf.setBoolean(JobContext.MAP_SPECULATIVE, false);
+    //jobconf.setBoolean(JobContext.REDUCE_SPECULATIVE, false);
+    jobconf.setBoolean("mapred.map.tasks.speculative.execution", false);
+    jobconf.setBoolean("mapred.reduce.tasks.speculative.execution", false);
+
+    return job; 
+  }
+
+  private static abstract class Runner<C, R> extends Thread {
+    final C part;
+    R result;
+
+    private Runner(C part) {this.part = part;}
+
+    @Override
+    public abstract void run();
+  }
+
+  /** Compute sigma */
+  private static <C extends MachineComputable<C, R>,
+                  R extends MachineComputable.Result<R>>
+      void compute(final C sigma, final int nThreads,
+                   final TaskInputOutputContext<?, ?, NullWritable, R> context
+      ) throws IOException, InterruptedException {
+    final JavaUtil.Timer timer = new JavaUtil.Timer(true, true);
+    final String s = "sigma = " + sigma;
+    timer.tick(s);
+    context.setStatus(s);
+   
+    final List<C> parts = sigma.partition(nThreads);
+
+    final List<Runner<C, R>> runners = new ArrayList<Runner<C, R>>(parts.size());
+    final AtomicInteger count = new AtomicInteger(0);
+    
+    final int base = nThreads/parts.size();
+    final int remainder = nThreads%parts.size();
+
+    //compute each part
+    for(int i = 0; i < parts.size(); i++) {
+      final int t = base + (i < remainder? 1: 0);
+      final Runner<C, R> r = new Runner<C, R>(parts.get(i)) {
+        @Override
+        public void run() {
+          timer.tick("START (thread=" + t + ")" + part);
+          result = part.compute(t, timer);
+
+          synchronized(count) {
+            final String s = "DONE(" + count.incrementAndGet() + "/" + parts.size() + ") " + part;
+            timer.tick(s);
+            context.setStatus(s);
+          }
+        }
+      }; 
+      runners.add(r);
+      r.start();
+    }
+
+    //wait for each runner
+    for(Runner<C, R> r : runners)
+      r.join();
+
+    final List<R> results = new ArrayList<R>();
+    for(Runner<C, R> r : runners) {
+      if (r.result != null)
+        results.add(r.result);
+      else
+        timer.tick("The result is null for " + r.part);
+    }
+    if (results.size() < parts.size())
+      timer.tick("results.size() = " + results.size() + " < parts.size() = " + parts.size());
+
+    //combine results
+    final List<R> combined = JavaUtil.combine(results);
+    timer.tick("combined.size() = " + combined.size());
+    for(int i = 0; i < combined.size(); i++) {
+      final R r = combined.get(i);
+      timer.tick(i + ") " + r);
+      context.write(NullWritable.get(), r);
+    }
+    Print.printMemoryInfo();
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  /** An output format using {@link Writable}. */
+  public static class WritableOutputFormat<V extends Writable>
+      extends FileOutputFormat<NullWritable, V> {
+    public WritableOutputFormat() {}
+
+    @Override
+    public RecordWriter<NullWritable, V> getRecordWriter(TaskAttemptContext job)
+        throws IOException, InterruptedException {
+      final Configuration conf = job.getConfiguration();
+      final Path f = getDefaultWorkFile(job, ".writable");
+      final DataOutputStream out = f.getFileSystem(conf).create(f, false);
+
+      return new RecordWriter<NullWritable, V>() {
+        @Override
+        public synchronized void write(NullWritable key, V value) throws IOException {
+          value.write(out);
+        }
+
+        @Override
+        public synchronized void close(TaskAttemptContext context)
+            throws IOException {
+          out.close();
+        }
+      };
+    }
+  }
+
+  /** Split for the computations */
+  public static abstract class SplitBase<C extends Writable>
+      extends InputSplit implements Container<C>, Writable, DataSerializable.ValueOf<C> {
+    private final static String[] EMPTY = {};
+
+    protected C c;
+
+    protected SplitBase() {}
+    protected SplitBase(C c) {this.c = c;}
+    @Override
+    public C get() {return c;}
+    @Override
+    public long getLength() {return 1;}
+    @Override
+    public String[] getLocations() {return EMPTY;}
+    @Override
+    public final void readFields(DataInput in) throws IOException {c = valueOf(in);}
+    @Override
+    public final void write(DataOutput out) throws IOException {c.write(out);}
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  /** An abstract InputFormat for the jobs */
+  protected static abstract class InputFormatBase<C extends MachineComputable<C, ?>,
+                                                  S extends SplitBase<C>>
+      extends InputFormat<NullWritable, C>
+      implements ValueOf<InputSplit, C, RuntimeException> {
+    /** Specify how to read the records */
+    @Override
+    public final RecordReader<NullWritable, C> createRecordReader(
+        InputSplit generic, TaskAttemptContext context) {
+      @SuppressWarnings("unchecked")
+      final S split = (S)generic;
+
+      //return a record reader
+      return new RecordReader<NullWritable, C>() {
+        private boolean done = false;
+
+        /** {@inheritDoc} */
+        @Override
+        public void initialize(InputSplit split, TaskAttemptContext context) {}
+        /** {@inheritDoc} */
+        @Override
+        public boolean nextKeyValue() {return !done ? done = true : false;}
+        /** {@inheritDoc} */
+        @Override
+        public NullWritable getCurrentKey() {return NullWritable.get();}
+        /** {@inheritDoc} */
+        @Override
+        public C getCurrentValue() {return split.get();}
+        /** {@inheritDoc} */
+        @Override
+        public float getProgress() {return done? 1f: 0f;}
+        /** {@inheritDoc} */
+        @Override
+        public void close() {}
+      };
+    }
+
+    protected abstract ConfSerializable.ValueOf<C> getConfValueOf();
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  public static class Null extends Machine {
+    private static final Null INSTANCE = new Null();
+
+    public static Null parse(String specification) {
+      return "n".equals(specification)? INSTANCE: null;
+    }
+
+    private Null() {}
+
+    @Override
+    public int getCore() {return 1;}
+
+    @Override
+    void submit(Job job) {
+      JavaUtil.sleepsecond(60, getClass().getSimpleName() + ".submit(..)");
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  public static abstract class SingleSideBase extends Machine {
+    /** Number of parts per job */
+    public final int nParts;
+    /** Number of threads per part */
+    final int nThreads;
+
+    SingleSideBase(final int nParts, final int nThreads) {
+      this.nParts = nParts;
+      this.nThreads = nThreads;
+
+      if (nParts <= 0) {
+        throw new IllegalArgumentException("nParts = " + nParts + " <= 0");
+      } else if (nThreads <= 0) {
+        throw new IllegalArgumentException("nThreads = " + nThreads + " <= 0");
+      }
+    }
+
+    @Override
+    public int getCore() {
+      return nParts*nThreads;
+    }
+
+    @Override
+    public String toString() {
+      return getClass().getSimpleName()
+          + "(p" + nParts + ",t" + nThreads + ")";
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  public static abstract class MapSideBase<C extends MachineComputable<C, R>,
+                                           R extends MachineComputable.Result<R>>
+      extends SingleSideBase {
+    public MapSideBase(final int nParts, final int nThreads) {
+      super(nParts, nThreads);
+    }
+
+    protected abstract Class<? extends MapperBase<C, R>> getMapperClass();
+
+    protected abstract Class<R> getResultClass();
+
+    protected abstract Class<? extends PartitionInputFormatBase<C, ?>> getPartitionInputFormatClass();
+
+    protected final void submit(Job job)
+        throws IOException, InterruptedException, ClassNotFoundException {
+      final Configuration jobconf = job.getConfiguration();
+      jobconf.setInt(N_PARTS, nParts);
+      jobconf.setInt(N_THREADS, nThreads);
+
+      // setup mapper
+      job.setMapperClass(getMapperClass());
+      job.setMapOutputKeyClass(NullWritable.class);
+      job.setMapOutputValueClass(getResultClass());
+
+      // zero reducer
+      job.setNumReduceTasks(0);
+
+      // setup input
+      job.setInputFormatClass(getPartitionInputFormatClass());
+
+      job.submit();
+    }
+
+    protected static abstract class PartitionInputFormatBase<C extends MachineComputable<C, ?>, S extends SplitBase<C>>
+        extends Machine.InputFormatBase<C, S> {
+      /** Partitions the summation into parts and then return them as splits */
+      @Override
+      public final List<InputSplit> getSplits(JobContext context) {
+        //read sigma from conf
+        final Configuration conf = context.getConfiguration();
+        final C sigma = getConfValueOf().valueOf(conf); 
+        final int nParts = conf.getInt(Machine.N_PARTS, 0);
+        //LOG.info("sigma  = " + sigma);
+        //LOG.info("nParts = " + nParts);
+
+        //create splits
+        final List<C> parts = sigma.partition(nParts);
+        //LOG.info("parts.size() = " + parts.size());
+
+        final List<InputSplit> splits = new ArrayList<InputSplit>();
+        for(C p : parts)
+          splits.add(valueOf(p));
+        //LOG.info("splits.size() = " + splits.size());
+        return splits;
+      }
+    }
+    
+    /** A mapper which computes sums */
+    protected static abstract class MapperBase<C extends MachineComputable<C, R>, R extends MachineComputable.Result<R>>
+        extends Mapper<NullWritable, C, NullWritable, R> {
+      protected void init(final Context context) {}
+
+      @Override
+      protected final void map(NullWritable nw, C sigma, final Context context
+          ) throws IOException, InterruptedException {
+        init(context);
+        final int nThreads = context.getConfiguration().getInt(N_THREADS, 1);
+        Machine.compute(sigma, nThreads, context);
+      }
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  public static abstract class ReduceSideBase<C extends MachineComputable<C, R>,
+                                              R extends MachineComputable.Result<R>>
+      extends SingleSideBase {
+    public ReduceSideBase(final int nParts, final int nThreads) {
+      super(nParts, nThreads);
+    }
+
+    protected abstract Class<? extends PartitionMapperBase<C>> getPartitionMapperClass();
+
+    protected abstract Class<C> getComputationClass();
+
+    protected abstract Class<R> getResultClass();
+
+    protected abstract Class<? extends ReducerBase<C, R>> getReducerClass();
+    
+    protected abstract Class<? extends SingletonInputFormatBase<C, ?>> getSingletonInputFormatClass();
+
+    protected abstract Class<? extends IndexPartitionerBase<C>> getIndexPartitionerClass();
+
+    /** {@inheritDoc} */
+    @Override
+    final void submit(Job job)
+        throws IOException, InterruptedException, ClassNotFoundException {
+      final Configuration jobconf = job.getConfiguration();
+      jobconf.setInt(N_PARTS, nParts);
+      jobconf.setInt(N_THREADS, nThreads);
+
+      // setup mapper
+      job.setMapperClass(getPartitionMapperClass());
+      job.setMapOutputKeyClass(IntWritable.class);
+      job.setMapOutputValueClass(getComputationClass());
+
+      // setup partitioner
+      job.setPartitionerClass(getIndexPartitionerClass());
+
+      // setup reducer
+      job.setReducerClass(getReducerClass());
+      job.setOutputKeyClass(NullWritable.class);
+      job.setOutputValueClass(getResultClass());
+      job.setNumReduceTasks(nParts);
+
+      // setup input
+      job.setInputFormatClass(getSingletonInputFormatClass());
+
+      job.submit();
+    }
+
+    /** An InputFormat which returns a single summation. */
+    protected static abstract class SingletonInputFormatBase<C extends MachineComputable<C, ?>, S extends SplitBase<C>>
+        extends Machine.InputFormatBase<C, S> {
+      /** @return a list containing a single split of summation */
+      @Override
+      public List<InputSplit> getSplits(JobContext context) {
+        //read sigma from conf
+        final Configuration conf = context.getConfiguration();
+        final C sigma = getConfValueOf().valueOf(conf); 
+  
+        //create splits
+        final List<InputSplit> splits = new ArrayList<InputSplit>(1);
+        splits.add(valueOf(sigma));
+        return splits;
+      }
+    }
+
+    /** A {@link Mapper} which partitions a computation */
+    protected static abstract class PartitionMapperBase<C extends MachineComputable<C, ?>>
+        extends Mapper<NullWritable, C, IntWritable, C> {
+      /** Partitions sigma into parts */
+      @Override
+      protected final void map(NullWritable nw, C sigma, final Context context
+          ) throws IOException, InterruptedException {
+        final Configuration conf = context.getConfiguration();
+        final int nParts = conf.getInt(Machine.N_PARTS, 0);
+        final List<C> parts = sigma.partition(nParts);
+        for(int i = 0; i < parts.size(); ++i) {
+          final C p = parts.get(i);
+          context.write(new IntWritable(i), p);
+          LOG.info("parts.get(" + i + ") = " + p);
+        }
+      }
+    }
+
+    /** Use the index for partitioning. */
+    protected static class IndexPartitionerBase<C> extends Partitioner<IntWritable, C> {
+      /** @return the index as the partition. */
+      @Override
+      public int getPartition(IntWritable index, C value, int numPartitions) {
+        return index.get();
+      }
+    }
+
+    /** A {@link Reducer} which does the computation */
+    protected static class ReducerBase<C extends MachineComputable<C, R>, R extends MachineComputable.Result<R>>
+        extends Reducer<IntWritable, C, NullWritable, R> {
+      protected void init(final Context context) {}
+
+      @Override
+      protected final void reduce(IntWritable index, Iterable<C> computations, Context context
+          ) throws IOException, InterruptedException {
+        LOG.info("index=" + index);
+        init(context);
+        final int nThreads = context.getConfiguration().getInt(N_THREADS, 1);
+        for(C sigma : computations)
+          compute(sigma, nThreads, context);
+      }
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  /**
+   * A machine which chooses Machine in runtime according to the cluster status
+   */
+  public static abstract class MixBase<C extends MachineComputable<C, R>,
+                                       R extends MachineComputable.Result<R>>
+      extends Machine {
+    protected JobClient jobclient;
+    protected int consecutiveMap = 0;
+    protected int consecutiveReduce = 0;
+    //private Cluster cluster;
+    
+    protected final MapSideBase<C, R> mapSide;
+    protected final ReduceSideBase<C, R> reduceSide;
+    
+    protected MixBase(final MapSideBase<C, R> mapSide, final ReduceSideBase<C, R> reduceSide) {
+      this.mapSide = mapSide;
+      this.reduceSide = reduceSide;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public synchronized void submit(Job job)
+        throws IOException, InterruptedException, ClassNotFoundException {
+      final Configuration conf = job.getConfiguration();
+      chooseMachine(conf).submit(job);
+    }
+
+    protected abstract int availableMap(final int remainingMap);
+    protected abstract int availableReduce(final int remainingReduce);
+    
+    /**
+     * Choose a Machine in runtime according to the cluster status.
+     */
+    synchronized Machine chooseMachine(Configuration conf) throws IOException {
+      if (jobclient == null)
+        jobclient = new JobClient(JobTracker.getAddress(conf), conf);
+      /*
+      if (cluster == null)
+        cluster = new Cluster(JobTracker.getAddress(conf), conf);
+        */
+
+      try {
+        for(;; Thread.sleep(2000)) {
+          //get remaining, available
+//          final ClusterMetrics status = cluster.getClusterStatus();
+          final ClusterStatus status = jobclient.getClusterStatus();
+          final int remaining_m = status.getMaxMapTasks() - status.getMapTasks();
+          final int remaining_r = status.getMaxReduceTasks() - status.getReduceTasks();
+          final int available_m = availableMap(remaining_m);
+          final int available_r = availableReduce(remaining_r);
+          
+          if (available_m >= mapSide.nParts || available_r >= reduceSide.nParts) {
+            //choose machine
+            final Machine value;
+            if (consecutiveMap >= 5)
+              value = reduceSide;
+            else if (consecutiveReduce >= 10)
+              value = mapSide;
+            else if (available_m < mapSide.nParts)
+              value = reduceSide;
+            else if (available_r < reduceSide.nParts)
+              value = mapSide;
+            else {
+              //favor ReduceSide machine
+              final int a = available_m/mapSide.nParts - 1;
+              final int b = available_r/reduceSide.nParts + 1;
+              value = RANDOM.nextInt(a + b) < a? mapSide: reduceSide;
+            }
+
+            //update consecutive m, r 
+            if (value == mapSide)
+              consecutiveMap++;
+            else
+              consecutiveMap = 0;
+            if (value == reduceSide)
+              consecutiveReduce++;
+            else
+              consecutiveReduce = 0;
+            Print.println("  " + this + " is " + value
+                + " (remaining: m=" + remaining_m + ", r=" + remaining_r
+                + "; available: m=" + available_m + ", r=" + available_r
+                + "; consecutive: m=" + consecutiveMap + ", r=" + consecutiveReduce + ")");
+            return value;
+          }
+        }
+      } catch (InterruptedException e) {
+        throw new IOException(e);
+      }    
+    }
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  /**
+   * Alternates Map-side and Reduce-side Machines in a regular pattern.
+   */
+  public static abstract class AlternationBase<C extends MachineComputable<C, R>,
+                                               R extends MachineComputable.Result<R>>
+      extends MixBase<C, R> {
+    private final char[] pattern;
+    private int curr = -1;
+    
+    protected AlternationBase(
+        final MapSideBase<C, R> mapSide, final ReduceSideBase<C, R> reduceSide,
+        final String pattern) {
+      super(mapSide, reduceSide);
+      this.pattern = new char[pattern.length()];
+      for(int i = 0; i < this.pattern.length; i++) {
+        final char c = pattern.charAt(i);
+        if (c != 'm' && c != 'r')
+          throw new IllegalArgumentException("c != 'm' && c != 'r', i="
+              + i + ", pattern=" + pattern);
+        else
+          this.pattern[i] = c; 
+      }
+    }
+
+    /**
+     * Choose a Machine in runtime according to the pattern.
+     */
+    synchronized Machine chooseMachine(Configuration conf) throws IOException {
+      if (++curr == pattern.length)
+        curr = 0;
+      return pattern[curr] == 'm'? mapSide: reduceSide;
+    }
+  }
+}
Index: src/examples/org/apache/hadoop/mp/util/HadoopUtil.java
===================================================================
--- src/examples/org/apache/hadoop/mp/util/HadoopUtil.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/util/HadoopUtil.java	(revision 0)
@@ -0,0 +1,297 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.util;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.conf.Configured;
+import org.apache.hadoop.fs.FileStatus;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.fs.permission.FsPermission;
+import org.apache.hadoop.mapreduce.Job;
+import org.apache.hadoop.mp.pi.math.Mod1Fraction;
+import org.apache.hadoop.mp.util.serialization.DataSerializable;
+import org.apache.hadoop.mp.util.serialization.StringSerializable;
+import org.apache.hadoop.util.Tool;
+import org.apache.hadoop.util.ToolRunner;
+
+/** Utility methods */
+public class HadoopUtil {
+  /** Print usage messages */
+  public static int printUsage(String[] args, String usage, Exception e) {
+    if (e != null)
+      Print.printStackTrace(e);
+
+    Print.println("args.length = " + args.length);
+    Print.println("args        = " + Arrays.asList(args).toString().replace(", ", ",\n  "));
+    Print.println();
+    Print.println("Usage: java " + usage);
+    Print.println();
+
+    ToolRunner.printGenericCommandUsage(Print.out);
+    return -1;
+  }
+
+  private static final Semaphore JOB_SEMAPHORE = new Semaphore(1);
+  private static final AtomicInteger nSubmittedJobs = new AtomicInteger(0);
+
+  /** Run a job. */
+  public static void runJob(String name, Job job, Machine machine, String startmessage,
+      final long sleeptime, final JavaUtil.Timer timer) {
+    JOB_SEMAPHORE.acquireUninterruptibly();
+    final long starttime = timer.tick(name + "> starting, " + startmessage
+        + ", ++nSubmittedJobs=" + nSubmittedJobs.incrementAndGet());
+    try {
+      try {
+        //submit a job
+        machine.submit(job);
+        
+        // Separate jobs
+        if (sleeptime > 0) {
+          Print.println(name + "> sleep(" + Parse.millis2String(sleeptime) + ")");
+          for(long ms = sleeptime; ms > 0 && !job.isComplete(); ) {
+            Thread.sleep(ms < 10000L? ms: 10000L);
+            
+            ms -= 10000L;
+            if ((sleeptime - ms) % 60000L == 0) {
+              Print.println(name + "> remaining sleep time="
+                  + Parse.millis2String(ms));
+                  /*
+              Printer.println(name + "> JobID=" + job.getJobID()
+                  + String.format(", mapProgress=%1.3f, reduceProgress=%1.3f",
+                      job.mapProgress(), job.reduceProgress()));
+                      */
+            }
+          }
+        }
+      } finally {
+        JOB_SEMAPHORE.release();
+      }
+  
+      if (!job.waitForCompletion(false))
+        throw new RuntimeException(name + " failed.");
+    } catch(Exception e) {
+      throw e instanceof RuntimeException? (RuntimeException)e: new RuntimeException(e);
+    } finally {
+      timer.tick(name + "> timetaken=" + Parse.millis2String(timer.tick() - starttime)
+          +", --nSubmittedJobs=" + nSubmittedJobs.decrementAndGet());
+    }
+  }
+
+  /** Rewrite job outputs */
+  public static <T extends MachineComputable.Result<T>> T processJobOutputs(
+      FileSystem fs, String remotedir, String jobname, Path joboutdir,
+      DataSerializable.ValueOf<T> iovalueof) throws IOException {
+    //read and combine results
+    T t = null;
+    final FileStatus[] statuses = fs.listStatus(joboutdir);
+    int w = 0;
+    if (statuses != null && statuses.length > 0) {
+      Arrays.sort(statuses);
+      Print.println("> found " + statuses.length + " items in " + joboutdir);
+      for(FileStatus status : statuses) {
+        if (status.getPath().getName().startsWith("part-")) {
+          final DataInputStream in = fs.open(status.getPath());
+          final T value;
+          try {
+            value = iovalueof.valueOf(in);
+          } finally {
+            in.close();
+          }
+  
+          if (t == null)
+            t = value;
+          else {
+            final T c = t.combine(value);
+            if (c == null) {
+              final Path outfile = new Path(remotedir, jobname + "." + w + ".writable");
+              Print.println("> write the result to " + outfile);
+              write(t, outfile, fs);
+              w++;
+              
+              t = value;
+            } else 
+              t = c;
+          }
+        }
+      }
+  
+      //write combined output
+      if (t == null) {
+        if (w == 0)
+          Print.println("> no result is found.");
+      } else {
+        final Path outfile = new Path(remotedir,
+            jobname + (w == 0? "": "." + w) + ".writable");
+        Print.println("> write the result to " + outfile);
+        write(t, outfile, fs);
+      }
+    }
+    return t;
+  }
+
+  /** Write the result to an output file */
+  public static <T extends MachineComputable.Result<T>> void write(
+      T r, Path outfile, FileSystem fs) throws IOException {
+    final DataOutputStream out = fs.create(outfile);
+    try {
+      r.write(out);
+    } finally {
+      out.close();
+    }
+  }
+
+  /** Rewrite completed results */
+  public static <K, R extends MachineComputable.Result<R>> void rewriteCompletedResult(
+      final K key, final R result, final StringSerializable.ValueOf<K> keyVO,
+      final FileStatus[] statuses, Path dir, FileSystem fs) throws IOException {
+    if (statuses != null && statuses.length > 0) {
+      final Path sub = new Path(dir, key.toString());
+      if (createDirectory(fs, sub, false)) {
+        Print.println("  " + sub + " already exists, skipping.");
+      } else {
+        Print.println(key + ": Move completed results from " + dir + " to " + sub);
+        int count = 0;
+        for(FileStatus s : statuses) {
+          final String name = s.getPath().getName();
+          if (key.equals(keyVO.valueOf(name))) {
+            final Path dest = new Path(sub, name);
+            fs.rename(s.getPath(), dest);
+            Print.println("    Renamed " + s.getPath() + " to " + dest);
+            count++;
+          }
+        }
+        final Path p = new Path(dir, key + ".writable");
+        write(result, p, fs);
+        Print.println("    count=" + count);
+        Print.println("  Wrote to " + p + ", result="+ result);
+      }        
+    }
+  }
+
+  /** Read existing results. */
+  public static <K, R extends MachineComputable.Result<R>> List<R> readExistingResults(
+      final K key, StringSerializable.ValueOf<K> keyVO, DataSerializable.ValueOf<R> valueVO,
+      final FileStatus[] statuses, FileSystem fs) throws IOException {
+    List<R> values = new ArrayList<R>();
+    if (statuses != null && statuses.length > 0) {
+      int count = 0;
+      for(FileStatus s : statuses) {
+        if (!s.isDir()) {
+          final String name = s.getPath().getName();
+          if (key.equals(keyVO.valueOf(name))) { 
+            //read file
+            DataInputStream in = null;
+            R r = null;
+            try {
+              in = fs.open(s.getPath());
+              r = valueVO.valueOf(in);
+            } finally {
+              Print.println("  " + name + " => " + r);
+              if (in != null) {
+                in.close();
+              }
+            }
+  
+            //put to the map
+            if (r != null) {
+              values.add(r);
+              if (values.size() > 1) {
+                values = JavaUtil.combine(values);
+              }
+              count++;
+            }
+          }
+        }
+      }
+      Print.println(key + ": #(existing results) = " + count);
+    }
+    if (values.size() > 0) {
+      values = JavaUtil.combine(values);
+      //combine results
+      Print.println(key + ": Combined: size=" + values.size() + ", [");
+      for(int i = 0; i < values.size(); i++) {
+        Print.println("  " + i + ": " + values.get(i));
+      }
+      Print.println("]");
+    }
+    return values;
+  }
+
+  /**
+   * Create a directory.
+   * @return true if the directory already exists.
+   */
+  public static boolean createDirectory(FileSystem fs, Path dir,
+      boolean deleteIfExists) throws IOException {
+    final boolean exists = fs.exists(dir);
+    if (exists) {
+      if (deleteIfExists) {
+        fs.delete(dir, true);
+      } else {
+        return true;
+      }
+    }
+    if (!fs.mkdirs(dir)) {
+      throw new IOException("Cannot create working directory " + dir);
+    }
+    fs.setPermission(dir, new FsPermission((short)0777));
+    return exists;
+  }
+
+  /** Write Mod1Fraction to a file. */
+  public static void write(Mod1Fraction v, Path p, FileSystem fs 
+      ) throws IOException{
+    Print.println("Write to " + p + " ...");
+    final DataOutputStream out = fs.create(p, true);
+    v.serialize(out);
+    out.close();
+  }
+
+  public static void array2confEntries(final Configuration conf, final String name, final String... values) {
+    conf.setInt(name + ".length", values.length);
+    for(int i = 0; i < values.length; i++)
+      conf.set(name + "." + i, values[i]);
+  }
+
+  public static String[] confEntries2array(final Configuration conf, final String name) {
+    final String[] values = new String[conf.getInt(name + ".length", 0)];
+    for(int i = 0; i < values.length; i++)
+      values[i] = conf.get(name + "." + i);
+    return values;
+  }
+  /////////////////////////////////////////////////////////////////////////////
+  public static abstract class RunnerBase extends Configured implements Tool {
+    protected final JavaUtil.Timer timer = new JavaUtil.Timer(true, true);
+    protected final File logfile; 
+    protected RunnerBase() throws FileNotFoundException {
+      logfile = Print.initLogFile(getClass().getSimpleName());
+    }
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/util/Recycler.java
===================================================================
--- src/examples/org/apache/hadoop/mp/util/Recycler.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/util/Recycler.java	(revision 0)
@@ -0,0 +1,97 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.util;
+
+import java.util.Arrays;
+
+/** Recycle objects. */
+public abstract class Recycler<T> {
+  protected final Object[] array;
+  protected int size = 0;
+
+  protected Recycler(final int size) {this.array = new Object[size];}
+
+  /** Create a new object. */
+  public abstract T newObject();
+
+  /** Reclaim an object. */
+  public void reclaim(final T a) {
+    if (size < array.length)
+      array[size] = a;
+  }
+
+  /** Recycling int[]. */
+  public static final class IntArray extends Recycler<int[]> {
+    private final int arraylength;
+
+    public IntArray(int factorysize, int arraylength) {
+      super(factorysize);
+      this.arraylength = arraylength;
+    }
+
+    @Override
+    public final int[] newObject() {
+      if (size > 0) {
+        size--;
+        final int[] a = (int[])array[size];
+        array[size] = null;
+        Arrays.fill(a, 0);
+        return a;
+      } else
+        return new int[arraylength];
+    }
+
+    @Override
+    public final void reclaim(final int[] a) {
+      if (a.length != arraylength)
+        throw new IllegalArgumentException("a.length = " + a.length
+            + " != arraylength = " + arraylength);
+      super.reclaim(a);
+    }
+  }
+
+  /** Recycling long[]. */
+  public static final class LongArray extends Recycler<long[]> {
+    private final int arraylength;
+
+    public LongArray(int factorysize, int arraylength) {
+      super(factorysize);
+      this.arraylength = arraylength;
+    }
+
+    @Override
+    public final long[] newObject() {
+      if (size > 0) {
+        size--;
+        final long[] a = (long[])array[size];
+        array[size] = null;
+        Arrays.fill(a, 0L);
+        return a;
+      } else
+        return new long[arraylength];
+    }
+
+    @Override
+    public final void reclaim(final long[] a) {
+      if (a.length != arraylength)
+        throw new IllegalArgumentException("a.length = " + a.length
+            + " != arraylength = " + arraylength);
+      super.reclaim(a);
+    }
+  }
+}
Index: src/examples/org/apache/hadoop/mp/util/Parse.java
===================================================================
--- src/examples/org/apache/hadoop/mp/util/Parse.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/util/Parse.java	(revision 0)
@@ -0,0 +1,378 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.util;
+
+import java.math.BigInteger;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.StringTokenizer;
+
+
+public class Parse {
+  /** Covert milliseconds to a String. */
+  public static String millis2String(long n) {
+    if (n < 0)
+      return "-" + millis2String(-n);
+    else if (n < 1000)
+      return n + "ms";
+
+    final StringBuilder b = new StringBuilder();
+    final int millis = (int)(n % 1000L);
+    if (millis != 0)
+      b.append(String.format(".%03d", millis)); 
+    if ((n /= 1000) < 60)
+      return b.insert(0, n).append("s").toString();
+
+    b.insert(0, String.format(":%02d", (int)(n % 60L)));
+    if ((n /= 60) < 60)
+      return b.insert(0, n).toString();
+
+    b.insert(0, String.format(":%02d", (int)(n % 60L)));
+    if ((n /= 60) < 24)
+      return b.insert(0, n).toString();
+
+    b.insert(0, n % 24L);
+    final int days = (int)((n /= 24) % 365L);
+    b.insert(0, days == 1? " day ": " days ").insert(0, days);
+    if ((n /= 365L) > 0)
+      b.insert(0, n == 1? " year ": " years ").insert(0, n);
+
+    return b.toString();
+  }
+
+  /** Covert milliseconds to a String. */
+  public static String millis2String(double t, final int decimal) {
+    if (t < 0)
+      return "-" + millis2String(-t, decimal);
+    else { 
+      final String unit;
+      if (t < 1000)
+        unit = "ms";
+      else if ((t /= 1000) < 60)
+        unit = (t <= 1? "second": "seconds");
+      else if ((t /= 60) < 60)
+        unit = (t <= 1? "minute": "minutes");
+      else if ((t /= 60) < 24)
+        unit = (t <= 1? "hour": "hours");
+      else if ((t /= 24) < 365)
+        unit = (t <= 1? "day": "days");
+      else {
+        t /= 365;
+        unit = (t <= 1? "year": "years");
+      }
+      return String.format("%." + decimal + "f ", t) + unit;
+    }
+  }
+
+  public static int char2int(int d) {
+    if (Character.isDigit(d)) {
+      return d - '0';
+    } else if (Character.isLowerCase(d)) {
+      return d - 'a' + 10;
+    } else if (Character.isUpperCase(d)) {
+      return d - 'A' + 10;
+    } else {
+      throw new IllegalArgumentException("Unexpected character: " + (char)d
+          + " (code=" + d + ")");
+    }
+  }
+  
+  public static int symbol2int(char c) {
+    c = Character.toLowerCase(c);
+    if (c == 'k')
+      return 1000;
+    if (c == 'm')
+      return 1000000;
+    if (c == 'b')
+      return 1000000000;
+    throw new IllegalArgumentException("Unknown symbol c = " + c);
+  }
+
+
+  /** Parse a variable. */  
+  public static Boolean parseBooleanVariable(final String name, final String s) {
+    return string2Boolean(parseStringVariable(name, s));
+  }
+
+  /** Covert a String to a Boolean. */
+  public static Boolean string2Boolean(String s) {
+    if ("null".equals(s))
+      return null;
+    else if ("true".equalsIgnoreCase(s))
+      return Boolean.TRUE;
+    else if ("false".equalsIgnoreCase(s))
+      return Boolean.FALSE;
+
+    throw new IllegalArgumentException("Cannot parse s = " + s);
+  }
+
+  /** Covert a String to a long.  
+   * This support comma separated number format.
+   */
+  public static Long string2long(String s) {
+    if (s.equals("null"))
+      return null;
+
+    s = s.trim().replace(",", "");
+    final int lastpos = s.length() - 1;
+    final char lastchar = s.charAt(lastpos);
+    if (Character.isDigit(lastchar))
+      return Long.parseLong(s);
+    else {
+      final long v = symbol2int(lastchar) * Long.parseLong(s.substring(0, lastpos));
+      if (v < 0)
+        throw new IllegalArgumentException("v < 0 || v > Integer.MAX_VALUE, v="
+            + v + ", s=" + s);
+      return v;
+    }
+  }
+
+  /** Covert a String to a long.  
+   * This support comma separated number format.
+   */
+  public static Integer string2integer(String s) {
+    if (s.equals("null"))
+      return null;
+
+    s = s.trim().replace(",", "");
+    final int lastpos = s.length() - 1;
+    final char lastchar = s.charAt(lastpos);
+    if (Character.isDigit(lastchar))
+      return Integer.parseInt(s);
+    else {
+      final int v = symbol2int(lastchar) * Integer.parseInt(s.substring(0, lastpos));
+      if (v < 0)
+        throw new IllegalArgumentException("v < 0 || v > Integer.MAX_VALUE, v="
+            + v + ", s=" + s);
+      return v;
+    }
+  }
+
+  /**
+   * The traditional binary prefixes, kilo, mega, ..., exa,
+   * which can be represented by a 64-bit integer.
+   * TraditionalBinaryPrefix symbol are case insensitive. 
+   */
+  public static enum TraditionalBinaryPrefix {
+    KILO(1024),
+    MEGA(KILO.value << 10),
+    GIGA(MEGA.value << 10),
+    TERA(GIGA.value << 10),
+    PETA(TERA.value << 10),
+    EXA(PETA.value << 10);
+
+    public final long value;
+    public final char symbol;
+
+    TraditionalBinaryPrefix(long value) {
+      this.value = value;
+      final char c = name().charAt(0);
+      this.symbol = c == 'K'? 'k': c;
+    }
+
+    /**
+     * @return The TraditionalBinaryPrefix object corresponding to the symbol.
+     */
+    public static TraditionalBinaryPrefix valueOf(char symbol) {
+      symbol = Character.toUpperCase(symbol);
+      for(TraditionalBinaryPrefix prefix : TraditionalBinaryPrefix.values()) {
+        if (symbol == prefix.symbol) {
+          return prefix;
+        }
+      }
+      throw new IllegalArgumentException("Unknown symbol '" + symbol + "'");
+    }
+
+    /**
+     * Convert a string to long.
+     * The input string is first be trimmed
+     * and then it is parsed with traditional binary prefix.
+     *
+     * For example,
+     * "-1230k" will be converted to -1230 * 1024 = -1259520;
+     * "891g" will be converted to 891 * 1024^3 = 956703965184;
+     *
+     * @param s input string
+     * @return a long value represented by the input string.
+     */
+    public static long string2long(String s) {
+      s = s.trim();
+      final int lastpos = s.length() - 1;
+      final char lastchar = s.charAt(lastpos);
+      if (Character.isDigit(lastchar))
+        return Long.parseLong(s);
+      else {
+        long prefix = TraditionalBinaryPrefix.valueOf(lastchar).value;
+        long num = Long.parseLong(s.substring(0, lastpos));
+        if (num > (Long.MAX_VALUE/prefix) || num < (Long.MIN_VALUE/prefix)) {
+          throw new IllegalArgumentException(s + " does not fit in a Long");
+        }
+        return num * prefix;
+      }
+    }
+
+    public static String long2string(final long n, final int decimal) {
+      if (n < 0)
+        return "-" + long2string(-n, decimal);
+      else if (n < 1024L)
+        return String.valueOf(n);
+      else {
+        final TraditionalBinaryPrefix[] v = TraditionalBinaryPrefix.values();
+        int i = 1;
+        for(; i < v.length && n >= v[i].value; i++);
+        i--;
+        return String.format("%." + decimal + "f %c", n/(double)v[i].value, v[i].symbol);
+      }
+    }
+  }
+
+  public static String bigInteger2Brief(final BigInteger x) {
+    String s = x.toString(16);
+    if (s.length() > 100)
+      s = s.substring(0, 100) + " ...";
+    return s;
+  }
+
+  /** Covert a long to a String in comma separated number format. */  
+  public static String long2string(long n) {
+    if (n < 0)
+      return "-" + long2string(-n);
+    
+    final StringBuilder b = new StringBuilder();
+    for(; n >= 1000; n = n/1000)
+      b.insert(0, String.format(",%03d", n % 1000));
+    return n + b.toString();    
+  }
+
+  /** Covert an array of long to a String. */  
+  public static String longArray2string(long[] a) {
+    if (a.length == 0)
+      return "[]";
+
+    final StringBuilder b = new StringBuilder("[");
+    b.append(a[0]);
+    for(int i = 1; i < a.length; i++)
+      b.append(", ").append(a[i]);
+    return b.append("]").toString();
+  }
+
+  /** Covert an array of long to a String. */  
+  public static String byteArray2string(byte[] a) {
+    if (a.length == 0)
+      return "[]";
+
+    final StringBuilder b = new StringBuilder("[");
+    b.append(String.format("%02X", a[0]));
+    for(int i = 1; i < a.length; i++)
+      b.append(String.format(", %02X", a[i]));
+    return b.append("]").toString();
+  }
+
+  /** Covert a String to an array of long. */  
+  public static long[] string2longArray(String s) {
+    s = s.substring(1, s.length() - 1).replace(", ", ":");
+    final StringTokenizer t = new StringTokenizer(s);
+    final long[] a = new long[t.countTokens()];
+    for(int i = 0; t.hasMoreTokens(); i++)
+      a[i] = Long.parseLong(t.nextToken());
+    return a;
+  }
+
+  /** Covert a String to an array of long. */  
+  public static List<Long> string2longList(String s) {
+    final List<Long> a = new ArrayList<Long>();
+    s = s.substring(1, s.length() - 1).replace(", ", " ");
+    for(final StringTokenizer t = new StringTokenizer(s); t.hasMoreTokens(); )
+      a.add(Long.parseLong(t.nextToken()));
+    return a;
+  }
+
+  /** Parse a variable. */  
+  public static int parseIntVariable(final String name, final String s) {
+    return Integer.parseInt(parseStringVariable(name, s));
+  }
+
+  /** Parse a variable. */  
+  public static Long parseLongVariable(final String name, final String s) {
+    return string2long(parseStringVariable(name, s));
+  }
+
+  /** Parse a variable. */  
+  public static String parseStringVariable(final String name, final String s) {
+    if (!s.startsWith(name + '='))
+      throw new IllegalArgumentException("!s.startsWith(name + '='), name="
+          + name + ", s=" + s);
+    return s.substring(name.length() + 1);
+  }
+
+  private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyyMMdd-HHmmssSSS");
+  public static String time2String(final long t) { 
+    return DATE_FORMAT.format(new Date(t));
+  }
+
+  public static String currentTime2String() { 
+    return time2String(System.currentTimeMillis());
+  }
+
+  /** Covert an array to a String. */  
+  public static <T> String array2string(T[] a) {
+    if (a == null)
+      return "null";
+    else if (a.length == 0)
+      return "[]";
+    else {
+      final StringBuilder b = new StringBuilder("[#=").append(a.length)
+          .append(": ").append(a[0]);
+      for(int i = 1; i < a.length; i++)
+        b.append(", ").append(a[i]);
+      return b.append("]").toString();
+    }
+  }
+
+  /** Covert an array to a String. */  
+  public static <T> String list2string(List<T> a) {
+    if (a == null)
+      return "null";
+    else if (a.size() == 0)
+      return "[]";
+    else {
+      final StringBuilder b = new StringBuilder("[");
+      for(int i = 0; i < a.size(); i++)
+        b.append("\n  ").append(a.get(i));
+      return b.append("\n]").toString();
+    }
+  }
+
+  public static String description2brief(final String[] ... descriptions) {
+    final StringBuilder list = new StringBuilder();
+    for(String[] d: descriptions)
+      for(String s: d)
+        list.append(' ').append(s.substring(0, s.indexOf('>') + 1));
+    return "" + list;      
+  }
+
+  public static String description(final String[] ... descriptions) {
+    final StringBuilder description = new StringBuilder();
+    for(String[] d: descriptions)
+      for(String s: d)
+        description.append("\n  ").append(s);
+    return "" + description;      
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/util/Statistics.java
===================================================================
--- src/examples/org/apache/hadoop/mp/util/Statistics.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/util/Statistics.java	(revision 0)
@@ -0,0 +1,73 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.util;
+
+import java.util.Map;
+import java.util.TreeMap;
+
+public class Statistics {
+  private static class Count {
+    private final String name;
+    private long count = 0;
+    
+    Count(String name) {
+      this.name = name;
+    }
+    
+    @Override
+    public String toString() {
+      return name + ": " + count;
+    }
+  }
+  
+  private final String name;
+  private Map<String, Count> counts = new TreeMap<String, Count>();
+  
+  public Statistics(String name) {
+    this.name = name;
+  }
+  
+  @Override
+  public String toString() {
+    final StringBuilder b = new StringBuilder();
+    b.append(getClass().getSimpleName()).append(" ").append(name)
+     .append(", counts.size()=").append(counts.size());
+    for(Count c : counts.values()) {
+      b.append("\n  ").append(c);
+    }
+    return b.toString();
+  }
+
+  public void countExecutionPoint() {
+    countExecutionPoint(Thread.currentThread().getStackTrace()[2].toString());
+  }
+  
+  public void countExecutionPoint(final String key) {
+    Count c = counts.get(key);
+    if (c == null)
+      counts.put(key, c = new Count(key));
+    c.count++;
+  }
+
+  public static void main(String[] args) {
+    final Statistics s = new Statistics("test");
+    s.countExecutionPoint();
+    s.countExecutionPoint();
+    System.out.println(s);
+  }
+}
Index: src/examples/org/apache/hadoop/mp/util/Combinable.java
===================================================================
--- src/examples/org/apache/hadoop/mp/util/Combinable.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/util/Combinable.java	(revision 0)
@@ -0,0 +1,31 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.util;
+
+/**
+ * A class is Combinable if its object can be combined with other objects.
+ * @param <TYPE> The generic type
+ */
+public interface Combinable<TYPE> extends Comparable<TYPE> {
+  /**
+   * Combine this with that. 
+   * @param that Another object.
+   * @return The combined object.
+   */
+  public TYPE combine(TYPE that); 
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/util/Print.java
===================================================================
--- src/examples/org/apache/hadoop/mp/util/Print.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/util/Print.java	(revision 0)
@@ -0,0 +1,228 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.util;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.PrintStream;
+import java.util.Properties;
+import java.util.Stack;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+
+/** Utility methods */
+public class Print {
+  public enum Level {
+    TRACE, DEBUG, VERBOSE, INFO;
+    
+    public boolean is(Level that) {
+      return this.ordinal() <= that.ordinal();
+    }
+  }
+
+  /** Standard output stream */
+  public static final PrintStream out = System.out;
+  public static AtomicBoolean isOutEnabled = new AtomicBoolean(true);
+
+  /** Log file output stream */
+  public static PrintStream log = null;
+  
+  private static String prefix = "";
+  private static Stack<String> prefixStack = new Stack<String>();
+  
+  static void appendPrefix(String s) {
+    prefixStack.push(prefix);
+    prefix += s;
+  }
+
+  private static void appendPrefix() {
+    appendPrefix("  ");
+  }
+
+  private static void restorePrefix() {
+    prefix = prefixStack.pop();
+  }
+
+  public static File initLogFile(String filename) throws FileNotFoundException {
+    if (log != null)
+      throw new RuntimeException("fout != null");
+    final File f = JavaUtil.createFile(null, filename, ".log");
+    log = new PrintStream(new FileOutputStream(f), true);
+    Runtime.getRuntime().addShutdownHook(new Thread() {
+      @Override
+      public void run() {
+        if (log != null)
+          log.close();
+      }
+    });
+    return f;
+  }
+
+  public static void closeFileOutput(){
+    log.close();
+    log = null;
+  }
+
+  public static void print() {
+    if (log != null)
+      log.print(prefix);
+    if (isOutEnabled.get() && out != log)
+      out.print(prefix);
+  }
+
+  public static void print(Object obj) {
+    if (log != null) {
+      log.print(obj);
+      log.flush();
+    }
+    if (isOutEnabled.get() && out != log) {
+      out.print(obj);
+      out.flush();
+    }
+  }
+
+  public static void println() {
+    if (log != null)
+      log.println(prefix);
+    if (isOutEnabled.get() && out != log)
+      out.println(prefix);
+  }
+
+  public static void println(final Object obj) {
+    final String t = obj.toString();
+    for(int i = 0; i < t.length(); ) {
+      final int j = t.indexOf('\n', i);
+      final String s;
+      if (j >= 0) {
+        s = t.substring(i, j);
+        i = j + 1;
+      } else {
+        s = t.substring(i);
+        i = t.length();
+      }
+
+      if (log != null) {
+        log.print(prefix);
+        log.println(s);
+      }
+      if (isOutEnabled.get() && out != log) {
+        out.print(prefix);
+        out.println(s);
+      }
+    }
+  }
+
+  public static <T> void print(final Object name, final T[] x) {
+    if (x == null) {
+      println(name + " = null");
+    } else if (x.length == 0) {
+      println(name + " = <empty>");
+    } else {
+      beginIndentation(name + " = [#=" + x.length);
+      for(int i = 0; i < x.length; i++) {
+        println(i + ": " + x[i]);
+      }
+      endIndentation("]");
+    }
+  }
+
+  public static void beginIndentation(Object obj) {
+    if (prefix.isEmpty())
+      println();
+    println(obj);
+    appendPrefix();
+  }
+
+  public static void endIndentation(Object obj) {
+    endIndentation();
+    println(obj);
+  }
+  public static void endIndentation() {
+    restorePrefix();
+  }
+
+  public static void printStackTrace(final Throwable t) {
+    if (log != null)
+      t.printStackTrace(log);
+    if (isOutEnabled.get() && out != log)
+      t.printStackTrace(out);
+  }
+
+  public static String printSystemInfo() {
+    final String[] names = {
+        "java.runtime.name",
+        "java.runtime.version",
+        "java.vm.version",
+        "java.vm.vendor",
+        "java.vm.name",
+        "java.vm.info",
+        "java.vm.specification.version",
+        "os.arch",
+        "os.name",
+        "os.version",
+        "sun.cpu.isalist",
+        "sun.arch.data.model",
+    };
+    int width = names[0].length();
+    for(int i = 1; i < names.length; i++) {
+      int n = names[i].length();
+      if (n > width)
+        width = n;
+    }
+    final String f = "\n%" + width + "s = ";
+
+    final Properties p = System.getProperties();
+    for(String n : names) {
+      Print.print(String.format(f, n) + p.getProperty(n));
+    }
+    Print.println();
+
+    final Runtime r = Runtime.getRuntime();
+    Print.print(String.format(f, "availableProcessors") + r.availableProcessors());
+    
+    printMemoryInfo(f);
+    return f;
+  }
+
+  public static String printMemoryInfo() {
+    final String f = "\n%20s = ";
+    return printMemoryInfo(f);    
+  }
+
+  private static String printMemoryInfo(final String format) {
+    final String f = format + "%sB";
+    final Runtime r = Runtime.getRuntime();
+    Print.print(String.format(f, "maxMemory", Parse.TraditionalBinaryPrefix.long2string(r.maxMemory(), 2)));
+    Print.print(String.format(f, "totalMemory", Parse.TraditionalBinaryPrefix.long2string(r.totalMemory(), 2)));
+    Print.print(String.format(f, "freeMemory", Parse.TraditionalBinaryPrefix.long2string(r.freeMemory(), 2)));
+    Print.println();
+    Print.println();
+    return f;
+  }
+
+  public static interface Brief {
+    /** Return a brief description of the object. */
+    public String toBrief();
+  }
+
+  public static interface Detail {
+    /** Print a detail description of the object. */
+    public void printDetail(final String firstlineprefix);
+  }
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/util/Partitionable.java
===================================================================
--- src/examples/org/apache/hadoop/mp/util/Partitionable.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/util/Partitionable.java	(revision 0)
@@ -0,0 +1,33 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.util;
+
+import java.util.List;
+
+/**
+ * A class is {@link Partitionable} if it can be partitioned.
+ * @param <TYPE> The generic type
+ */
+public interface Partitionable<TYPE> {
+  /**
+   * Partition this object. 
+   * @param nParts The maximum number of parts.
+   * @return A list of partitions with size <= n.
+   */
+  public List<TYPE> partition(final int nParts);
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/util/serialization/DataSerializable.java
===================================================================
--- src/examples/org/apache/hadoop/mp/util/serialization/DataSerializable.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/util/serialization/DataSerializable.java	(revision 0)
@@ -0,0 +1,51 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.util.serialization;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.hadoop.io.Writable;
+import org.apache.hadoop.mp.util.Container;
+
+/** Serialize to {@link DataOutput} */
+public interface DataSerializable<R> {
+  /** Serialize to {@link DataOutput} */
+  public R serialize(final DataOutput out) throws IOException;
+
+  /** Value of {@link DataInput} */
+  public static interface ValueOf<R> {
+    /** Value of {@link DataInput} */
+    public R valueOf(DataInput in) throws IOException; 
+  }
+  
+  public static abstract class W<T extends DataSerializable<?>>
+      implements Container<T>, Writable {
+    private T item;
+
+    public final W<T> set(T item) {
+      this.item = item;
+      return this;
+    }
+    @Override
+    public final T get() {return item;}
+    @Override
+    public final void write(DataOutput out) throws IOException {item.serialize(out);}
+  }
+}
Index: src/examples/org/apache/hadoop/mp/util/serialization/ValueOf.java
===================================================================
--- src/examples/org/apache/hadoop/mp/util/serialization/ValueOf.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/util/serialization/ValueOf.java	(revision 0)
@@ -0,0 +1,24 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.util.serialization;
+
+
+public interface ValueOf<RETURN, PARAMETER, EXCEPTION extends Exception> {
+  /** @return The object represented by the parameter. */
+  public RETURN valueOf(PARAMETER p) throws EXCEPTION; 
+}
\ No newline at end of file
Index: src/examples/org/apache/hadoop/mp/util/serialization/StreamSerializable.java
===================================================================
--- src/examples/org/apache/hadoop/mp/util/serialization/StreamSerializable.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/util/serialization/StreamSerializable.java	(revision 0)
@@ -0,0 +1,34 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.util.serialization;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/** Serialize to {@link OutputStream} */
+public interface StreamSerializable<R, T extends OutputStream> {
+  /** Serialize to {@link OutputStream} */
+  public R serialize(final T out) throws IOException; 
+
+  /** Value of {@link InputStream} */
+  public static interface ValueOf<R, T extends InputStream> {
+    /** Value of {@link InputStream} */
+    public R valueOf(final T in) throws IOException; 
+  }
+}
Index: src/examples/org/apache/hadoop/mp/util/serialization/ConfSerializable.java
===================================================================
--- src/examples/org/apache/hadoop/mp/util/serialization/ConfSerializable.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/util/serialization/ConfSerializable.java	(revision 0)
@@ -0,0 +1,32 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.util.serialization;
+
+import org.apache.hadoop.conf.Configuration;
+
+/** Serialize to {@link Configuration} */
+public interface ConfSerializable {
+  /** Serialize to {@link Configuration} */
+  public void serialize(Configuration conf);
+
+  /** Value of {@link Configuration} */
+  public static interface ValueOf<R> {
+    /** Value of {@link Configuration} */
+    public R valueOf(final Configuration conf); 
+  }
+}
Index: src/examples/org/apache/hadoop/mp/util/serialization/StringSerializable.java
===================================================================
--- src/examples/org/apache/hadoop/mp/util/serialization/StringSerializable.java	(revision 0)
+++ src/examples/org/apache/hadoop/mp/util/serialization/StringSerializable.java	(revision 0)
@@ -0,0 +1,30 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.mp.util.serialization;
+
+/** Serialize to {@link String} */
+public interface StringSerializable {
+  /** Serialize to a {@link String} */
+  public String serialize();
+  
+  /** Value of a {@link String} */
+  public static interface ValueOf<R> {
+    /** Value of a {@link String} */
+    public R valueOf(final String s); 
+  }
+}
